
sender.elf:     file format elf32-msp430

SYMBOL TABLE:
0000c000 l    d  .text	00000000 .text
0000e35a l    d  .rodata	00000000 .rodata
00000200 l    d  .data	00000000 .data
0000022e l    d  .bss	00000000 .bss
000002e8 l    d  .noinit	00000000 .noinit
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 main_LinkTo.c
0000c12c l     F .text	0000005e sRxCallback
0000022e l     O .bss	00000001 sLinkID1
00000230 l     O .bss	00000001 sTxTid
0000022f l     O .bss	00000001 sRxTid
0000c110 l       .text	00000000 __br_unexpected_
00000000 l    df *ABS*	00000000 mrfi.c
0000c18a l     F .text	00000058 spiRegAccess
0000c1e2 l     F .text	00000048 Mrfi_DelayUsec
0000c22a l     F .text	000000b6 spiBurstFifoAccess
00000234 l     O .bss	00000018 mrfiIncomingPacket
0000024d l     O .bss	00000001 mrfiRndSeed
0000024e l     O .bss	00000002 sReplyDelayScalar
00000232 l     O .bss	00000001 sReplyDelayContext
00000233 l     O .bss	00000001 sKillSem
0000024c l     O .bss	00000001 mrfiRadioState
0000c48c l     F .text	0000002c Mrfi_RxModeOff
0000c4d8 l     F .text	00000014 Mrfi_RxModeOn
00000250 l     O .bss	00000002 sBackoffHelper
0000e39a l     O .rodata	00000004 mrfiLogicalChanTable
0000e39e l     O .rodata	00000003 mrfiRFPowerTable
0000e35e l     O .rodata	0000003c mrfiRadioCfg
00000200 l     O .data	00000004 mrfiRxFilterAddr
00000252 l     O .bss	00000001 mrfiRxFilterEnabled
00000000 l    df *ABS*	00000000 bsp.c
00000000 l    df *ABS*	00000000 nwk_api.c
00000254 l     O .bss	00000001 sInit_done
0000e3b4 l     O .rodata	00000006 CSWTCH.3
00000000 l    df *ABS*	00000000 nwk.c
00000204 l     O .data	0000002a sPersistInfo
00000000 l    df *ABS*	00000000 nwk_join.c
00000258 l     O .bss	00000004 sJoinToken
0000025c l     O .bss	00000002 spCallback
00000256 l     O .bss	00000001 sTid
00000000 l    df *ABS*	00000000 nwk_frame.c
0000025e l     O .bss	00000001 sMyTxType
00000260 l     O .bss	00000002 spCallback
00000262 l     O .bss	00000002 sMyAddr
00000264 l     O .bss	00000001 sTRACTID
0000e3ba l     O .rodata	0000000c func
00000000 l    df *ABS*	00000000 nwk_link.c
0000026c l     O .bss	00000004 sLinkToken
00000266 l     O .bss	00000001 sTid
00000268 l     O .bss	00000002 sServiceLinkID
0000026a l     O .bss	00000001 sListenActive
00000267 l     O .bss	00000001 sNumLinkers
00000000 l    df *ABS*	00000000 nwk_ioctl.c
0000e3c6 l     O .rodata	00000004 CSWTCH.1
00000000 l    df *ABS*	00000000 nwk_globals.c
00000270 l     O .bss	00000004 sAPAddress
00000274 l     O .bss	00000001 sRAMAddressIsSet
0000e3ca l     O .rodata	00000004 sMyROMAddress
00000276 l     O .bss	00000004 sMyRAMAddress
0000e3ce l     O .rodata	00000006 sVersionInfo
00000000 l    df *ABS*	00000000 nwk_freq.c
00000000 l    df *ABS*	00000000 nwk_ping.c
0000027a l     O .bss	00000001 sTid
00000000 l    df *ABS*	00000000 nwk_mgmt.c
0000027c l     O .bss	00000001 sTid
0000027e l     O .bss	00000002 sAPAddr
00000000 l    df *ABS*	00000000 nwk_security.c
00000000 l    df *ABS*	00000000 nwk_QMgmt.c
00000280 l     O .bss	00000034 sInFrameQ
000002b4 l     O .bss	00000034 sOutFrameQ
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
0000d596 g     F .text	000000e6 nwk_retrieveFrame
00000057 g       *ABS*	00000000 __BCSCTL1
0000005a g       *ABS*	00000000 __CACTL2
0000c366 g     F .text	00000076 MRFI_ReplyDelay
0000002e g       *ABS*	00000000 __data_size
00000166 g       *ABS*	00000000 __TA0CCTL2
0000c110  w      .text	00000000 __isr_14
0000c3f0 g     F .text	00000044 mrfiSpiInit
00000128 g       *ABS*	00000000 __FCTL1
00000192 g       *ABS*	00000000 __TA1CCR0
00000042 g       *ABS*	00000000 __P2SEL2
00000024 g       *ABS*	00000000 __P1IES
0000d6e8 g     F .text	00000014 nwk_setLinkToken
00000069 g       *ABS*	00000000 __UCB0CTL1
0000dc06 g     F .text	00000020 nwk_globalsInit
0000c110  w      .text	00000000 __isr_4
00000002 g       *ABS*	00000000 __IFG1
0000c63e g     F .text	0000014c MRFI_Transmit
00000060 g       *ABS*	00000000 __UCA0CTL0
0000d340 g     F .text	000000f2 nwk_join
0000e1f4 g     F .text	000000fa memmove
0000d2b4 g     F .text	0000003c nwk_putNumObjectIntoMsg
00000000 g       .vectors	00000000 _efartext
0000ceaa g     F .text	0000008c nwk_nwkInit
0000de2e g     F .text	0000006c nwk_poll
00000176 g       *ABS*	00000000 __TA0CCR2
0000c534 g     F .text	0000001a mrfiSpiReadReg
00000001 g       *ABS*	00000000 __IE2
0000da9c g     F .text	00000052 nwk_rawSend
0000dcbc g     F .text	000000c2 nwk_ping
0000d500 g     F .text	00000096 MRFI_RxCompleteISR
0000002b g       *ABS*	00000000 __P2IFG
0000001a g       *ABS*	00000000 __P3DIR
0000ca1e g     F .text	00000042 MRFI_RxAddrIsFiltered
0000e3d4 g       *ABS*	00000000 _etext
0000d004 g     F .text	00000042 nwk_isLinkDuplicate
000010f8 g       *ABS*	00000000 __CALDCO_16MHZ
0000c32a g     F .text	00000024 MRFI_RandomByte
000000ba g       *ABS*	00000000 __bss_size
0000d2a6 g     F .text	0000000e nwk_getNumObjectFromMsg
0000d70e g     F .text	00000176 nwk_link
000010fd g       *ABS*	00000000 __CALBC1_8MHZ
0000c000  w      .text	00000000 __watchdog_support
0000c10a  w      .text	00000000 __stop_progExec__
00000172 g       *ABS*	00000000 __TA0CCR0
0000e0fa g     F .text	000000fa memcpy
0000002d g       *ABS*	00000000 __P2IE
0000c3dc g     F .text	0000000e MRFI_PostKillSem
0000cfb2 g     F .text	00000006 nwk_freeConnection
0000ce04 g     F .text	000000a6 SMPL_Ioctl
0000d2f4 g     F .text	00000026 nwk_joinInit
0000cdfe g     F .text	00000006 SMPL_Link
0000c110  w      .text	00000000 __isr_11
00000160 g       *ABS*	00000000 __TA0CTL
00000025 g       *ABS*	00000000 __P1IE
0000006b g       *ABS*	00000000 __UCB0BR1
00000164 g       *ABS*	00000000 __TA0CCTL1
00000049 g       *ABS*	00000000 __ADC10DTC1
00000190 g       *ABS*	00000000 __TA1R
0000dcac g     F .text	00000002 nwk_freqInit
0000cc12 g     F .text	00000018 BSP_InitLeds
00000066 g       *ABS*	00000000 __UCA0RXBUF
00000061 g       *ABS*	00000000 __UCA0CTL1
00000170 g       *ABS*	00000000 __TA0R
0000cca0 g     F .text	00000080 SMPL_LinkListen
0000c2e0 g     F .text	0000004a MRFI_Receive
0000d32e g     F .text	00000012 nwk_getJoinToken
0000d46c g     F .text	00000094 nwk_buildFrame
0000c4ec g     F .text	00000020 MRFI_RxOn
0000cc66 g     F .text	0000003a SMPL_Init
0000cd9c g     F .text	00000008 SMPL_Send
00000180 g       *ABS*	00000000 __TA1CTL
0000c796 g     F .text	00000038 MRFI_SetLogicalChannel
0000c5ba g     F .text	00000018 mrfiSpiWriteReg
0000006d g       *ABS*	00000000 __UCB0STAT
0000c110  w      .text	00000000 __isr_5
00000063 g       *ABS*	00000000 __UCA0BR1
0000e3d4 g       *ABS*	00000000 __data_load_start
0000c110 g       .text	00000000 __dtors_end
00000053 g       *ABS*	00000000 __BCSCTL3
0000e0ca g     F .text	00000010 nwk_getQ
0000d046 g     F .text	0000004a nwk_findAddressMatch
000001bc g       *ABS*	00000000 __ADC10SA
0000d276 g     F .text	00000030 nwk_checkAppMsgTID
00000065 g       *ABS*	00000000 __UCA0STAT
0000c110  w      .text	00000000 __isr_2
0000012c g       *ABS*	00000000 __FCTL3
0000c110  w      .text	00000000 __isr_10
0000002e g       *ABS*	00000000 __P2SEL
000010f9 g       *ABS*	00000000 __CALBC1_16MHZ
0000012e g       *ABS*	00000000 __TA0IV
00000023 g       *ABS*	00000000 __P1IFG
000010fb g       *ABS*	00000000 __CALBC1_12MHZ
00000182 g       *ABS*	00000000 __TA1CCTL0
0000004a g       *ABS*	00000000 __ADC10AE0
0000011a g       *ABS*	00000000 __UCB0I2CSA
0000cba8 g     F .text	00000016 BSP_GpioPort1Isr
0000c114 g     F .text	00000018 toggleLED
00000056 g       *ABS*	00000000 __DCOCTL
0000c7ce g     F .text	0000003a MRFI_SetRFPwr
00000003 g       *ABS*	00000000 __IFG2
000002e8 g     O .noinit	00000002 __wdt_clear_value
0000db1a g     F .text	00000086 nwk_radioControl
0000c9f0 g     F .text	0000001e MRFI_EnableRxAddrFilter
0000001b g       *ABS*	00000000 __P3SEL
0000c110  w      .text	00000000 __isr_7
0000ffe0 g     O .vectors	00000020 __ivtbl_16
0000006c g       *ABS*	00000000 __UCB0I2CIE
0000006a g       *ABS*	00000000 __UCB0BR0
00000028 g       *ABS*	00000000 __P2IN
00000118 g       *ABS*	00000000 __UCB0I2COA
000001b4 g       *ABS*	00000000 __ADC10MEM
0000005b g       *ABS*	00000000 __CAPD
0000df92 g     F .text	00000138 nwk_QfindOldest
0000c54e g     F .text	0000006c MRFI_Rssi
0000c110  w      .text	00000000 __isr_0
0000daee g     F .text	0000002c nwk_rawReceive
0000ddf6 g     F .text	00000038 nwk_processMgmt
00000029 g       *ABS*	00000000 __P2OUT
0000012a g       *ABS*	00000000 __FCTL2
00000064 g       *ABS*	00000000 __UCA0MCTL
00000043 g       *ABS*	00000000 __P3SEL2
0000c028  w      .text	00000000 __do_clear_bss
0000c808 g     F .text	000001ba MRFI_Init
00000021 g       *ABS*	00000000 __P1OUT
0000002c g       *ABS*	00000000 __P2IES
00000026 g       *ABS*	00000000 __P1SEL
0000d0b8 g     F .text	00000062 nwk_isConnectionValid
0000d31a g     F .text	00000014 nwk_setJoinToken
00000027 g       *ABS*	00000000 __P1REN
0000e358  w      .text	00000000 _unexpected_
0000c110  w      .text	00000000 __isr_8
0000dc38 g     F .text	00000006 nwk_getFWVersion
0000011e g       *ABS*	00000000 __TA1IV
0000cba8 g       .text	00000000 __isr_3
0000e0da g     F .text	00000020 memcmp
000010fc g       *ABS*	00000000 __CALDCO_8MHZ
0000dc64 g     F .text	0000001a nwk_setAPAddress
0000dca6 g     F .text	00000006 nwk_getBCastAddress
0000c000  w      .text	00000000 _reset_vector__
0000c110 g       .text	00000000 __ctors_start
0000c3ea g     F .text	00000006 MRFI_GetRadioState
0000cbc8 g     F .text	0000001c BSP_InitBoard
0000c110  w      .text	00000000 __isr_12
000010fa g       *ABS*	00000000 __CALDCO_12MHZ
0000c5d2 g     F .text	0000005e MRFI_WakeUp
00000018 g       *ABS*	00000000 __P3IN
0000c010  w      .text	00000000 __do_copy_data
0000d1f2 g     F .text	00000042 nwk_isValidReply
0000d44e g     F .text	0000001e nwk_frameInit
00000162 g       *ABS*	00000000 __TA0CCTL0
0000dcae g     F .text	00000004 nwk_processFreq
0000022e g       .bss	00000000 __bss_start
0000dcb2 g     F .text	0000000a nwk_pingInit
0000df02 g     F .text	00000090 nwk_QfindSlot
0000cfb8 g     F .text	0000004c nwk_getConnInfo
0000e2ee g     F .text	0000006a memset
0000c03e g     F .text	000000cc main
0000cc2a g     F .text	0000000e BSP_InitDrivers
0000c110  w      .text	00000000 __isr_13
0000c434 g     F .text	00000058 mrfiSpiCmdStrobe
0000c50c g     F .text	00000028 MRFI_Sleep
0000d6b2 g     F .text	00000004 nwk_getMyRxType
0000d6fc g     F .text	00000012 nwk_getLinkToken
0000dc3e g     F .text	00000004 nwk_getProtocolVersion
0000dc42 g     F .text	00000022 nwk_setMyAddress
00010000 g       .vectors	00000000 _vectors_end
0000dc7e g     F .text	00000028 nwk_getAPAddress
0000002a g       *ABS*	00000000 __P2DIR
00000174 g       *ABS*	00000000 __TA0CCR1
00000186 g       *ABS*	00000000 __TA1CCTL2
00000068 g       *ABS*	00000000 __UCB0CTL0
0000002f g       *ABS*	00000000 __P2REN
0000ddec g     F .text	0000000a nwk_mgmtInit
0000d67c g     F .text	00000036 nwk_sendFrame
0000da32 g     F .text	0000005c nwk_getLocalLinkID
0000006e g       *ABS*	00000000 __UCB0RXBUF
000001b0 g       *ABS*	00000000 __ADC10CTL0
0000c110  w      .text	00000000 __isr_9
0000005e g       *ABS*	00000000 __UCA0IRTCTL
000010fe g       *ABS*	00000000 __CALDCO_1MHZ
00000067 g       *ABS*	00000000 __UCA0TXBUF
00000184 g       *ABS*	00000000 __TA1CCTL1
0000d11a g     F .text	000000d8 nwk_allocateLocalRxPort
0000ca0e g     F .text	00000010 MRFI_DisableRxAddrFilter
0000c00c  w      .text	00000000 __init_stack
0000005d g       *ABS*	00000000 __UCA0ABCTL
0000cda4 g     F .text	0000005a SMPL_Receive
00000019 g       *ABS*	00000000 __P3OUT
0000dd7e g     F .text	0000006e nwk_processPing
00000196 g       *ABS*	00000000 __TA1CCR2
0000c110 g       .text	00000000 __dtors_start
0000c110  w      .text	00000000 __isr_6
0000c110 g       .text	00000000 __ctors_end
0000d6b6 g     F .text	00000032 nwk_linkInit
00000194 g       *ABS*	00000000 __TA1CCR1
00000062 g       *ABS*	00000000 __UCA0BR0
00000400 g       *ABS*	00000000 __stack
0000d432 g     F .text	0000001c nwk_processJoin
0000c110  w      .text	00000000 __isr_1
0000022e g       .data	00000000 _edata
0000cf36 g     F .text	0000007c nwk_getNextConnection
000002ea g       *ABS*	00000000 _end
0000cbe4 g     F .text	0000002e BSP_Delay
0000e35a g     O .rodata	00000004 mrfiBroadcastAddr
0000d234 g     F .text	00000042 nwk_findPeer
00000048 g       *ABS*	00000000 __ADC10DTC0
0000d884 g     F .text	000001ae nwk_processLink
0000c4b8 g     F .text	00000020 MRFI_RxIdle
0000dbe0 g     F .text	00000026 nwk_connectionControl
000001b2 g       *ABS*	00000000 __ADC10CTL1
0000c9c2 g     F .text	0000002e MRFI_SetRxAddrFilter
0000dea0 g     F .text	0000001e nwk_QInit
00000058 g       *ABS*	00000000 __BCSCTL2
0000c10a  w      .text	00000000 _endless_loop__
0000dba0 g     F .text	00000040 nwk_deviceAddress
00000041 g       *ABS*	00000000 __P1SEL2
0000cbbe g     F .text	0000000a BSP_EARLY_INIT
00000022 g       *ABS*	00000000 __P1DIR
0000cc38 g     F .text	00000024 BSP_Init
0000de9c g     F .text	00000004 nwk_processSecurity
0000005f g       *ABS*	00000000 __UCA0IRRCTL
00000010 g       *ABS*	00000000 __P3REN
0000d2f0 g     F .text	00000004 nwk_NVObj
0000006f g       *ABS*	00000000 __UCB0TXBUF
000010ff g       *ABS*	00000000 __CALBC1_1MHZ
0000da8e g     F .text	0000000e nwk_setListenContext
0000c010  w      .text	00000000 __low_level_init
0000cd20 g     F .text	0000007c SMPL_SendOpt
00000200 g       .data	00000000 __data_start
00000120 g       *ABS*	00000000 __WDTCTL
0000debe g     F .text	00000044 nwk_QadjustOrder
00000000 g       *ABS*	00000000 __IE1
0000d090 g     F .text	00000028 nwk_checkConnInfo
0000dc26 g     F .text	00000012 nwk_getMyAddress
0000cc5c g     F .text	0000000a BSP_InitButtons
0000c78a g     F .text	0000000c mrfiSpiReadRxFifo
0000c34e g     F .text	00000018 MRFI_DelayMs
00000059 g       *ABS*	00000000 __CACTL1
0000c630 g     F .text	0000000e mrfiSpiWriteTxFifo
00000020 g       *ABS*	00000000 __P1IN
0000de9a g     F .text	00000002 nwk_securityInit
0000ca60 g     F .text	00000148 MRFI_GpioIsr



Disassembly of section .text:

0000c000 <__watchdog_support>:
    c000:	55 42 20 01 	mov.b	&0x0120,r5	
    c004:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08
    c008:	82 45 e8 02 	mov	r5,	&0x02e8	

0000c00c <__init_stack>:
    c00c:	31 40 00 04 	mov	#1024,	r1	;#0x0400

0000c010 <__do_copy_data>:
    c010:	3f 40 2e 00 	mov	#46,	r15	;#0x002e
    c014:	0f 93       	tst	r15		
    c016:	08 24       	jz	$+18     	;abs 0xc028
    c018:	92 42 e8 02 	mov	&0x02e8,&0x0120	
    c01c:	20 01 
    c01e:	2f 83       	decd	r15		
    c020:	9f 4f d4 e3 	mov	-7212(r15),512(r15);0xe3d4(r15), 0x0200(r15)
    c024:	00 02 
    c026:	f8 23       	jnz	$-14     	;abs 0xc018

0000c028 <__do_clear_bss>:
    c028:	3f 40 ba 00 	mov	#186,	r15	;#0x00ba
    c02c:	0f 93       	tst	r15		
    c02e:	07 24       	jz	$+16     	;abs 0xc03e
    c030:	92 42 e8 02 	mov	&0x02e8,&0x0120	
    c034:	20 01 
    c036:	1f 83       	dec	r15		
    c038:	cf 43 2e 02 	mov.b	#0,	558(r15);r3 As==00, 0x022e(r15)
    c03c:	f9 23       	jnz	$-12     	;abs 0xc030

0000c03e <main>:
static uint8_t sRxCallback(linkID_t);

#define SPIN_ABOUT_A_SECOND  NWK_DELAY(100)

void main (void)
{
    c03e:	21 83       	decd	r1		
  WDTCTL = WDTPW + WDTHOLD;
    c040:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    c044:	20 01 
  BSP_Init();
    c046:	b0 12 38 cc 	call	#0xcc38	
  /* This call will fail because the join will fail since there is no Access Point 
   * in this scenario. But we don't care -- just use the default link token later. 
   * We supply a callback pointer to handle the message returned by the peer. 
   */

  SMPL_Init(sRxCallback);
    c04a:	3f 40 2c c1 	mov	#-16084,r15	;#0xc12c
    c04e:	b0 12 66 cc 	call	#0xcc66	


  /* turn on LEDs alternatively */
  toggleLED(1);
    c052:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c054:	b0 12 14 c1 	call	#0xc114	
  toggleLED(2);
    c058:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c05a:	b0 12 14 c1 	call	#0xc114	
  NWK_DELAY(200);
    c05e:	3f 40 c8 00 	mov	#200,	r15	;#0x00c8
    c062:	b0 12 4e c3 	call	#0xc34e	
    c066:	3b 40 06 00 	mov	#6,	r11	;#0x0006
    c06a:	36 3c       	jmp	$+110    	;abs 0xc0d8
  uint8_t  msg[2];

  while (SMPL_SUCCESS != SMPL_Link(&sLinkID1))
  {
    /* blink red LED, until we link successfully */
    toggleLED(1);
    c06c:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c06e:	b0 12 14 c1 	call	#0xc114	
    NWK_DELAY(1000);//SPIN_ABOUT_A_SECOND;
    c072:	3f 40 e8 03 	mov	#1000,	r15	;#0x03e8
    c076:	b0 12 4e c3 	call	#0xc34e	

static void linkTo()
{
  uint8_t  msg[2];

  while (SMPL_SUCCESS != SMPL_Link(&sLinkID1))
    c07a:	3f 40 2e 02 	mov	#558,	r15	;#0x022e
    c07e:	b0 12 fe cd 	call	#0xcdfe	
    c082:	0f 93       	tst	r15		
    c084:	f3 23       	jnz	$-24     	;abs 0xc06c
    toggleLED(1);
    NWK_DELAY(1000);//SPIN_ABOUT_A_SECOND;
  }

  /* we're linked. turn off LEDs. Received messages will toggle the green LED. */
  if (BSP_LED1_IS_ON())
    c086:	5f 42 21 00 	mov.b	&0x0021,r15	
    c08a:	1f f3       	and	#1,	r15	;r3 As==01
    c08c:	03 24       	jz	$+8      	;abs 0xc094
  {
    toggleLED(1);
    c08e:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c090:	b0 12 14 c1 	call	#0xc114	
  }

  if (BSP_LED2_IS_ON())
    c094:	5f 42 29 00 	mov.b	&0x0029,r15	
    c098:	3f f0 20 00 	and	#32,	r15	;#0x0020
    c09c:	03 24       	jz	$+8      	;abs 0xc0a4
  {
    toggleLED(2);
    c09e:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c0a0:	b0 12 14 c1 	call	#0xc114	
  }
  
  /* turn on RX. default is RX off. */
  SMPL_Ioctl( IOCTL_OBJ_RADIO, IOCTL_ACT_RADIO_RXON, 0);
    c0a4:	0d 43       	clr	r13		
    c0a6:	3e 42       	mov	#8,	r14	;r2 As==11
    c0a8:	3f 40 03 00 	mov	#3,	r15	;#0x0003
    c0ac:	b0 12 04 ce 	call	#0xce04	

  /* put LED to toggle in the message */
  msg[0] = 2;  /* toggle green */
    c0b0:	e1 43 00 00 	mov.b	#2,	0(r1)	;r3 As==10, 0x0000(r1)
  while (1)
  {
    SPIN_ABOUT_A_SECOND;
    c0b4:	3f 40 64 00 	mov	#100,	r15	;#0x0064
    c0b8:	b0 12 4e c3 	call	#0xc34e	

    /* put the sequence ID in the message */
    msg[1] = ++sTxTid;
    c0bc:	5f 42 30 02 	mov.b	&0x0230,r15	
    c0c0:	5f 53       	inc.b	r15		
    c0c2:	c2 4f 30 02 	mov.b	r15,	&0x0230	
    c0c6:	c1 4f 01 00 	mov.b	r15,	1(r1)	;0x0001(r1)
    SMPL_Send(sLinkID1, msg, sizeof(msg));
    c0ca:	6d 43       	mov.b	#2,	r13	;r3 As==10
    c0cc:	0e 41       	mov	r1,	r14	
    c0ce:	5f 42 2e 02 	mov.b	&0x022e,r15	
    c0d2:	b0 12 9c cd 	call	#0xcd9c	
    c0d6:	ee 3f       	jmp	$-34     	;abs 0xc0b4
  toggleLED(2);
  NWK_DELAY(200);
  int i,j;
  for (i = 6; --i >= 0; ) {
    for (j = 1; j<=3 ; j++) {
      toggleLED(j);
    c0d8:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c0da:	b0 12 14 c1 	call	#0xc114	
      NWK_DELAY(120);
    c0de:	3f 40 78 00 	mov	#120,	r15	;#0x0078
    c0e2:	b0 12 4e c3 	call	#0xc34e	
  toggleLED(2);
  NWK_DELAY(200);
  int i,j;
  for (i = 6; --i >= 0; ) {
    for (j = 1; j<=3 ; j++) {
      toggleLED(j);
    c0e6:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c0e8:	b0 12 14 c1 	call	#0xc114	
      NWK_DELAY(120);
    c0ec:	3f 40 78 00 	mov	#120,	r15	;#0x0078
    c0f0:	b0 12 4e c3 	call	#0xc34e	
  toggleLED(2);
  NWK_DELAY(200);
  int i,j;
  for (i = 6; --i >= 0; ) {
    for (j = 1; j<=3 ; j++) {
      toggleLED(j);
    c0f4:	7f 40 03 00 	mov.b	#3,	r15	;#0x0003
    c0f8:	b0 12 14 c1 	call	#0xc114	
      NWK_DELAY(120);
    c0fc:	3f 40 78 00 	mov	#120,	r15	;#0x0078
    c100:	b0 12 4e c3 	call	#0xc34e	
    c104:	3b 53       	add	#-1,	r11	;r3 As==11
  /* turn on LEDs alternatively */
  toggleLED(1);
  toggleLED(2);
  NWK_DELAY(200);
  int i,j;
  for (i = 6; --i >= 0; ) {
    c106:	e8 23       	jnz	$-46     	;abs 0xc0d8
    c108:	b8 3f       	jmp	$-142    	;abs 0xc07a

0000c10a <__stop_progExec__>:
    c10a:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    c10e:	fd 3f       	jmp	$-4      	;abs 0xc10a

0000c110 <__ctors_end>:
    c110:	30 40 58 e3 	br	#0xe358	

0000c114 <toggleLED>:
}


void toggleLED(uint8_t which)
{
  switch(which)
    c114:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    c116:	07 24       	jz	$+16     	;abs 0xc126
    c118:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    c11a:	01 24       	jz	$+4      	;abs 0xc11e
    c11c:	30 41       	ret			
   {
    case 1 :
      BSP_TOGGLE_LED1();
      break;
    case 2 :
      BSP_TOGGLE_LED2();
    c11e:	f2 e0 20 00 	xor.b	#32,	&0x0029	;#0x0020
    c122:	29 00 
    c124:	30 41       	ret			
void toggleLED(uint8_t which)
{
  switch(which)
   {
    case 1 :
      BSP_TOGGLE_LED1();
    c126:	d2 e3 21 00 	xor.b	#1,	&0x0021	;r3 As==01
    c12a:	30 41       	ret			

0000c12c <sRxCallback>:
}


/* handle received frames. */
static uint8_t sRxCallback(linkID_t port)
{
    c12c:	0b 12       	push	r11		
    c12e:	21 82       	sub	#4,	r1	;r2 As==10
  uint8_t msg[2], len, tid;

  /* is the callback for the link ID we want to handle? */
  if (port == sLinkID1)
    c130:	5f 92 2e 02 	cmp.b	&0x022e,r15	
    c134:	04 24       	jz	$+10     	;abs 0xc13e
       /* drop frame. we're done with it. */
       return 1;
     }
  }
  /* keep frame for later handling. */
  return 0;
    c136:	4f 43       	clr.b	r15		
}
    c138:	21 52       	add	#4,	r1	;r2 As==10
    c13a:	3b 41       	pop	r11		
    c13c:	30 41       	ret			

  /* is the callback for the link ID we want to handle? */
  if (port == sLinkID1)
  {
    /* yes. go get the frame. we know this call will succeed. */
     if ((SMPL_SUCCESS == SMPL_Receive(sLinkID1, msg, &len)) && len)
    c13e:	0d 41       	mov	r1,	r13	
    c140:	0e 41       	mov	r1,	r14	
    c142:	1e 53       	inc	r14		
    c144:	b0 12 a4 cd 	call	#0xcda4	
    c148:	0f 93       	tst	r15		
    c14a:	f5 23       	jnz	$-20     	;abs 0xc136
    c14c:	c1 93 00 00 	tst.b	0(r1)		;0x0000(r1)
    c150:	f2 27       	jz	$-26     	;abs 0xc136
     {
       /* Check the application sequence number to detect
        * late or missing frames... 
        */
       tid = *(msg+1);
    c152:	5b 41 02 00 	mov.b	2(r1),	r11	;0x0002(r1)
       if (tid)
    c156:	4b 93       	tst.b	r11		
    c158:	05 24       	jz	$+12     	;abs 0xc164
       {
         if (tid > sRxTid)
    c15a:	c2 9b 2f 02 	cmp.b	r11,	&0x022f	
    c15e:	0d 28       	jnc	$+28     	;abs 0xc17a
           toggleLED(*msg);
           sRxTid = tid;
         }
       }
       /* drop frame. we're done with it. */
       return 1;
    c160:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c162:	ea 3f       	jmp	$-42     	;abs 0xc138
         }
       }
       else
       {
         /* the wrap case... */
         if (sRxTid)
    c164:	c2 93 2f 02 	tst.b	&0x022f	
    c168:	fb 27       	jz	$-8      	;abs 0xc160
         {
           /* we're good. toggle LED in the message */
           toggleLED(*msg);
    c16a:	5f 41 01 00 	mov.b	1(r1),	r15	;0x0001(r1)
    c16e:	b0 12 14 c1 	call	#0xc114	
           sRxTid = tid;
    c172:	c2 43 2f 02 	mov.b	#0,	&0x022f	;r3 As==00
         }
       }
       /* drop frame. we're done with it. */
       return 1;
    c176:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c178:	df 3f       	jmp	$-64     	;abs 0xc138
       if (tid)
       {
         if (tid > sRxTid)
         {
           /* we're good. toggle LED in the message */
           toggleLED(*msg);
    c17a:	5f 41 01 00 	mov.b	1(r1),	r15	;0x0001(r1)
    c17e:	b0 12 14 c1 	call	#0xc114	
           sRxTid = tid;
    c182:	c2 4b 2f 02 	mov.b	r11,	&0x022f	
           toggleLED(*msg);
           sRxTid = tid;
         }
       }
       /* drop frame. we're done with it. */
       return 1;
    c186:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c188:	d7 3f       	jmp	$-80     	;abs 0xc138

0000c18a <spiRegAccess>:
static uint8_t spiRegAccess(uint8_t addrByte, uint8_t writeValue)
{
  uint8_t readValue;
  mrfiSpiIState_t s;

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );   /* SPI is not initialized */
    c18a:	5d 42 68 00 	mov.b	&0x0068,r13	
    c18e:	3d f2       	and	#8,	r13	;r2 As==11
    c190:	03 20       	jnz	$+8      	;abs 0xc198
    c192:	32 c2       	dint			
    c194:	03 43       	nop			
    c196:	ff 3f       	jmp	$+0      	;abs 0xc196

  /* disable interrupts that use SPI */
  MRFI_SPI_ENTER_CRITICAL_SECTION(s);
    c198:	0c 42       	mov	r2,	r12	
    c19a:	32 c2       	dint			
    c19c:	03 43       	nop			

  /* turn chip select "off" and then "on" to clear any current SPI access */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c19e:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c1a2:	21 00 
  MRFI_SPI_TURN_CHIP_SELECT_ON();
    c1a4:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c1a8:	21 00 

  /* send register address byte, the read/write bit is already configured */
  MRFI_SPI_WRITE_BYTE(addrByte);
    c1aa:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c1ae:	03 00 
    c1b0:	c2 4f 6f 00 	mov.b	r15,	&0x006f	
  MRFI_SPI_WAIT_DONE();
    c1b4:	5f 42 03 00 	mov.b	&0x0003,r15	
    c1b8:	2f f2       	and	#4,	r15	;r2 As==10
    c1ba:	fc 27       	jz	$-6      	;abs 0xc1b4

  /*
   *  Send the byte value to write.  If this operation is a read, this value
   *  is not used and is just dummy data.  Wait for SPI access to complete.
   */
  MRFI_SPI_WRITE_BYTE(writeValue);
    c1bc:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c1c0:	03 00 
    c1c2:	c2 4e 6f 00 	mov.b	r14,	&0x006f	
  MRFI_SPI_WAIT_DONE();
    c1c6:	5f 42 03 00 	mov.b	&0x0003,r15	
    c1ca:	2f f2       	and	#4,	r15	;r2 As==10
    c1cc:	fc 27       	jz	$-6      	;abs 0xc1c6
  /*
   *  If this is a read operation, SPI data register now contains the register
   *  value which will be returned.  For a read operation, it contains junk info
   *  that is not used.
   */
  readValue = MRFI_SPI_READ_BYTE();
    c1ce:	5f 42 6e 00 	mov.b	&0x006e,r15	

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c1d2:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c1d6:	21 00 
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c1d8:	3c b2       	bit	#8,	r12	;r2 As==11
    c1da:	01 20       	jnz	$+4      	;abs 0xc1de

  /* return the register value */
  return(readValue);
}
    c1dc:	30 41       	ret			
   */
  readValue = MRFI_SPI_READ_BYTE();

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c1de:	32 d2       	eint			

  /* return the register value */
  return(readValue);
}
    c1e0:	30 41       	ret			

0000c1e2 <Mrfi_DelayUsec>:
 *
 * @return      none
 ****************************************************************************************************
 */
static void Mrfi_DelayUsec(uint16_t howLong)
{
    c1e2:	0b 12       	push	r11		
    c1e4:	0a 12       	push	r10		
  bspIState_t s;
  uint16_t count = howLong/MRFI_MAX_DELAY_US;

  if (howLong)
    c1e6:	0f 93       	tst	r15		
    c1e8:	1d 24       	jz	$+60     	;abs 0xc224
 ****************************************************************************************************
 */
static void Mrfi_DelayUsec(uint16_t howLong)
{
  bspIState_t s;
  uint16_t count = howLong/MRFI_MAX_DELAY_US;
    c1ea:	0b 4f       	mov	r15,	r11	
    c1ec:	12 c3       	clrc			
    c1ee:	0b 10       	rrc	r11		
    c1f0:	12 c3       	clrc			
    c1f2:	0b 10       	rrc	r11		
    c1f4:	12 c3       	clrc			
    c1f6:	0b 10       	rrc	r11		
    c1f8:	12 c3       	clrc			
    c1fa:	0b 10       	rrc	r11		
    c1fc:	05 3c       	jmp	$+12     	;abs 0xc208
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
      BSP_EXIT_CRITICAL_SECTION(s);
    } while (count--);
    c1fe:	0f 4b       	mov	r11,	r15	
    c200:	3f 53       	add	#-1,	r15	;r3 As==11
    c202:	0b 93       	tst	r11		
    c204:	0f 24       	jz	$+32     	;abs 0xc224
    c206:	0b 4f       	mov	r15,	r11	

  if (howLong)
  {
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
    c208:	0a 42       	mov	r2,	r10	
    c20a:	32 c2       	dint			
    c20c:	03 43       	nop			
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
    c20e:	3f 40 10 00 	mov	#16,	r15	;#0x0010
    c212:	b0 12 e4 cb 	call	#0xcbe4	
      BSP_EXIT_CRITICAL_SECTION(s);
    c216:	3a b2       	bit	#8,	r10	;r2 As==11
    c218:	f2 27       	jz	$-26     	;abs 0xc1fe
    c21a:	32 d2       	eint			
    } while (count--);
    c21c:	0f 4b       	mov	r11,	r15	
    c21e:	3f 53       	add	#-1,	r15	;r3 As==11
    c220:	0b 93       	tst	r11		
    c222:	f1 23       	jnz	$-28     	;abs 0xc206
  }

  return;
}
    c224:	3a 41       	pop	r10		
    c226:	3b 41       	pop	r11		
    c228:	30 41       	ret			

0000c22a <spiBurstFifoAccess>:
 *
 * @return      none
 *=================================================================================================
 */
static void spiBurstFifoAccess(uint8_t addrByte, uint8_t * pData, uint8_t len)
{
    c22a:	0b 12       	push	r11		
    c22c:	4b 4f       	mov.b	r15,	r11	
  mrfiSpiIState_t s;

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );   /* SPI is not initialized */
    c22e:	5f 42 68 00 	mov.b	&0x0068,r15	
    c232:	3f f2       	and	#8,	r15	;r2 As==11
    c234:	52 24       	jz	$+166    	;abs 0xc2da
  MRFI_SPI_ASSERT(len != 0);                      /* zero length is not allowed */
    c236:	4d 93       	tst.b	r13		
    c238:	4d 24       	jz	$+156    	;abs 0xc2d4
  MRFI_SPI_ASSERT(addrByte & BURST_BIT);          /* only burst mode supported */
    c23a:	3b b0 40 00 	bit	#64,	r11	;#0x0040
    c23e:	03 20       	jnz	$+8      	;abs 0xc246
    c240:	32 c2       	dint			
    c242:	03 43       	nop			
    c244:	ff 3f       	jmp	$+0      	;abs 0xc244

  /* disable interrupts that use SPI */
  MRFI_SPI_ENTER_CRITICAL_SECTION(s);
    c246:	0f 42       	mov	r2,	r15	
    c248:	3f f2       	and	#8,	r15	;r2 As==11
    c24a:	32 c2       	dint			
    c24c:	03 43       	nop			

  /* turn chip select "off" and then "on" to clear any current SPI access */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c24e:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c252:	21 00 
  MRFI_SPI_TURN_CHIP_SELECT_ON();
    c254:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c258:	21 00 
   *  the start of this loop.  Loop exits when nothing left to transfer.
   */
  do
  {
    /* send FIFO access command byte, wait for SPI access to complete */
    MRFI_SPI_WRITE_BYTE(addrByte);
    c25a:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c25e:	03 00 
    c260:	c2 4b 6f 00 	mov.b	r11,	&0x006f	
    MRFI_SPI_WAIT_DONE();
    c264:	5c 42 03 00 	mov.b	&0x0003,r12	
    c268:	2c f2       	and	#4,	r12	;r2 As==10
    c26a:	fc 27       	jz	$-6      	;abs 0xc264
     *  Inner loop.  This loop executes as long as the SPI access is not interrupted.
     *  Loop completes when nothing left to transfer.
     */
    do
    {
      MRFI_SPI_WRITE_BYTE(*pData);
    c26c:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c270:	03 00 
    c272:	e2 4e 6f 00 	mov.b	@r14,	&0x006f	
       *  Use idle time.  Perform increment/decrement operations before pending on
       *  completion of SPI access.
       *
       *  Decrement the length counter.  Wait for SPI access to complete.
       */
      len--;
    c276:	7d 53       	add.b	#-1,	r13	;r3 As==11
      MRFI_SPI_WAIT_DONE();
    c278:	5c 42 03 00 	mov.b	&0x0003,r12	
    c27c:	2c f2       	and	#4,	r12	;r2 As==10
    c27e:	fc 27       	jz	$-6      	;abs 0xc278

      /*-------------------------------------------------------------------------------
       *  SPI data register holds data just read.  If this is a read operation,
       *  store the value into memory.
       */
      if (addrByte & READ_BIT)
    c280:	4b 93       	tst.b	r11		
    c282:	17 38       	jl	$+48     	;abs 0xc2b2
       *  critical interrupts that might be pending.
       *
       *  To improve latency, take care of pointer increment within the interrupt
       *  enabled window.
       */
      MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c284:	0f 93       	tst	r15		
    c286:	13 20       	jnz	$+40     	;abs 0xc2ae
      pData++;
    c288:	1e 53       	inc	r14		
      MRFI_SPI_ENTER_CRITICAL_SECTION(s);
    c28a:	0f 42       	mov	r2,	r15	
    c28c:	3f f2       	and	#8,	r15	;r2 As==11
    c28e:	32 c2       	dint			
    c290:	03 43       	nop			
       *  If chip select is "off" the SPI access was interrupted (all SPI access
       *  functions leave chip select in the "off" state).  In this case, turn
       *  back on chip select and break to the main loop.  The main loop will
       *  pick up where the access was interrupted.
       */
      if (MRFI_SPI_CHIP_SELECT_IS_OFF())
    c292:	5c 42 21 00 	mov.b	&0x0021,r12	
    c296:	3c f0 10 00 	and	#16,	r12	;#0x0010
    c29a:	0f 20       	jnz	$+32     	;abs 0xc2ba
        break;
      }

    /*-------------------------------------------------------------------------------
     */
    } while (len); /* inner loop */
    c29c:	4d 93       	tst.b	r13		
    c29e:	e6 23       	jnz	$-50     	;abs 0xc26c
  } while (len);   /* main loop */

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c2a0:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c2a4:	21 00 
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c2a6:	0f 93       	tst	r15		
    c2a8:	12 20       	jnz	$+38     	;abs 0xc2ce
}
    c2aa:	3b 41       	pop	r11		
    c2ac:	30 41       	ret			
       *  critical interrupts that might be pending.
       *
       *  To improve latency, take care of pointer increment within the interrupt
       *  enabled window.
       */
      MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c2ae:	32 d2       	eint			
    c2b0:	eb 3f       	jmp	$-40     	;abs 0xc288
       *  SPI data register holds data just read.  If this is a read operation,
       *  store the value into memory.
       */
      if (addrByte & READ_BIT)
      {
        *pData = MRFI_SPI_READ_BYTE();
    c2b2:	de 42 6e 00 	mov.b	&0x006e,0(r14)	;0x0000(r14)
    c2b6:	00 00 
    c2b8:	e5 3f       	jmp	$-52     	;abs 0xc284
       *  back on chip select and break to the main loop.  The main loop will
       *  pick up where the access was interrupted.
       */
      if (MRFI_SPI_CHIP_SELECT_IS_OFF())
      {
        MRFI_SPI_TURN_CHIP_SELECT_ON();
    c2ba:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c2be:	21 00 
      }

    /*-------------------------------------------------------------------------------
     */
    } while (len); /* inner loop */
  } while (len);   /* main loop */
    c2c0:	4d 93       	tst.b	r13		
    c2c2:	cb 23       	jnz	$-104    	;abs 0xc25a

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c2c4:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c2c8:	21 00 
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c2ca:	0f 93       	tst	r15		
    c2cc:	ee 27       	jz	$-34     	;abs 0xc2aa
    c2ce:	32 d2       	eint			
}
    c2d0:	3b 41       	pop	r11		
    c2d2:	30 41       	ret			
static void spiBurstFifoAccess(uint8_t addrByte, uint8_t * pData, uint8_t len)
{
  mrfiSpiIState_t s;

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );   /* SPI is not initialized */
  MRFI_SPI_ASSERT(len != 0);                      /* zero length is not allowed */
    c2d4:	32 c2       	dint			
    c2d6:	03 43       	nop			
    c2d8:	ff 3f       	jmp	$+0      	;abs 0xc2d8
 */
static void spiBurstFifoAccess(uint8_t addrByte, uint8_t * pData, uint8_t len)
{
  mrfiSpiIState_t s;

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );   /* SPI is not initialized */
    c2da:	32 c2       	dint			
    c2dc:	03 43       	nop			
    c2de:	ff 3f       	jmp	$+0      	;abs 0xc2de

0000c2e0 <MRFI_Receive>:
 * @return      none
 **************************************************************************************************
 */
void MRFI_Receive(mrfiPacket_t * pPacket)
{
  *pPacket = mrfiIncomingPacket;
    c2e0:	3e 40 34 02 	mov	#564,	r14	;#0x0234
    c2e4:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c2e8:	2f 53       	incd	r15		
    c2ea:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c2ee:	2f 53       	incd	r15		
    c2f0:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c2f4:	2f 53       	incd	r15		
    c2f6:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c2fa:	2f 53       	incd	r15		
    c2fc:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c300:	2f 53       	incd	r15		
    c302:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c306:	2f 53       	incd	r15		
    c308:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c30c:	2f 53       	incd	r15		
    c30e:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c312:	2f 53       	incd	r15		
    c314:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c318:	2f 53       	incd	r15		
    c31a:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c31e:	2f 53       	incd	r15		
    c320:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c324:	af 4e 02 00 	mov	@r14,	2(r15)	;0x0002(r15)
}
    c328:	30 41       	ret			

0000c32a <MRFI_RandomByte>:
 * @return      a random byte
 **************************************************************************************************
 */
uint8_t MRFI_RandomByte(void)
{
  mrfiRndSeed = (mrfiRndSeed*MRFI_RANDOM_MULTIPLIER) + MRFI_RANDOM_OFFSET;
    c32a:	5d 42 4d 02 	mov.b	&0x024d,r13	
    c32e:	4e 4d       	mov.b	r13,	r14	
    c330:	4e 5e       	rla.b	r14		
    c332:	4e 5d       	add.b	r13,	r14	
    c334:	4e 5e       	rla.b	r14		
    c336:	4e 5e       	rla.b	r14		
    c338:	4f 4e       	mov.b	r14,	r15	
    c33a:	4f 5f       	rla.b	r15		
    c33c:	4f 5f       	rla.b	r15		
    c33e:	4f 5f       	rla.b	r15		
    c340:	4f 5e       	add.b	r14,	r15	
    c342:	4f 5d       	add.b	r13,	r15	
    c344:	7f 50 43 00 	add.b	#67,	r15	;#0x0043
    c348:	c2 4f 4d 02 	mov.b	r15,	&0x024d	

  return mrfiRndSeed;
}
    c34c:	30 41       	ret			

0000c34e <MRFI_DelayMs>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_DelayMs(uint16_t milliseconds)
{
    c34e:	0b 12       	push	r11		
    c350:	0b 4f       	mov	r15,	r11	
  while (milliseconds)
    c352:	0f 93       	tst	r15		
    c354:	06 24       	jz	$+14     	;abs 0xc362
  {
    Mrfi_DelayUsec( APP_USEC_VALUE );
    c356:	3f 40 e8 03 	mov	#1000,	r15	;#0x03e8
    c35a:	b0 12 e2 c1 	call	#0xc1e2	
    milliseconds--;
    c35e:	3b 53       	add	#-1,	r11	;r3 As==11
 * @return      none
 **************************************************************************************************
 */
void MRFI_DelayMs(uint16_t milliseconds)
{
  while (milliseconds)
    c360:	fa 23       	jnz	$-10     	;abs 0xc356
  {
    Mrfi_DelayUsec( APP_USEC_VALUE );
    milliseconds--;
  }
}
    c362:	3b 41       	pop	r11		
    c364:	30 41       	ret			

0000c366 <MRFI_ReplyDelay>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_ReplyDelay()
{
    c366:	0b 12       	push	r11		
    c368:	0a 12       	push	r10		
    c36a:	09 12       	push	r9		
  bspIState_t s;
  uint16_t    milliseconds = sReplyDelayScalar;
    c36c:	19 42 4e 02 	mov	&0x024e,r9	

  BSP_ENTER_CRITICAL_SECTION(s);
    c370:	0f 42       	mov	r2,	r15	
    c372:	32 c2       	dint			
    c374:	03 43       	nop			
  sReplyDelayContext = 1;
    c376:	d2 43 32 02 	mov.b	#1,	&0x0232	;r3 As==01
  BSP_EXIT_CRITICAL_SECTION(s);
    c37a:	3f f2       	and	#8,	r15	;r2 As==11
    c37c:	2d 20       	jnz	$+92     	;abs 0xc3d8

  while (milliseconds)
    c37e:	09 93       	tst	r9		
    c380:	1d 24       	jz	$+60     	;abs 0xc3bc
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_ReplyDelay()
{
    c382:	3b 40 3f 00 	mov	#63,	r11	;#0x003f
    c386:	06 3c       	jmp	$+14     	;abs 0xc394
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
      BSP_EXIT_CRITICAL_SECTION(s);
      if (sKillSem)
    c388:	5f 42 33 02 	mov.b	&0x0233,r15	
    c38c:	4f 93       	tst.b	r15		
    c38e:	10 20       	jnz	$+34     	;abs 0xc3b0
    c390:	3b 53       	add	#-1,	r11	;r3 As==11
      {
        break;
      }
    } while (count--);
    c392:	0e 24       	jz	$+30     	;abs 0xc3b0

  if (howLong)
  {
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
    c394:	0a 42       	mov	r2,	r10	
    c396:	32 c2       	dint			
    c398:	03 43       	nop			
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
    c39a:	3f 40 10 00 	mov	#16,	r15	;#0x0010
    c39e:	b0 12 e4 cb 	call	#0xcbe4	
      BSP_EXIT_CRITICAL_SECTION(s);
    c3a2:	3a b2       	bit	#8,	r10	;r2 As==11
    c3a4:	f1 27       	jz	$-28     	;abs 0xc388
    c3a6:	32 d2       	eint			
      if (sKillSem)
    c3a8:	5f 42 33 02 	mov.b	&0x0233,r15	
    c3ac:	4f 93       	tst.b	r15		
    c3ae:	f0 27       	jz	$-30     	;abs 0xc390
  BSP_EXIT_CRITICAL_SECTION(s);

  while (milliseconds)
  {
    Mrfi_DelayUsecSem( APP_USEC_VALUE );
    if (sKillSem)
    c3b0:	5f 42 33 02 	mov.b	&0x0233,r15	
    c3b4:	4f 93       	tst.b	r15		
    c3b6:	02 20       	jnz	$+6      	;abs 0xc3bc
    {
      break;
    }
    milliseconds--;
    c3b8:	39 53       	add	#-1,	r9	;r3 As==11

  BSP_ENTER_CRITICAL_SECTION(s);
  sReplyDelayContext = 1;
  BSP_EXIT_CRITICAL_SECTION(s);

  while (milliseconds)
    c3ba:	e3 23       	jnz	$-56     	;abs 0xc382
      break;
    }
    milliseconds--;
  }

  BSP_ENTER_CRITICAL_SECTION(s);
    c3bc:	0f 42       	mov	r2,	r15	
    c3be:	32 c2       	dint			
    c3c0:	03 43       	nop			
  sKillSem           = 0;
    c3c2:	c2 43 33 02 	mov.b	#0,	&0x0233	;r3 As==00
  sReplyDelayContext = 0;
    c3c6:	c2 43 32 02 	mov.b	#0,	&0x0232	;r3 As==00
  BSP_EXIT_CRITICAL_SECTION(s);
    c3ca:	3f f2       	and	#8,	r15	;r2 As==11
    c3cc:	01 24       	jz	$+4      	;abs 0xc3d0
    c3ce:	32 d2       	eint			
}
    c3d0:	39 41       	pop	r9		
    c3d2:	3a 41       	pop	r10		
    c3d4:	3b 41       	pop	r11		
    c3d6:	30 41       	ret			
  bspIState_t s;
  uint16_t    milliseconds = sReplyDelayScalar;

  BSP_ENTER_CRITICAL_SECTION(s);
  sReplyDelayContext = 1;
  BSP_EXIT_CRITICAL_SECTION(s);
    c3d8:	32 d2       	eint			
    c3da:	d1 3f       	jmp	$-92     	;abs 0xc37e

0000c3dc <MRFI_PostKillSem>:
 **************************************************************************************************
 */
void MRFI_PostKillSem(void)
{

  if (sReplyDelayContext)
    c3dc:	5f 42 32 02 	mov.b	&0x0232,r15	
    c3e0:	4f 93       	tst.b	r15		
    c3e2:	02 24       	jz	$+6      	;abs 0xc3e8
  {
    sKillSem = 1;
    c3e4:	d2 43 33 02 	mov.b	#1,	&0x0233	;r3 As==01
    c3e8:	30 41       	ret			

0000c3ea <MRFI_GetRadioState>:
 **************************************************************************************************
 */
uint8_t MRFI_GetRadioState(void)
{
  return mrfiRadioState;
}
    c3ea:	5f 42 4c 02 	mov.b	&0x024c,r15	
    c3ee:	30 41       	ret			

0000c3f0 <mrfiSpiInit>:
 **************************************************************************************************
 */
void mrfiSpiInit(void)
{
  /* configure all SPI related pins */
  MRFI_SPI_CONFIG_CSN_PIN_AS_OUTPUT();
    c3f0:	f2 d0 10 00 	bis.b	#16,	&0x0022	;#0x0010
    c3f4:	22 00 
  MRFI_SPI_CONFIG_SCLK_PIN_AS_OUTPUT();
    c3f6:	f2 d0 20 00 	bis.b	#32,	&0x0022	;#0x0020
    c3fa:	22 00 
  MRFI_SPI_CONFIG_SI_PIN_AS_OUTPUT();
    c3fc:	f2 d0 80 ff 	bis.b	#-128,	&0x0022	;#0xff80
    c400:	22 00 
  MRFI_SPI_CONFIG_SO_PIN_AS_INPUT();

  /* set CSn to default high level */
  MRFI_SPI_DRIVE_CSN_HIGH();
    c402:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c406:	21 00 
  
  /* initialize the SPI registers */
  MRFI_SPI_INIT();
    c408:	d2 43 69 00 	mov.b	#1,	&0x0069	;r3 As==01
    c40c:	f2 40 81 ff 	mov.b	#-127,	&0x0069	;#0xff81
    c410:	69 00 
    c412:	f2 40 a9 ff 	mov.b	#-87,	&0x0068	;#0xffa9
    c416:	68 00 
    c418:	e2 43 6a 00 	mov.b	#2,	&0x006a	;r3 As==10
    c41c:	c2 43 6b 00 	mov.b	#0,	&0x006b	;r3 As==00
    c420:	f2 d0 e0 ff 	bis.b	#-32,	&0x0026	;#0xffe0
    c424:	26 00 
    c426:	f2 d0 e0 ff 	bis.b	#-32,	&0x0041	;#0xffe0
    c42a:	41 00 
    c42c:	f2 f0 fe ff 	and.b	#-2,	&0x0069	;#0xfffe
    c430:	69 00 
} 
    c432:	30 41       	ret			

0000c434 <mrfiSpiCmdStrobe>:
uint8_t mrfiSpiCmdStrobe(uint8_t addr)
{
  uint8_t statusByte;
  mrfiSpiIState_t s;

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );       /* SPI is not initialized */
    c434:	5e 42 68 00 	mov.b	&0x0068,r14	
    c438:	3e f2       	and	#8,	r14	;r2 As==11
    c43a:	23 24       	jz	$+72     	;abs 0xc482
  MRFI_SPI_ASSERT((addr >= 0x30) && (addr <= 0x3D));  /* invalid address */
    c43c:	4e 4f       	mov.b	r15,	r14	
    c43e:	7e 50 d0 ff 	add.b	#-48,	r14	;#0xffd0
    c442:	7e 90 0e 00 	cmp.b	#14,	r14	;#0x000e
    c446:	03 28       	jnc	$+8      	;abs 0xc44e
    c448:	32 c2       	dint			
    c44a:	03 43       	nop			
    c44c:	ff 3f       	jmp	$+0      	;abs 0xc44c

  /* disable interrupts that use SPI */
  MRFI_SPI_ENTER_CRITICAL_SECTION(s);
    c44e:	0d 42       	mov	r2,	r13	
    c450:	32 c2       	dint			
    c452:	03 43       	nop			

  /* turn chip select "off" and then "on" to clear any current SPI access */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c454:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c458:	21 00 
  MRFI_SPI_TURN_CHIP_SELECT_ON();
    c45a:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c45e:	21 00 

  /* send the command strobe, wait for SPI access to complete */
  MRFI_SPI_WRITE_BYTE(addr);
    c460:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c464:	03 00 
    c466:	c2 4f 6f 00 	mov.b	r15,	&0x006f	
  MRFI_SPI_WAIT_DONE();
    c46a:	5f 42 03 00 	mov.b	&0x0003,r15	
    c46e:	2f f2       	and	#4,	r15	;r2 As==10
    c470:	fc 27       	jz	$-6      	;abs 0xc46a

  /* read the readio status byte returned by the command strobe */
  statusByte = MRFI_SPI_READ_BYTE();
    c472:	5f 42 6e 00 	mov.b	&0x006e,r15	

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c476:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c47a:	21 00 
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c47c:	3d b2       	bit	#8,	r13	;r2 As==11
    c47e:	04 20       	jnz	$+10     	;abs 0xc488

  /* return the status byte */
  return(statusByte);
}
    c480:	30 41       	ret			
uint8_t mrfiSpiCmdStrobe(uint8_t addr)
{
  uint8_t statusByte;
  mrfiSpiIState_t s;

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );       /* SPI is not initialized */
    c482:	32 c2       	dint			
    c484:	03 43       	nop			
    c486:	ff 3f       	jmp	$+0      	;abs 0xc486
  /* read the readio status byte returned by the command strobe */
  statusByte = MRFI_SPI_READ_BYTE();

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c488:	32 d2       	eint			

  /* return the status byte */
  return(statusByte);
}
    c48a:	30 41       	ret			

0000c48c <Mrfi_RxModeOff>:
 **************************************************************************************************
 */
static void Mrfi_RxModeOff(void)
{
  /*disable receive interrupts */
  MRFI_DISABLE_SYNC_PIN_INT();
    c48c:	f2 f0 fe ff 	and.b	#-2,	&0x002d	;#0xfffe
    c490:	2d 00 

  /* turn off radio */
  MRFI_STROBE_IDLE_AND_WAIT();
    c492:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    c496:	b0 12 34 c4 	call	#0xc434	
    c49a:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    c49e:	b0 12 34 c4 	call	#0xc434	
    c4a2:	3f b0 f0 00 	bit	#240,	r15	;#0x00f0
    c4a6:	f9 23       	jnz	$-12     	;abs 0xc49a

  /* flush the receive FIFO of any residual data */
  mrfiSpiCmdStrobe( SFRX );
    c4a8:	7f 40 3a 00 	mov.b	#58,	r15	;#0x003a
    c4ac:	b0 12 34 c4 	call	#0xc434	

  /* clear receive interrupt */
  MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    c4b0:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    c4b4:	2b 00 
}
    c4b6:	30 41       	ret			

0000c4b8 <MRFI_RxIdle>:
 **************************************************************************************************
 */
void MRFI_RxIdle(void)
{
  /* radio must be awake to move it to idle mode */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c4b8:	5f 42 4c 02 	mov.b	&0x024c,r15	
    c4bc:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    c4be:	09 24       	jz	$+20     	;abs 0xc4d2

  /* if radio is on, turn it off */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
    c4c0:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    c4c4:	01 24       	jz	$+4      	;abs 0xc4c8
    c4c6:	30 41       	ret			
  {
    Mrfi_RxModeOff();
    c4c8:	b0 12 8c c4 	call	#0xc48c	
    mrfiRadioState = MRFI_RADIO_STATE_IDLE;
    c4cc:	e2 43 4c 02 	mov.b	#2,	&0x024c	;r3 As==10
    c4d0:	30 41       	ret			
 **************************************************************************************************
 */
void MRFI_RxIdle(void)
{
  /* radio must be awake to move it to idle mode */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c4d2:	32 c2       	dint			
    c4d4:	03 43       	nop			
    c4d6:	ff 3f       	jmp	$+0      	;abs 0xc4d6

0000c4d8 <Mrfi_RxModeOn>:
 **************************************************************************************************
 */
static void Mrfi_RxModeOn(void)
{
  /* clear any residual receive interrupt */
  MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    c4d8:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    c4dc:	2b 00 

  /* send strobe to enter receive mode */
  mrfiSpiCmdStrobe( SRX );
    c4de:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    c4e2:	b0 12 34 c4 	call	#0xc434	

  /* enable receive interrupts */
  MRFI_ENABLE_SYNC_PIN_INT();
    c4e6:	d2 d3 2d 00 	bis.b	#1,	&0x002d	;r3 As==01
}
    c4ea:	30 41       	ret			

0000c4ec <MRFI_RxOn>:
 **************************************************************************************************
 */
void MRFI_RxOn(void)
{
  /* radio must be awake before we can move it to RX state */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c4ec:	5f 42 4c 02 	mov.b	&0x024c,r15	
    c4f0:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    c4f2:	09 24       	jz	$+20     	;abs 0xc506

  /* if radio is off, turn it on */
  if(mrfiRadioState != MRFI_RADIO_STATE_RX)
    c4f4:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    c4f8:	05 24       	jz	$+12     	;abs 0xc504
  {
    mrfiRadioState = MRFI_RADIO_STATE_RX;
    c4fa:	f2 40 03 00 	mov.b	#3,	&0x024c	;#0x0003
    c4fe:	4c 02 
    Mrfi_RxModeOn();
    c500:	b0 12 d8 c4 	call	#0xc4d8	
    c504:	30 41       	ret			
 **************************************************************************************************
 */
void MRFI_RxOn(void)
{
  /* radio must be awake before we can move it to RX state */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c506:	32 c2       	dint			
    c508:	03 43       	nop			
    c50a:	ff 3f       	jmp	$+0      	;abs 0xc50a

0000c50c <MRFI_Sleep>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_Sleep(void)
{
    c50c:	0b 12       	push	r11		
  bspIState_t s;

  /* Critical section necessary for watertight testing and
   * setting of state variables.
   */
  BSP_ENTER_CRITICAL_SECTION(s);
    c50e:	0b 42       	mov	r2,	r11	
    c510:	32 c2       	dint			
    c512:	03 43       	nop			

  /* If radio is not asleep, put it to sleep */
  if(mrfiRadioState != MRFI_RADIO_STATE_OFF)
    c514:	d2 93 4c 02 	cmp.b	#1,	&0x024c	;r3 As==01
    c518:	08 24       	jz	$+18     	;abs 0xc52a
  {
    /* go to idle so radio is in a known state before sleeping */
    MRFI_RxIdle();
    c51a:	b0 12 b8 c4 	call	#0xc4b8	

    mrfiSpiCmdStrobe( SPWD );
    c51e:	7f 40 39 00 	mov.b	#57,	r15	;#0x0039
    c522:	b0 12 34 c4 	call	#0xc434	

    /* Our new state is OFF */
    mrfiRadioState = MRFI_RADIO_STATE_OFF;
    c526:	d2 43 4c 02 	mov.b	#1,	&0x024c	;r3 As==01
  }

  BSP_EXIT_CRITICAL_SECTION(s);
    c52a:	3b b2       	bit	#8,	r11	;r2 As==11
    c52c:	01 24       	jz	$+4      	;abs 0xc530
    c52e:	32 d2       	eint			
}
    c530:	3b 41       	pop	r11		
    c532:	30 41       	ret			

0000c534 <mrfiSpiReadReg>:
 * @return      register value
 **************************************************************************************************
 */
uint8_t mrfiSpiReadReg(uint8_t addr)
{
  MRFI_SPI_ASSERT(addr <= 0x3B);    /* invalid address */
    c534:	7f 90 3c 00 	cmp.b	#60,	r15	;#0x003c
    c538:	03 28       	jnc	$+8      	;abs 0xc540
    c53a:	32 c2       	dint			
    c53c:	03 43       	nop			
    c53e:	ff 3f       	jmp	$+0      	;abs 0xc53e
  
  /*
   *  The burst bit is set to allow access to read-only status registers.
   *  This does not affect normal register reads.
   */
  return( spiRegAccess(addr | BURST_BIT | READ_BIT, DUMMY_BYTE) );
    c540:	7e 40 db ff 	mov.b	#-37,	r14	;#0xffdb
    c544:	7f d0 c0 ff 	bis.b	#-64,	r15	;#0xffc0
    c548:	b0 12 8a c1 	call	#0xc18a	
}
    c54c:	30 41       	ret			

0000c54e <MRFI_Rssi>:
 *
 * @return      RSSI value in units of dBm.
 **************************************************************************************************
 */
int8_t MRFI_Rssi(void)
{
    c54e:	0b 12       	push	r11		
  uint8_t regValue;

  /* Radio must be in RX state to measure rssi. */
  MRFI_ASSERT( mrfiRadioState == MRFI_RADIO_STATE_RX );
    c550:	f2 90 03 00 	cmp.b	#3,	&0x024c	;#0x0003
    c554:	4c 02 
    c556:	03 24       	jz	$+8      	;abs 0xc55e
    c558:	32 c2       	dint			
    c55a:	03 43       	nop			
    c55c:	ff 3f       	jmp	$+0      	;abs 0xc55c
    c55e:	3b 40 10 00 	mov	#16,	r11	;#0x0010
   * Just having the Radio ON is not enough to read
   * the correct RSSI value. The Radio must in RX mode for
   * a certain duration. This duration depends on
   * the baud rate and the received signal strength itself.
   */
  MRFI_RSSI_VALID_WAIT();
    c562:	7f 40 38 00 	mov.b	#56,	r15	;#0x0038
    c566:	b0 12 34 c5 	call	#0xc534	
    c56a:	3f b0 50 00 	bit	#80,	r15	;#0x0050
    c56e:	06 20       	jnz	$+14     	;abs 0xc57c
    c570:	3f 40 40 00 	mov	#64,	r15	;#0x0040
    c574:	b0 12 e2 c1 	call	#0xc1e2	
    c578:	3b 53       	add	#-1,	r11	;r3 As==11
    c57a:	f3 23       	jnz	$-24     	;abs 0xc562

  /* Read the RSSI value */
  regValue = mrfiSpiReadReg( RSSI );
    c57c:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    c580:	b0 12 34 c5 	call	#0xc534	
  int16_t rssi;

  /* The raw value is in 2's complement and in half db steps. Convert it to
   * decimal taking into account the offset value.
   */
  if(rawValue >= 128)
    c584:	4f 93       	tst.b	r15		
    c586:	08 38       	jl	$+18     	;abs 0xc598
  {
    rssi = (int16_t)(rawValue - 256)/2 - MRFI_RSSI_OFFSET;
  }
  else
  {
    rssi = (rawValue/2) - MRFI_RSSI_OFFSET;
    c588:	12 c3       	clrc			
    c58a:	4f 10       	rrc.b	r15		
    c58c:	4f 4f       	mov.b	r15,	r15	
    c58e:	3f 50 b8 ff 	add	#-72,	r15	;#0xffb8
    c592:	4f 4f       	mov.b	r15,	r15	
  /* Read the RSSI value */
  regValue = mrfiSpiReadReg( RSSI );

  /* convert and do offset compensation */
  return( Mrfi_CalculateRssi(regValue) );
}
    c594:	3b 41       	pop	r11		
    c596:	30 41       	ret			
  /* The raw value is in 2's complement and in half db steps. Convert it to
   * decimal taking into account the offset value.
   */
  if(rawValue >= 128)
  {
    rssi = (int16_t)(rawValue - 256)/2 - MRFI_RSSI_OFFSET;
    c598:	4e 4f       	mov.b	r15,	r14	
    c59a:	0f 4e       	mov	r14,	r15	
    c59c:	3f 50 00 ff 	add	#-256,	r15	;#0xff00
    c5a0:	0f 93       	tst	r15		
    c5a2:	01 34       	jge	$+4      	;abs 0xc5a6
    c5a4:	1f 53       	inc	r15		
    c5a6:	0f 11       	rra	r15		
    c5a8:	3f 50 b8 ff 	add	#-72,	r15	;#0xffb8
  {
    rssi = (rawValue/2) - MRFI_RSSI_OFFSET;
  }

  /* Restrict this value to least value can be held in an 8 bit signed int */
  if(rssi < -128)
    c5ac:	3f 90 80 ff 	cmp	#-128,	r15	;#0xff80
    c5b0:	f0 37       	jge	$-30     	;abs 0xc592
    c5b2:	7f 40 80 ff 	mov.b	#-128,	r15	;#0xff80
  /* Read the RSSI value */
  regValue = mrfiSpiReadReg( RSSI );

  /* convert and do offset compensation */
  return( Mrfi_CalculateRssi(regValue) );
}
    c5b6:	3b 41       	pop	r11		
    c5b8:	30 41       	ret			

0000c5ba <mrfiSpiWriteReg>:
 * @return      none
 **************************************************************************************************
 */
void mrfiSpiWriteReg(uint8_t addr, uint8_t value)
{
  MRFI_SPI_ASSERT((addr <= 0x2E) || (addr == 0x3E));    /* invalid address */
    c5ba:	7f 90 2f 00 	cmp.b	#47,	r15	;#0x002f
    c5be:	06 28       	jnc	$+14     	;abs 0xc5cc
    c5c0:	7f 90 3e 00 	cmp.b	#62,	r15	;#0x003e
    c5c4:	03 24       	jz	$+8      	;abs 0xc5cc
    c5c6:	32 c2       	dint			
    c5c8:	03 43       	nop			
    c5ca:	ff 3f       	jmp	$+0      	;abs 0xc5ca
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
  spiRegAccess(addr, value);
    c5cc:	b0 12 8a c1 	call	#0xc18a	
}
    c5d0:	30 41       	ret			

0000c5d2 <MRFI_WakeUp>:
 **************************************************************************************************
 */
void MRFI_WakeUp(void)
{
  /* if radio is already awake, just ignore wakeup request */
  if(mrfiRadioState != MRFI_RADIO_STATE_OFF)
    c5d2:	d2 93 4c 02 	cmp.b	#1,	&0x024c	;r3 As==01
    c5d6:	01 24       	jz	$+4      	;abs 0xc5da
    c5d8:	30 41       	ret			
  {
    return;
  }

  /* drive CSn low to initiate wakeup */
  MRFI_SPI_DRIVE_CSN_LOW();
    c5da:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c5de:	21 00 

  /* wait for MISO to go high indicating the oscillator is stable */
  while (MRFI_SPI_SO_IS_HIGH());
    c5e0:	5f 42 20 00 	mov.b	&0x0020,r15	
    c5e4:	3f f0 40 00 	and	#64,	r15	;#0x0040
    c5e8:	fb 23       	jnz	$-8      	;abs 0xc5e0

  /* wakeup is complete, drive CSn high and continue */
  MRFI_SPI_DRIVE_CSN_HIGH();
    c5ea:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c5ee:	21 00 
/*
 *  The test registers must be restored after sleep for the CC1100 and CC2500 radios.
 *  This is not required for the CC1101 radio.
 */
#ifndef MRFI_CC1101
  mrfiSpiWriteReg( TEST2, SMARTRF_SETTING_TEST2 );
    c5f0:	7e 40 88 ff 	mov.b	#-120,	r14	;#0xff88
    c5f4:	7f 40 2c 00 	mov.b	#44,	r15	;#0x002c
    c5f8:	b0 12 ba c5 	call	#0xc5ba	
  mrfiSpiWriteReg( TEST1, SMARTRF_SETTING_TEST1 );
    c5fc:	7e 40 31 00 	mov.b	#49,	r14	;#0x0031
    c600:	7f 40 2d 00 	mov.b	#45,	r15	;#0x002d
    c604:	b0 12 ba c5 	call	#0xc5ba	
  mrfiSpiWriteReg( TEST0, SMARTRF_SETTING_TEST0 );
    c608:	7e 40 0b 00 	mov.b	#11,	r14	;#0x000b
    c60c:	7f 40 2e 00 	mov.b	#46,	r15	;#0x002e
    c610:	b0 12 ba c5 	call	#0xc5ba	
#endif

  /* enter idle mode */
  mrfiRadioState = MRFI_RADIO_STATE_IDLE;
    c614:	e2 43 4c 02 	mov.b	#2,	&0x024c	;r3 As==10
  MRFI_STROBE_IDLE_AND_WAIT();
    c618:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    c61c:	b0 12 34 c4 	call	#0xc434	
    c620:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    c624:	b0 12 34 c4 	call	#0xc434	
    c628:	3f b0 f0 00 	bit	#240,	r15	;#0x00f0
    c62c:	f9 23       	jnz	$-12     	;abs 0xc620
    c62e:	30 41       	ret			

0000c630 <mrfiSpiWriteTxFifo>:
 * @return      none
 **************************************************************************************************
 */
void mrfiSpiWriteTxFifo(uint8_t * pData, uint8_t len)
{
  spiBurstFifoAccess(TXFIFO | BURST_BIT, pData, len);
    c630:	4d 4e       	mov.b	r14,	r13	
    c632:	0e 4f       	mov	r15,	r14	
    c634:	7f 40 7f 00 	mov.b	#127,	r15	;#0x007f
    c638:	b0 12 2a c2 	call	#0xc22a	
}
    c63c:	30 41       	ret			

0000c63e <MRFI_Transmit>:
 *                  MRFI_TX_RESULT_SUCCESS - transmit succeeded
 *                  MRFI_TX_RESULT_FAILED  - transmit failed because CCA failed
 **************************************************************************************************
 */
uint8_t MRFI_Transmit(mrfiPacket_t * pPacket, uint8_t txType)
{
    c63e:	0b 12       	push	r11		
    c640:	0a 12       	push	r10		
    c642:	09 12       	push	r9		
    c644:	21 83       	decd	r1		
    c646:	4b 4e       	mov.b	r14,	r11	
  uint8_t ccaRetries;
  uint8_t txBufLen;
  uint8_t returnValue = MRFI_TX_RESULT_SUCCESS;

  /* radio must be awake to transmit */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c648:	d2 93 4c 02 	cmp.b	#1,	&0x024c	;r3 As==01
    c64c:	2f 24       	jz	$+96     	;abs 0xc6ac

  /* Turn off reciever. We can ignore/drop incoming packets during transmit. */
  Mrfi_RxModeOff();
    c64e:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    c652:	b0 12 8c c4 	call	#0xc48c	

  /* ------------------------------------------------------------------
   *    Write packet to transmit FIFO
   *   --------------------------------
   */
  mrfiSpiWriteTxFifo(&(pPacket->frame[0]), txBufLen);
    c656:	2f 41       	mov	@r1,	r15	
    c658:	6e 4f       	mov.b	@r15,	r14	
    c65a:	5e 53       	inc.b	r14		
    c65c:	b0 12 30 c6 	call	#0xc630	

  /* ------------------------------------------------------------------
   *    Immediate transmit
   *   ---------------------
   */
  if (txType == MRFI_TX_TYPE_FORCED)
    c660:	4b 93       	tst.b	r11		
    c662:	05 24       	jz	$+12     	;abs 0xc66e
    /* ------------------------------------------------------------------
     *    CCA transmit
     *   ---------------
     */

    MRFI_ASSERT( txType == MRFI_TX_TYPE_CCA );
    c664:	5b 93       	cmp.b	#1,	r11	;r3 As==01
    c666:	25 24       	jz	$+76     	;abs 0xc6b2
    c668:	32 c2       	dint			
    c66a:	03 43       	nop			
    c66c:	ff 3f       	jmp	$+0      	;abs 0xc66c
   *   ---------------------
   */
  if (txType == MRFI_TX_TYPE_FORCED)
  {
    /* Issue the TX strobe. */
    mrfiSpiCmdStrobe( STX );
    c66e:	7f 40 35 00 	mov.b	#53,	r15	;#0x0035
    c672:	b0 12 34 c4 	call	#0xc434	

    /* Wait for transmit to complete */
    while(!MRFI_SYNC_PIN_INT_FLAG_IS_SET());
    c676:	5f 42 2b 00 	mov.b	&0x002b,r15	
    c67a:	1f f3       	and	#1,	r15	;r3 As==01
    c67c:	fc 27       	jz	$-6      	;abs 0xc676

    /* Clear the interrupt flag */
    MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    c67e:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    c682:	2b 00 
 */
uint8_t MRFI_Transmit(mrfiPacket_t * pPacket, uint8_t txType)
{
  uint8_t ccaRetries;
  uint8_t txBufLen;
  uint8_t returnValue = MRFI_TX_RESULT_SUCCESS;
    c684:	4b 43       	clr.b	r11		

  /*
   * Flush the transmit FIFO.  It must be flushed so that
   * the next transmit can start with a clean slate.
   */
  mrfiSpiCmdStrobe( SFTX );
    c686:	7f 40 3b 00 	mov.b	#59,	r15	;#0x003b
    c68a:	b0 12 34 c4 	call	#0xc434	

  /* Restore GDO_0 to be SYNC signal */
  MRFI_CONFIG_GDO0_AS_SYNC_SIGNAL();
    c68e:	7e 40 06 00 	mov.b	#6,	r14	;#0x0006
    c692:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c694:	b0 12 ba c5 	call	#0xc5ba	

  /* If the radio was in RX state when transmit was attempted,
   * put it back to Rx On state.
   */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
    c698:	f2 90 03 00 	cmp.b	#3,	&0x024c	;#0x0003
    c69c:	4c 02 
    c69e:	6b 24       	jz	$+216    	;abs 0xc776
  {
    Mrfi_RxModeOn();
  }

  return( returnValue );
}
    c6a0:	4f 4b       	mov.b	r11,	r15	
    c6a2:	21 53       	incd	r1		
    c6a4:	39 41       	pop	r9		
    c6a6:	3a 41       	pop	r10		
    c6a8:	3b 41       	pop	r11		
    c6aa:	30 41       	ret			
  uint8_t ccaRetries;
  uint8_t txBufLen;
  uint8_t returnValue = MRFI_TX_RESULT_SUCCESS;

  /* radio must be awake to transmit */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c6ac:	32 c2       	dint			
    c6ae:	03 43       	nop			
    c6b0:	ff 3f       	jmp	$+0      	;abs 0xc6b0
     * can re-configure the GDO_0 output from the radio to be PA_PD signal
     * instead of the SYNC signal.
     * Since both SYNC and PA_PD are used as falling edge interrupts, we
     * don't need to reconfigure the MCU input.
     */
    MRFI_CONFIG_GDO0_AS_PAPD_SIGNAL();
    c6b2:	7e 40 1b 00 	mov.b	#27,	r14	;#0x001b
    c6b6:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c6b8:	b0 12 ba c5 	call	#0xc5ba	
    c6bc:	7b 40 05 00 	mov.b	#5,	r11	;#0x0005
       */

      /* Can not use the Mrfi_RxModeOn() function here since it turns on the
       * Rx interrupt, which we don't want in this case.
       */
      mrfiSpiCmdStrobe( SRX );
    c6c0:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    c6c4:	b0 12 34 c4 	call	#0xc434	
    c6c8:	3a 40 10 00 	mov	#16,	r10	;#0x0010
    c6cc:	06 3c       	jmp	$+14     	;abs 0xc6da

      /* wait for the rssi to be valid. */
      MRFI_RSSI_VALID_WAIT();
    c6ce:	3f 40 40 00 	mov	#64,	r15	;#0x0040
    c6d2:	b0 12 e2 c1 	call	#0xc1e2	
    c6d6:	3a 53       	add	#-1,	r10	;r3 As==11
    c6d8:	07 24       	jz	$+16     	;abs 0xc6e8
    c6da:	7f 40 38 00 	mov.b	#56,	r15	;#0x0038
    c6de:	b0 12 34 c5 	call	#0xc534	
    c6e2:	3f b0 50 00 	bit	#80,	r15	;#0x0050
    c6e6:	f3 27       	jz	$-24     	;abs 0xc6ce
       *  is used to capture the transition that indicates a transmit was started.
       *  The pin level cannot be used to indicate transmit success as timing may
       *  prevent the transition from being detected.  The interrupt latch captures
       *  the event regardless of timing.
       */
      MRFI_CLEAR_PAPD_PIN_INT_FLAG();
    c6e8:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    c6ec:	2b 00 

      /* send strobe to initiate transmit */
      mrfiSpiCmdStrobe( STX );
    c6ee:	7f 40 35 00 	mov.b	#53,	r15	;#0x0035
    c6f2:	b0 12 34 c4 	call	#0xc434	
       * successful transmit. This is the 250 XOSC periods
       * (9.6 us for a 26 MHz crystal) See section 19.6 of 2500 datasheet.
       * Found out that we need a delay of atleast 20 us on CC2500 and
       * 25 us on CC1100 to see the PA_PD signal change.
       */
      Mrfi_DelayUsec(25);
    c6f6:	3f 40 19 00 	mov	#25,	r15	;#0x0019
    c6fa:	b0 12 e2 c1 	call	#0xc1e2	

      /* PA_PD signal goes from HIGH to LOW when going from RX state.
       * This transition is trapped as a falling edge interrupt flag
       * to indicate that CCA passed and the transmit has started.
       */
      if (MRFI_PAPD_INT_FLAG_IS_SET())
    c6fe:	5f 42 2b 00 	mov.b	&0x002b,r15	
    c702:	1f f3       	and	#1,	r15	;r3 As==01
    c704:	2f 20       	jnz	$+96     	;abs 0xc764
        /* Turn off radio and save some power during backoff */

        /* NOTE: Can't use Mrfi_RxModeOff() - since it tries to update the
         * sync signal status which we are not using during the TX operation.
         */
        MRFI_STROBE_IDLE_AND_WAIT();
    c706:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    c70a:	b0 12 34 c4 	call	#0xc434	
    c70e:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    c712:	b0 12 34 c4 	call	#0xc434	
    c716:	3f b0 f0 00 	bit	#240,	r15	;#0x00f0
    c71a:	f9 23       	jnz	$-12     	;abs 0xc70e

        /* flush the receive FIFO of any residual data */
        mrfiSpiCmdStrobe( SFRX );
    c71c:	7f 40 3a 00 	mov.b	#58,	r15	;#0x003a
    c720:	b0 12 34 c4 	call	#0xc434	
    c724:	7b 53       	add.b	#-1,	r11	;r3 As==11

        /* Retry ? */
        if (ccaRetries != 0)
    c726:	2f 24       	jz	$+96     	;abs 0xc786
 * @return      a random byte
 **************************************************************************************************
 */
uint8_t MRFI_RandomByte(void)
{
  mrfiRndSeed = (mrfiRndSeed*MRFI_RANDOM_MULTIPLIER) + MRFI_RANDOM_OFFSET;
    c728:	5d 42 4d 02 	mov.b	&0x024d,r13	
    c72c:	4e 4d       	mov.b	r13,	r14	
    c72e:	4e 5e       	rla.b	r14		
    c730:	4e 5d       	add.b	r13,	r14	
    c732:	4e 5e       	rla.b	r14		
    c734:	4e 5e       	rla.b	r14		
    c736:	4f 4e       	mov.b	r14,	r15	
    c738:	4f 5f       	rla.b	r15		
    c73a:	4f 5f       	rla.b	r15		
    c73c:	4f 5f       	rla.b	r15		
    c73e:	4f 5e       	add.b	r14,	r15	
    c740:	4f 5d       	add.b	r13,	r15	
    c742:	7f 50 43 00 	add.b	#67,	r15	;#0x0043
    c746:	c2 4f 4d 02 	mov.b	r15,	&0x024d	
{
  uint8_t backoffs;
  uint8_t i;

  /* calculate random value for backoffs - 1 to 16 */
  backoffs = (MRFI_RandomByte() & 0x0F) + 1;
    c74a:	49 4f       	mov.b	r15,	r9	
    c74c:	79 f0 0f 00 	and.b	#15,	r9	;#0x000f
    c750:	59 53       	inc.b	r9		

  /* delay for randomly computed number of backoff periods */
  for (i=0; i<backoffs; i++)
    c752:	4a 43       	clr.b	r10		
  {
    Mrfi_DelayUsec( sBackoffHelper );
    c754:	1f 42 50 02 	mov	&0x0250,r15	
    c758:	b0 12 e2 c1 	call	#0xc1e2	

  /* calculate random value for backoffs - 1 to 16 */
  backoffs = (MRFI_RandomByte() & 0x0F) + 1;

  /* delay for randomly computed number of backoff periods */
  for (i=0; i<backoffs; i++)
    c75c:	5a 53       	inc.b	r10		
    c75e:	4a 99       	cmp.b	r9,	r10	
    c760:	f9 2b       	jnc	$-12     	;abs 0xc754
    c762:	ae 3f       	jmp	$-162    	;abs 0xc6c0
        *    Clear Channel Assessment passed.
        *   ----------------------------------
        */

        /* Clear the PA_PD int flag */
        MRFI_CLEAR_PAPD_PIN_INT_FLAG();
    c764:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    c768:	2b 00 

        /* PA_PD signal stays LOW while in TX state and goes back to HIGH when
         * the radio transitions to RX state.
         */
        /* wait for transmit to complete */
        while (!MRFI_PAPD_PIN_IS_HIGH());
    c76a:	5f 42 28 00 	mov.b	&0x0028,r15	
    c76e:	1f f3       	and	#1,	r15	;r3 As==01
    c770:	fc 27       	jz	$-6      	;abs 0xc76a
 */
uint8_t MRFI_Transmit(mrfiPacket_t * pPacket, uint8_t txType)
{
  uint8_t ccaRetries;
  uint8_t txBufLen;
  uint8_t returnValue = MRFI_TX_RESULT_SUCCESS;
    c772:	4b 43       	clr.b	r11		
    c774:	88 3f       	jmp	$-238    	;abs 0xc686
  /* If the radio was in RX state when transmit was attempted,
   * put it back to Rx On state.
   */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
  {
    Mrfi_RxModeOn();
    c776:	b0 12 d8 c4 	call	#0xc4d8	
  }

  return( returnValue );
}
    c77a:	4f 4b       	mov.b	r11,	r15	
    c77c:	21 53       	incd	r1		
    c77e:	39 41       	pop	r9		
    c780:	3a 41       	pop	r10		
    c782:	3b 41       	pop	r11		
    c784:	30 41       	ret			
          ccaRetries--;
        }
        else /* No CCA retries are left, abort */
        {
          /* set return value for failed transmit and break */
          returnValue = MRFI_TX_RESULT_FAILED;
    c786:	5b 43       	mov.b	#1,	r11	;r3 As==01
    c788:	7e 3f       	jmp	$-258    	;abs 0xc686

0000c78a <mrfiSpiReadRxFifo>:
 * @return      none
 **************************************************************************************************
 */
void mrfiSpiReadRxFifo(uint8_t * pData, uint8_t len)
{
  spiBurstFifoAccess(RXFIFO | BURST_BIT | READ_BIT, pData, len);
    c78a:	4d 4e       	mov.b	r14,	r13	
    c78c:	0e 4f       	mov	r15,	r14	
    c78e:	7f 43       	mov.b	#-1,	r15	;r3 As==11
    c790:	b0 12 2a c2 	call	#0xc22a	
}
    c794:	30 41       	ret			

0000c796 <MRFI_SetLogicalChannel>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_SetLogicalChannel(uint8_t chan)
{
    c796:	21 83       	decd	r1		
  /* logical channel is not valid? */
  MRFI_ASSERT( chan < MRFI_NUM_LOGICAL_CHANS );
    c798:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    c79a:	03 28       	jnc	$+8      	;abs 0xc7a2
    c79c:	32 c2       	dint			
    c79e:	03 43       	nop			
    c7a0:	ff 3f       	jmp	$+0      	;abs 0xc7a0

  /* make sure radio is off before changing channels */
  Mrfi_RxModeOff();
    c7a2:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    c7a6:	b0 12 8c c4 	call	#0xc48c	

  MRFI_WRITE_REGISTER( CHANNR, mrfiLogicalChanTable[chan] );
    c7aa:	2f 41       	mov	@r1,	r15	
    c7ac:	4f 4f       	mov.b	r15,	r15	
    c7ae:	5e 4f 9a e3 	mov.b	-7270(r15),r14	;0xe39a(r15)
    c7b2:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    c7b6:	b0 12 ba c5 	call	#0xc5ba	

  /* turn radio back on if it was on before channel change */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
    c7ba:	f2 90 03 00 	cmp.b	#3,	&0x024c	;#0x0003
    c7be:	4c 02 
    c7c0:	02 24       	jz	$+6      	;abs 0xc7c6
  {
    Mrfi_RxModeOn();
  }
}
    c7c2:	21 53       	incd	r1		
    c7c4:	30 41       	ret			
  MRFI_WRITE_REGISTER( CHANNR, mrfiLogicalChanTable[chan] );

  /* turn radio back on if it was on before channel change */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
  {
    Mrfi_RxModeOn();
    c7c6:	b0 12 d8 c4 	call	#0xc4d8	
  }
}
    c7ca:	21 53       	incd	r1		
    c7cc:	30 41       	ret			

0000c7ce <MRFI_SetRFPwr>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_SetRFPwr(uint8_t idx)
{
    c7ce:	21 83       	decd	r1		
  /* is power level specified valid? */
  MRFI_ASSERT( idx < MRFI_NUM_POWER_SETTINGS );
    c7d0:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    c7d4:	03 28       	jnc	$+8      	;abs 0xc7dc
    c7d6:	32 c2       	dint			
    c7d8:	03 43       	nop			
    c7da:	ff 3f       	jmp	$+0      	;abs 0xc7da

  /* make sure radio is off before changing power levels */
  Mrfi_RxModeOff();
    c7dc:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    c7e0:	b0 12 8c c4 	call	#0xc48c	

  MRFI_WRITE_REGISTER( PA_TABLE0, mrfiRFPowerTable[idx] );
    c7e4:	2f 41       	mov	@r1,	r15	
    c7e6:	4f 4f       	mov.b	r15,	r15	
    c7e8:	5e 4f 9e e3 	mov.b	-7266(r15),r14	;0xe39e(r15)
    c7ec:	7f 40 3e 00 	mov.b	#62,	r15	;#0x003e
    c7f0:	b0 12 ba c5 	call	#0xc5ba	

  /* turn radio back on if it was on before power level change */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
    c7f4:	f2 90 03 00 	cmp.b	#3,	&0x024c	;#0x0003
    c7f8:	4c 02 
    c7fa:	02 24       	jz	$+6      	;abs 0xc800
  {
    Mrfi_RxModeOn();
  }
}
    c7fc:	21 53       	incd	r1		
    c7fe:	30 41       	ret			
  MRFI_WRITE_REGISTER( PA_TABLE0, mrfiRFPowerTable[idx] );

  /* turn radio back on if it was on before power level change */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
  {
    Mrfi_RxModeOn();
    c800:	b0 12 d8 c4 	call	#0xc4d8	
  }
}
    c804:	21 53       	incd	r1		
    c806:	30 41       	ret			

0000c808 <MRFI_Init>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_Init(void)
{
    c808:	0b 12       	push	r11		
    c80a:	0a 12       	push	r10		
  /* ------------------------------------------------------------------
   *    Initialization
   *   -----------------
   */

  memset(&mrfiIncomingPacket, 0x0, sizeof(mrfiIncomingPacket));
    c80c:	82 43 34 02 	mov	#0,	&0x0234	;r3 As==00
    c810:	82 43 36 02 	mov	#0,	&0x0236	;r3 As==00
    c814:	82 43 38 02 	mov	#0,	&0x0238	;r3 As==00
    c818:	82 43 3a 02 	mov	#0,	&0x023a	;r3 As==00
    c81c:	82 43 3c 02 	mov	#0,	&0x023c	;r3 As==00
    c820:	82 43 3e 02 	mov	#0,	&0x023e	;r3 As==00
    c824:	82 43 40 02 	mov	#0,	&0x0240	;r3 As==00
    c828:	82 43 42 02 	mov	#0,	&0x0242	;r3 As==00
    c82c:	82 43 44 02 	mov	#0,	&0x0244	;r3 As==00
    c830:	82 43 46 02 	mov	#0,	&0x0246	;r3 As==00
    c834:	82 43 48 02 	mov	#0,	&0x0248	;r3 As==00
    c838:	82 43 4a 02 	mov	#0,	&0x024a	;r3 As==00

  /* initialize GPIO pins */
  MRFI_CONFIG_GDO0_PIN_AS_INPUT();
    c83c:	f2 f0 fe ff 	and.b	#-2,	&0x002e	;#0xfffe
    c840:	2e 00 

  /* initialize SPI */
  mrfiSpiInit();
    c842:	b0 12 f0 c3 	call	#0xc3f0	

  /* ------------------------------------------------------------------
   *    Radio power-up reset
   *   ----------------------
   */
  MRFI_ASSERT(MRFI_SPI_CSN_IS_HIGH());
    c846:	5f 42 21 00 	mov.b	&0x0021,r15	
    c84a:	3f f0 10 00 	and	#16,	r15	;#0x0010
    c84e:	03 20       	jnz	$+8      	;abs 0xc856
    c850:	32 c2       	dint			
    c852:	03 43       	nop			
    c854:	ff 3f       	jmp	$+0      	;abs 0xc854

  /* pulse CSn low then high */
  MRFI_SPI_DRIVE_CSN_LOW();
    c856:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c85a:	21 00 
  Mrfi_DelayUsec(10);
    c85c:	3f 40 0a 00 	mov	#10,	r15	;#0x000a
    c860:	b0 12 e2 c1 	call	#0xc1e2	
  MRFI_SPI_DRIVE_CSN_HIGH();
    c864:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c868:	21 00 

  /* hold CSn high for at least 40 microseconds */
  Mrfi_DelayUsec(40);
    c86a:	3f 40 28 00 	mov	#40,	r15	;#0x0028
    c86e:	b0 12 e2 c1 	call	#0xc1e2	

  /* pull CSn low and wait for SO to go low */
  MRFI_SPI_DRIVE_CSN_LOW();
    c872:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c876:	21 00 
  while (MRFI_SPI_SO_IS_HIGH());
    c878:	5f 42 20 00 	mov.b	&0x0020,r15	
    c87c:	3f f0 40 00 	and	#64,	r15	;#0x0040
    c880:	fb 23       	jnz	$-8      	;abs 0xc878

  /* directly send strobe command - cannot use function as it affects CSn pin */
  MRFI_SPI_WRITE_BYTE(SRES);
    c882:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c886:	03 00 
    c888:	f2 40 30 00 	mov.b	#48,	&0x006f	;#0x0030
    c88c:	6f 00 
  MRFI_SPI_WAIT_DONE();
    c88e:	5f 42 03 00 	mov.b	&0x0003,r15	
    c892:	2f f2       	and	#4,	r15	;r2 As==10
    c894:	fc 27       	jz	$-6      	;abs 0xc88e

  /* wait for SO to go low again, reset is complete at that point */
  while (MRFI_SPI_SO_IS_HIGH());
    c896:	5f 42 20 00 	mov.b	&0x0020,r15	
    c89a:	3f f0 40 00 	and	#64,	r15	;#0x0040
    c89e:	fb 23       	jnz	$-8      	;abs 0xc896

  /* return CSn pin to its default high level */
  MRFI_SPI_DRIVE_CSN_HIGH();
    c8a0:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c8a4:	21 00 
   */

  /* verify that SPI is working, PKTLEN is an arbitrary read/write register used for testing */
#ifdef MRFI_ASSERTS_ARE_ON
#define TEST_VALUE 0xA5
  mrfiSpiWriteReg( PKTLEN, TEST_VALUE );
    c8a6:	7e 40 a5 ff 	mov.b	#-91,	r14	;#0xffa5
    c8aa:	7f 40 06 00 	mov.b	#6,	r15	;#0x0006
    c8ae:	b0 12 ba c5 	call	#0xc5ba	
  MRFI_ASSERT( mrfiSpiReadReg( PKTLEN ) == TEST_VALUE ); /* SPI is not responding */
    c8b2:	7f 40 06 00 	mov.b	#6,	r15	;#0x0006
    c8b6:	b0 12 34 c5 	call	#0xc534	
    c8ba:	7f 90 a5 ff 	cmp.b	#-91,	r15	;#0xffa5
    c8be:	03 24       	jz	$+8      	;abs 0xc8c6
    c8c0:	32 c2       	dint			
    c8c2:	03 43       	nop			
    c8c4:	ff 3f       	jmp	$+0      	;abs 0xc8c4
#endif

  /* verify the correct radio is installed */
  MRFI_ASSERT( mrfiSpiReadReg( PARTNUM ) == MRFI_RADIO_PARTNUM );      /* incorrect radio specified */
    c8c6:	7f 40 30 00 	mov.b	#48,	r15	;#0x0030
    c8ca:	b0 12 34 c5 	call	#0xc534	
    c8ce:	7f 90 80 ff 	cmp.b	#-128,	r15	;#0xff80
    c8d2:	03 24       	jz	$+8      	;abs 0xc8da
    c8d4:	32 c2       	dint			
    c8d6:	03 43       	nop			
    c8d8:	ff 3f       	jmp	$+0      	;abs 0xc8d8
  MRFI_ASSERT( mrfiSpiReadReg( VERSION ) >= MRFI_RADIO_MIN_VERSION );  /* obsolete radio specified  */
    c8da:	7f 40 31 00 	mov.b	#49,	r15	;#0x0031
    c8de:	b0 12 34 c5 	call	#0xc534	
    c8e2:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    c8e4:	6b 24       	jz	$+216    	;abs 0xc9bc
    c8e6:	6a 28       	jnc	$+214    	;abs 0xc9bc
    c8e8:	3b 40 5f e3 	mov	#-7329,	r11	;#0xe35f
  {
    uint8_t i;

    for (i=0; i<(sizeof(mrfiRadioCfg)/sizeof(mrfiRadioCfg[0])); i++)
    {
      mrfiSpiWriteReg(mrfiRadioCfg[i][0], mrfiRadioCfg[i][1]);
    c8ec:	6e 4b       	mov.b	@r11,	r14	
    c8ee:	5f 4b ff ff 	mov.b	-1(r11),r15	;0xffff(r11)
    c8f2:	b0 12 ba c5 	call	#0xc5ba	
    c8f6:	2b 53       	incd	r11		

  /* initialize radio registers */
  {
    uint8_t i;

    for (i=0; i<(sizeof(mrfiRadioCfg)/sizeof(mrfiRadioCfg[0])); i++)
    c8f8:	3b 90 9b e3 	cmp	#-7269,	r11	;#0xe39b
    c8fc:	f7 23       	jnz	$-16     	;abs 0xc8ec
      mrfiSpiWriteReg(mrfiRadioCfg[i][0], mrfiRadioCfg[i][1]);
    }
  }

  /* Initial radio state is IDLE state */
  mrfiRadioState = MRFI_RADIO_STATE_IDLE;
    c8fe:	e2 43 4c 02 	mov.b	#2,	&0x024c	;r3 As==10

  /* set default channel */
  MRFI_SetLogicalChannel( 0 );
    c902:	4f 43       	clr.b	r15		
    c904:	b0 12 96 c7 	call	#0xc796	

  /* set default power */
  MRFI_SetRFPwr(MRFI_NUM_POWER_SETTINGS - 1);
    c908:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c90a:	b0 12 ce c7 	call	#0xc7ce	
  /* Generate Random seed:
   * We will use the RSSI value to generate our random seed.
   */

  /* Put the radio in RX state */
  mrfiSpiCmdStrobe( SRX );
    c90e:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    c912:	b0 12 34 c4 	call	#0xc434	
    c916:	3b 40 10 00 	mov	#16,	r11	;#0x0010
    c91a:	06 3c       	jmp	$+14     	;abs 0xc928

  /* delay for the rssi to be valid */
  MRFI_RSSI_VALID_WAIT();
    c91c:	3f 40 40 00 	mov	#64,	r15	;#0x0040
    c920:	b0 12 e2 c1 	call	#0xc1e2	
    c924:	3b 53       	add	#-1,	r11	;r3 As==11
    c926:	07 24       	jz	$+16     	;abs 0xc936
    c928:	7f 40 38 00 	mov.b	#56,	r15	;#0x0038
    c92c:	b0 12 34 c5 	call	#0xc534	
    c930:	3f b0 50 00 	bit	#80,	r15	;#0x0050
    c934:	f3 27       	jz	$-24     	;abs 0xc91c
    c936:	5b 42 4d 02 	mov.b	&0x024d,r11	
  /* Generate Random seed:
   * We will use the RSSI value to generate our random seed.
   */

  /* Put the radio in RX state */
  mrfiSpiCmdStrobe( SRX );
    c93a:	7a 40 10 00 	mov.b	#16,	r10	;#0x0010
  /* use most random bit of rssi to populate the random seed */
  {
    uint8_t i;
    for(i=0; i<16; i++)
    {
      mrfiRndSeed = (mrfiRndSeed << 1) | (mrfiSpiReadReg(RSSI) & 0x01);
    c93e:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    c942:	b0 12 34 c5 	call	#0xc534	
    c946:	4e 4b       	mov.b	r11,	r14	
    c948:	0e 5e       	rla	r14		
    c94a:	4b 4f       	mov.b	r15,	r11	
    c94c:	5b f3       	and.b	#1,	r11	;r3 As==01
    c94e:	4b de       	bis.b	r14,	r11	
    c950:	c2 4b 4d 02 	mov.b	r11,	&0x024d	
    c954:	7a 53       	add.b	#-1,	r10	;r3 As==11
  MRFI_RSSI_VALID_WAIT();

  /* use most random bit of rssi to populate the random seed */
  {
    uint8_t i;
    for(i=0; i<16; i++)
    c956:	f3 23       	jnz	$-24     	;abs 0xc93e
      mrfiRndSeed = (mrfiRndSeed << 1) | (mrfiSpiReadReg(RSSI) & 0x01);
    }
  }

  /* Force the seed to be non-zero by setting one bit, just in case... */
  mrfiRndSeed |= 0x0080;
    c958:	7b d0 80 ff 	bis.b	#-128,	r11	;#0xff80
    c95c:	c2 4b 4d 02 	mov.b	r11,	&0x024d	

  /* Turn off RF. */
  Mrfi_RxModeOff();
    c960:	b0 12 8c c4 	call	#0xc48c	
    dataRate = mantissa * (MRFI_RADIO_OSC_FREQ>>exponent);

    bits = ((uint32_t)((PHY_PREAMBLE_SYNC_BYTES + MRFI_MAX_FRAME_SIZE)*8))*10000;

    /* processing on the peer + the Tx/Rx time plus more */
    sReplyDelayScalar = PLATFORM_FACTOR_CONSTANT + (((bits/dataRate)+5)/10);
    c964:	b2 40 33 00 	mov	#51,	&0x024e	;#0x0033
    c968:	4e 02 
     * we just calculated divided by 32. With the backoff algorithm backing
     * off up to 16 periods this will result in waiting up to about 1/2 the total
     * scalar value. For high data rates this does not contribute at all. Value
     * is in microseconds.
     */
    sBackoffHelper = MRFI_BACKOFF_PERIOD_USECS + (sReplyDelayScalar>>5)*1000;
    c96a:	b2 40 e2 04 	mov	#1250,	&0x0250	;#0x04e2
    c96e:	50 02 
  }

  /* Clean out buffer to protect against spurious frames */
  memset(mrfiIncomingPacket.frame, 0x00, sizeof(mrfiIncomingPacket.frame));
    c970:	82 43 34 02 	mov	#0,	&0x0234	;r3 As==00
    c974:	82 43 36 02 	mov	#0,	&0x0236	;r3 As==00
    c978:	82 43 38 02 	mov	#0,	&0x0238	;r3 As==00
    c97c:	82 43 3a 02 	mov	#0,	&0x023a	;r3 As==00
    c980:	82 43 3c 02 	mov	#0,	&0x023c	;r3 As==00
    c984:	82 43 3e 02 	mov	#0,	&0x023e	;r3 As==00
    c988:	82 43 40 02 	mov	#0,	&0x0240	;r3 As==00
    c98c:	82 43 42 02 	mov	#0,	&0x0242	;r3 As==00
    c990:	82 43 44 02 	mov	#0,	&0x0244	;r3 As==00
    c994:	82 43 46 02 	mov	#0,	&0x0246	;r3 As==00
    c998:	82 43 48 02 	mov	#0,	&0x0248	;r3 As==00
  memset(mrfiIncomingPacket.rxMetrics, 0x00, sizeof(mrfiIncomingPacket.rxMetrics));
    c99c:	82 43 4a 02 	mov	#0,	&0x024a	;r3 As==00
   *  This interrupt is used to indicate receive.  The SYNC signal goes
   *  high when a receive OR a transmit begins.  It goes high once the
   *  sync word is received or transmitted and then goes low again once
   *  the packet completes.
   */
  MRFI_CONFIG_GDO0_AS_SYNC_SIGNAL();
    c9a0:	7e 40 06 00 	mov.b	#6,	r14	;#0x0006
    c9a4:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c9a6:	b0 12 ba c5 	call	#0xc5ba	
  MRFI_CONFIG_SYNC_PIN_FALLING_EDGE_INT();
    c9aa:	d2 d3 2c 00 	bis.b	#1,	&0x002c	;r3 As==01
  MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    c9ae:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    c9b2:	2b 00 

  /* enable global interrupts */
  BSP_ENABLE_INTERRUPTS();
    c9b4:	32 d2       	eint			
}
    c9b6:	3a 41       	pop	r10		
    c9b8:	3b 41       	pop	r11		
    c9ba:	30 41       	ret			
  MRFI_ASSERT( mrfiSpiReadReg( PKTLEN ) == TEST_VALUE ); /* SPI is not responding */
#endif

  /* verify the correct radio is installed */
  MRFI_ASSERT( mrfiSpiReadReg( PARTNUM ) == MRFI_RADIO_PARTNUM );      /* incorrect radio specified */
  MRFI_ASSERT( mrfiSpiReadReg( VERSION ) >= MRFI_RADIO_MIN_VERSION );  /* obsolete radio specified  */
    c9bc:	32 c2       	dint			
    c9be:	03 43       	nop			
    c9c0:	ff 3f       	jmp	$+0      	;abs 0xc9c0

0000c9c2 <MRFI_SetRxAddrFilter>:
 * @return      zero     : successfully set filter address
 *              non-zero : illegal address
 **************************************************************************************************
 */
uint8_t MRFI_SetRxAddrFilter(uint8_t * pAddr)
{
    c9c2:	0b 12       	push	r11		
    c9c4:	0b 4f       	mov	r15,	r11	
  /*
   *  If first byte of filter address match fir byte of broadcast address,
   *  there is a conflict with hardware filtering.
   */
  if (pAddr[0] == mrfiBroadcastAddr[0])
    c9c6:	6e 4f       	mov.b	@r15,	r14	
    c9c8:	7e 93       	cmp.b	#-1,	r14	;r3 As==11
    c9ca:	0f 24       	jz	$+32     	;abs 0xc9ea

  /*
   *  Set the hardware address register.  The hardware address filtering only recognizes
   *  a single byte but this does provide at least some automatic hardware filtering.
   */
  MRFI_WRITE_REGISTER( ADDR, pAddr[0] );
    c9cc:	7f 40 09 00 	mov.b	#9,	r15	;#0x0009
    c9d0:	b0 12 ba c5 	call	#0xc5ba	
    c9d4:	0e 43       	clr	r14		
 *
 * @return      zero     : successfully set filter address
 *              non-zero : illegal address
 **************************************************************************************************
 */
uint8_t MRFI_SetRxAddrFilter(uint8_t * pAddr)
    c9d6:	0d 4b       	mov	r11,	r13	
    c9d8:	0d 5e       	add	r14,	r13	
  {
    uint8_t i;

    for (i=0; i<MRFI_ADDR_SIZE; i++)
    {
      mrfiRxFilterAddr[i] = pAddr[i];
    c9da:	ee 4d 00 02 	mov.b	@r13,	512(r14);0x0200(r14)
    c9de:	1e 53       	inc	r14		

  /* save a copy of the filter address */
  {
    uint8_t i;

    for (i=0; i<MRFI_ADDR_SIZE; i++)
    c9e0:	2e 92       	cmp	#4,	r14	;r2 As==10
    c9e2:	f9 23       	jnz	$-12     	;abs 0xc9d6
      mrfiRxFilterAddr[i] = pAddr[i];
    }
  }

  /* successfully set filter address */
  return( 0 );
    c9e4:	4f 43       	clr.b	r15		
}
    c9e6:	3b 41       	pop	r11		
    c9e8:	30 41       	ret			
   *  there is a conflict with hardware filtering.
   */
  if (pAddr[0] == mrfiBroadcastAddr[0])
  {
    /* unable to set filter address */
    return( 1 );
    c9ea:	5f 43       	mov.b	#1,	r15	;r3 As==01
    }
  }

  /* successfully set filter address */
  return( 0 );
}
    c9ec:	3b 41       	pop	r11		
    c9ee:	30 41       	ret			

0000c9f0 <MRFI_EnableRxAddrFilter>:
 * @return      none
 **************************************************************************************************
 */
void MRFI_EnableRxAddrFilter(void)
{
  MRFI_ASSERT(mrfiRxFilterAddr[0] != mrfiBroadcastAddr[0]); /* filter address must be set before enabling filter */
    c9f0:	f2 93 00 02 	cmp.b	#-1,	&0x0200	;r3 As==11
    c9f4:	09 24       	jz	$+20     	;abs 0xca08

  /* set flag to indicate filtering is enabled */
  mrfiRxFilterEnabled = 1;
    c9f6:	d2 43 52 02 	mov.b	#1,	&0x0252	;r3 As==01

  /* enable hardware filtering on the radio */
  MRFI_WRITE_REGISTER( PKTCTRL1, PKTCTRL1_ADDR_FILTER_ON );
    c9fa:	7e 40 07 00 	mov.b	#7,	r14	;#0x0007
    c9fe:	7f 40 07 00 	mov.b	#7,	r15	;#0x0007
    ca02:	b0 12 ba c5 	call	#0xc5ba	
}
    ca06:	30 41       	ret			
 * @return      none
 **************************************************************************************************
 */
void MRFI_EnableRxAddrFilter(void)
{
  MRFI_ASSERT(mrfiRxFilterAddr[0] != mrfiBroadcastAddr[0]); /* filter address must be set before enabling filter */
    ca08:	32 c2       	dint			
    ca0a:	03 43       	nop			
    ca0c:	ff 3f       	jmp	$+0      	;abs 0xca0c

0000ca0e <MRFI_DisableRxAddrFilter>:
 **************************************************************************************************
 */
void MRFI_DisableRxAddrFilter(void)
{
  /* clear flag that indicates filtering is enabled */
  mrfiRxFilterEnabled = 0;
    ca0e:	c2 43 52 02 	mov.b	#0,	&0x0252	;r3 As==00

  /* disable hardware filtering on the radio */
  MRFI_WRITE_REGISTER( PKTCTRL1, PKTCTRL1_ADDR_FILTER_OFF );
    ca12:	6e 42       	mov.b	#4,	r14	;r2 As==10
    ca14:	7f 40 07 00 	mov.b	#7,	r15	;#0x0007
    ca18:	b0 12 ba c5 	call	#0xc5ba	
}
    ca1c:	30 41       	ret			

0000ca1e <MRFI_RxAddrIsFiltered>:
 * @return      zero     : address is not filtered
 *              non-zero : address is filtered
 **************************************************************************************************
 */
uint8_t MRFI_RxAddrIsFiltered(uint8_t * pAddr)
{
    ca1e:	0b 12       	push	r11		
  uint8_t addrByte;
  uint8_t filterAddrMatches;
  uint8_t broadcastAddrMatches;

  /* first check to see if filtering is even enabled */
  if (!mrfiRxFilterEnabled)
    ca20:	c2 93 52 02 	tst.b	&0x0252	
    ca24:	14 24       	jz	$+42     	;abs 0xca4e
    ca26:	0e 43       	clr	r14		
    ca28:	4c 43       	clr.b	r12		
    ca2a:	4b 43       	clr.b	r11		
 *
 * @return      zero     : address is not filtered
 *              non-zero : address is filtered
 **************************************************************************************************
 */
uint8_t MRFI_RxAddrIsFiltered(uint8_t * pAddr)
    ca2c:	0d 4f       	mov	r15,	r13	
    ca2e:	0d 5e       	add	r14,	r13	

  /* loop through address to see if there is a match to filter address of broadcast address */
  for (i=0; i<MRFI_ADDR_SIZE; i++)
  {
    /* get byte from address to check */
    addrByte = pAddr[i];
    ca30:	6d 4d       	mov.b	@r13,	r13	

    /* compare byte to filter address byte */
    if (addrByte == mrfiRxFilterAddr[i])
    ca32:	ce 9d 00 02 	cmp.b	r13,	512(r14);0x0200(r14)
    ca36:	0e 24       	jz	$+30     	;abs 0xca54
    {
      filterAddrMatches++;
    }
    if (addrByte == mrfiBroadcastAddr[i])
    ca38:	ce 9d 5a e3 	cmp.b	r13,	-7334(r14);0xe35a(r14)
    ca3c:	0f 24       	jz	$+32     	;abs 0xca5c
    {
      broadcastAddrMatches++;
    ca3e:	1e 53       	inc	r14		
  /* clear address byte match counts */
  filterAddrMatches    = 0;
  broadcastAddrMatches = 0;

  /* loop through address to see if there is a match to filter address of broadcast address */
  for (i=0; i<MRFI_ADDR_SIZE; i++)
    ca40:	2e 92       	cmp	#4,	r14	;r2 As==10
    ca42:	f4 23       	jnz	$-22     	;abs 0xca2c
  /*
   *  If address is *not* filtered, either the "filter address match count" or
   *  the "broadcast address match count" will equal the total number of bytes
   *  in the address.
   */
  if ((broadcastAddrMatches == MRFI_ADDR_SIZE) || (filterAddrMatches == MRFI_ADDR_SIZE))
    ca44:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    ca46:	03 24       	jz	$+8      	;abs 0xca4e
  {
    /*
     *  Filtering is not enabled, so by definition the address is
     *  not filtered.  Return zero to indicate address is not filtered.
     */
    return( 0 );
    ca48:	5f 43       	mov.b	#1,	r15	;r3 As==01
    ca4a:	6b 92       	cmp.b	#4,	r11	;r2 As==10
    ca4c:	01 20       	jnz	$+4      	;abs 0xca50
   *  in the address.
   */
  if ((broadcastAddrMatches == MRFI_ADDR_SIZE) || (filterAddrMatches == MRFI_ADDR_SIZE))
  {
    /* address *not* filtered, return zero */
    return( 0 );
    ca4e:	4f 43       	clr.b	r15		
  else
  {
    /* address filtered, return non-zero */
    return( 1 );
  }
}
    ca50:	3b 41       	pop	r11		
    ca52:	30 41       	ret			
    addrByte = pAddr[i];

    /* compare byte to filter address byte */
    if (addrByte == mrfiRxFilterAddr[i])
    {
      filterAddrMatches++;
    ca54:	5b 53       	inc.b	r11		
    }
    if (addrByte == mrfiBroadcastAddr[i])
    ca56:	ce 9d 5a e3 	cmp.b	r13,	-7334(r14);0xe35a(r14)
    ca5a:	f1 23       	jnz	$-28     	;abs 0xca3e
    {
      broadcastAddrMatches++;
    ca5c:	5c 53       	inc.b	r12		
    ca5e:	ef 3f       	jmp	$-32     	;abs 0xca3e

0000ca60 <MRFI_GpioIsr>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_GpioIsr(void)
{
    ca60:	0b 12       	push	r11		
    ca62:	21 83       	decd	r1		
  /* see if sync pin interrupt is enabled and has fired */
  if (MRFI_SYNC_PIN_INT_IS_ENABLED() && MRFI_SYNC_PIN_INT_FLAG_IS_SET())
    ca64:	5f 42 2d 00 	mov.b	&0x002d,r15	
    ca68:	1f f3       	and	#1,	r15	;r3 As==01
    ca6a:	04 24       	jz	$+10     	;abs 0xca74
    ca6c:	5f 42 2b 00 	mov.b	&0x002b,r15	
    ca70:	1f f3       	and	#1,	r15	;r3 As==01
    ca72:	03 20       	jnz	$+8      	;abs 0xca7a
     *  naturally but it must be verified for every target.
     */
    MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    Mrfi_SyncPinRxIsr();
  }
}
    ca74:	21 53       	incd	r1		
    ca76:	3b 41       	pop	r11		
    ca78:	30 41       	ret			
     *  reset the interrupt capture.  In other words, if a second interrupt
     *  occurs after the flag is cleared it must be processed, i.e. this interrupt
     *  exits then immediately starts again.  Most microcontrollers handle this
     *  naturally but it must be verified for every target.
     */
    MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    ca7a:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    ca7e:	2b 00 
  /* We should receive this interrupt only in RX state
   * Should never receive it if RX was turned On only for
   * some internal mrfi processing like - during CCA.
   * Otherwise something is terribly wrong.
   */
  MRFI_ASSERT( mrfiRadioState == MRFI_RADIO_STATE_RX );
    ca80:	f2 90 03 00 	cmp.b	#3,	&0x024c	;#0x0003
    ca84:	4c 02 
    ca86:	03 24       	jz	$+8      	;abs 0xca8e
    ca88:	32 c2       	dint			
    ca8a:	03 43       	nop			
    ca8c:	ff 3f       	jmp	$+0      	;abs 0xca8c
   *  in a row to guarantee an accurate value.
   */
  {
    uint8_t rxBytesVerify;

    rxBytesVerify = mrfiSpiReadReg( RXBYTES );
    ca8e:	7f 40 3b 00 	mov.b	#59,	r15	;#0x003b
    ca92:	b0 12 34 c5 	call	#0xc534	
    ca96:	4b 4f       	mov.b	r15,	r11	
    ca98:	01 3c       	jmp	$+4      	;abs 0xca9c

    do
    {
      rxBytes = rxBytesVerify;
      rxBytesVerify = mrfiSpiReadReg( RXBYTES );
    ca9a:	4b 4f       	mov.b	r15,	r11	
    ca9c:	7f 40 3b 00 	mov.b	#59,	r15	;#0x003b
    caa0:	b0 12 34 c5 	call	#0xc534	
    }
    while (rxBytes != rxBytesVerify);
    caa4:	4f 9b       	cmp.b	r11,	r15	
    caa6:	f9 23       	jnz	$-12     	;abs 0xca9a
   *  It is possible nothing the FIFO is empty even though the interrupt fired.
   *  This can happen if address check is enabled and a non-matching packet is
   *  received.  In that case, the radio automatically removes the packet from
   *  the FIFO.
   */
  if (rxBytes == 0)
    caa8:	4b 93       	tst.b	r11		
    caaa:	e4 27       	jz	$-54     	;abs 0xca74
     *    Process frame length
     *   ----------------------
     */

    /* read the first byte from FIFO - the packet length */
    mrfiSpiReadRxFifo(&frameLen, MRFI_LENGTH_FIELD_SIZE);
    caac:	5e 43       	mov.b	#1,	r14	;r3 As==01
    caae:	0f 41       	mov	r1,	r15	
    cab0:	b0 12 8a c7 	call	#0xc78a	
     *   4) A failed transmit forced radio to IDLE state to flush the transmit FIFO.
     *      This could cause an active receive to be cut short.
     *
     *  Also check the sanity of the length to guard against rogue frames.
     */
    if ((rxBytes != (frameLen + MRFI_LENGTH_FIELD_SIZE + MRFI_RX_METRICS_SIZE))           ||
    cab4:	6e 41       	mov.b	@r1,	r14	
    cab6:	4f 4e       	mov.b	r14,	r15	
    cab8:	4b 4b       	mov.b	r11,	r11	
    caba:	0d 4f       	mov	r15,	r13	
    cabc:	3d 50 03 00 	add	#3,	r13	;#0x0003
    cac0:	0b 9d       	cmp	r13,	r11	
    cac2:	06 20       	jnz	$+14     	;abs 0xcad0
    cac4:	3f 90 16 00 	cmp	#22,	r15	;#0x0016
    cac8:	03 34       	jge	$+8      	;abs 0xcad0
        ((frameLen + MRFI_LENGTH_FIELD_SIZE) > MRFI_MAX_FRAME_SIZE) ||
    caca:	7e 90 0b 00 	cmp.b	#11,	r14	;#0x000b
    cace:	1c 2c       	jc	$+58     	;abs 0xcb08

      /*
       *  Flush receive FIFO to reset receive.  Must go to IDLE state to do this.
       *  The critical section guarantees a transmit does not occur while cleaning up.
       */
      BSP_ENTER_CRITICAL_SECTION(s);
    cad0:	0b 42       	mov	r2,	r11	
    cad2:	32 c2       	dint			
    cad4:	03 43       	nop			
      MRFI_STROBE_IDLE_AND_WAIT();
    cad6:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    cada:	b0 12 34 c4 	call	#0xc434	
    cade:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    cae2:	b0 12 34 c4 	call	#0xc434	
    cae6:	3f b0 f0 00 	bit	#240,	r15	;#0x00f0
    caea:	f9 23       	jnz	$-12     	;abs 0xcade
      mrfiSpiCmdStrobe( SFRX );
    caec:	7f 40 3a 00 	mov.b	#58,	r15	;#0x003a
    caf0:	b0 12 34 c4 	call	#0xc434	
      mrfiSpiCmdStrobe( SRX );
    caf4:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    caf8:	b0 12 34 c4 	call	#0xc434	
      BSP_EXIT_CRITICAL_SECTION(s);
    cafc:	3b b2       	bit	#8,	r11	;r2 As==11
    cafe:	ba 27       	jz	$-138    	;abs 0xca74
    cb00:	32 d2       	eint			
     *  naturally but it must be verified for every target.
     */
    MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    Mrfi_SyncPinRxIsr();
  }
}
    cb02:	21 53       	incd	r1		
    cb04:	3b 41       	pop	r11		
    cb06:	30 41       	ret			
       *    Get packet
       *   ------------
       */

      /* clean out buffer to help protect against spurious frames */
      memset(mrfiIncomingPacket.frame, 0x00, sizeof(mrfiIncomingPacket.frame));
    cb08:	82 43 34 02 	mov	#0,	&0x0234	;r3 As==00
    cb0c:	82 43 36 02 	mov	#0,	&0x0236	;r3 As==00
    cb10:	82 43 38 02 	mov	#0,	&0x0238	;r3 As==00
    cb14:	82 43 3a 02 	mov	#0,	&0x023a	;r3 As==00
    cb18:	82 43 3c 02 	mov	#0,	&0x023c	;r3 As==00
    cb1c:	82 43 3e 02 	mov	#0,	&0x023e	;r3 As==00
    cb20:	82 43 40 02 	mov	#0,	&0x0240	;r3 As==00
    cb24:	82 43 42 02 	mov	#0,	&0x0242	;r3 As==00
    cb28:	82 43 44 02 	mov	#0,	&0x0244	;r3 As==00
    cb2c:	82 43 46 02 	mov	#0,	&0x0246	;r3 As==00
    cb30:	82 43 48 02 	mov	#0,	&0x0248	;r3 As==00

      /* set length field */
      mrfiIncomingPacket.frame[MRFI_LENGTH_FIELD_OFS] = frameLen;
    cb34:	c2 4e 34 02 	mov.b	r14,	&0x0234	

      /* get packet from FIFO */
      mrfiSpiReadRxFifo(&(mrfiIncomingPacket.frame[MRFI_FRAME_BODY_OFS]), frameLen);
    cb38:	3f 40 35 02 	mov	#565,	r15	;#0x0235
    cb3c:	b0 12 8a c7 	call	#0xc78a	

      /* get receive metrics from FIFO */
      mrfiSpiReadRxFifo(&(mrfiIncomingPacket.rxMetrics[0]), MRFI_RX_METRICS_SIZE);
    cb40:	6e 43       	mov.b	#2,	r14	;r3 As==10
    cb42:	3f 40 4a 02 	mov	#586,	r15	;#0x024a
    cb46:	b0 12 8a c7 	call	#0xc78a	
       *  This could cause reads from an empty receive FIFO which puts the radio
       *  into an undefined state.
       */

      /* determine if CRC failed */
      if (!(mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_CRC_LQI_OFS] & MRFI_RX_METRICS_CRC_OK_MASK))
    cb4a:	5b 42 4b 02 	mov.b	&0x024b,r11	
    cb4e:	4b 93       	tst.b	r11		
    cb50:	91 37       	jge	$-220    	;abs 0xca74
         *    Filtering
         *   -----------
         */

        /* if address is not filtered, receive is successful */
        if (!MRFI_RxAddrIsFiltered(MRFI_P_DST_ADDR(&mrfiIncomingPacket)))
    cb52:	3f 40 35 02 	mov	#565,	r15	;#0x0235
    cb56:	b0 12 1e ca 	call	#0xca1e	
    cb5a:	4f 93       	tst.b	r15		
    cb5c:	8b 23       	jnz	$-232    	;abs 0xca74
             *   --------------------
             */

            /* Convert the raw RSSI value and do offset compensation for this radio */
            mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_RSSI_OFS] =
                Mrfi_CalculateRssi(mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_RSSI_OFS]);
    cb5e:	5f 42 4a 02 	mov.b	&0x024a,r15	
  int16_t rssi;

  /* The raw value is in 2's complement and in half db steps. Convert it to
   * decimal taking into account the offset value.
   */
  if(rawValue >= 128)
    cb62:	4f 93       	tst.b	r15		
    cb64:	11 38       	jl	$+36     	;abs 0xcb88
  {
    rssi = (int16_t)(rawValue - 256)/2 - MRFI_RSSI_OFFSET;
  }
  else
  {
    rssi = (rawValue/2) - MRFI_RSSI_OFFSET;
    cb66:	12 c3       	clrc			
    cb68:	4f 10       	rrc.b	r15		
    cb6a:	4f 4f       	mov.b	r15,	r15	
    cb6c:	3f 50 b8 ff 	add	#-72,	r15	;#0xffb8
    cb70:	4f 4f       	mov.b	r15,	r15	
             *    Receive successful
             *   --------------------
             */

            /* Convert the raw RSSI value and do offset compensation for this radio */
            mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_RSSI_OFS] =
    cb72:	c2 4f 4a 02 	mov.b	r15,	&0x024a	
                Mrfi_CalculateRssi(mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_RSSI_OFS]);

            /* Remove the CRC valid bit from the LQI byte */
            mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_CRC_LQI_OFS] =
    cb76:	7b f0 7f 00 	and.b	#127,	r11	;#0x007f
    cb7a:	c2 4b 4b 02 	mov.b	r11,	&0x024b	
              (mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_CRC_LQI_OFS] & MRFI_RX_METRICS_LQI_MASK);


            /* call external, higher level "receive complete" processing routine */
            MRFI_RxCompleteISR();
    cb7e:	b0 12 00 d5 	call	#0xd500	
     *  naturally but it must be verified for every target.
     */
    MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    Mrfi_SyncPinRxIsr();
  }
}
    cb82:	21 53       	incd	r1		
    cb84:	3b 41       	pop	r11		
    cb86:	30 41       	ret			
  /* The raw value is in 2's complement and in half db steps. Convert it to
   * decimal taking into account the offset value.
   */
  if(rawValue >= 128)
  {
    rssi = (int16_t)(rawValue - 256)/2 - MRFI_RSSI_OFFSET;
    cb88:	4e 4f       	mov.b	r15,	r14	
    cb8a:	0f 4e       	mov	r14,	r15	
    cb8c:	3f 50 00 ff 	add	#-256,	r15	;#0xff00
    cb90:	0f 93       	tst	r15		
    cb92:	01 34       	jge	$+4      	;abs 0xcb96
    cb94:	1f 53       	inc	r15		
    cb96:	0f 11       	rra	r15		
    cb98:	3f 50 b8 ff 	add	#-72,	r15	;#0xffb8
  {
    rssi = (rawValue/2) - MRFI_RSSI_OFFSET;
  }

  /* Restrict this value to least value can be held in an 8 bit signed int */
  if(rssi < -128)
    cb9c:	3f 90 80 ff 	cmp	#-128,	r15	;#0xff80
    cba0:	e7 37       	jge	$-48     	;abs 0xcb70
    cba2:	7f 40 80 ff 	mov.b	#-128,	r15	;#0xff80
    cba6:	e5 3f       	jmp	$-52     	;abs 0xcb72

0000cba8 <BSP_GpioPort1Isr>:
 *
 * @return      -
 **************************************************************************************************
 */
BSP_ISR_FUNCTION( BSP_GpioPort1Isr, PORT2_VECTOR )
{
    cba8:	0f 12       	push	r15		
    cbaa:	0e 12       	push	r14		
    cbac:	0d 12       	push	r13		
    cbae:	0c 12       	push	r12		
  /*
   *  This ISR is easily replaced.  The new ISR must simply
   *  include the following function call.
   */
  MRFI_GpioIsr();
    cbb0:	b0 12 60 ca 	call	#0xca60	
}
    cbb4:	3c 41       	pop	r12		
    cbb6:	3d 41       	pop	r13		
    cbb8:	3e 41       	pop	r14		
    cbba:	3f 41       	pop	r15		
    cbbc:	00 13       	reti			

0000cbbe <BSP_EARLY_INIT>:
 **************************************************************************************************
*/
int BSP_EARLY_INIT(void)
{
  /* Disable watchdog timer */
  WDTCTL = WDTPW | WDTHOLD;
    cbbe:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    cbc2:	20 01 

  /* Return 1 - run seg_init */
  return (1);
}
    cbc4:	1f 43       	mov	#1,	r15	;r3 As==01
    cbc6:	30 41       	ret			

0000cbc8 <BSP_InitBoard>:
 **************************************************************************************************
 */
void BSP_InitBoard(void)
{
  /* configure internal digitally controlled oscillator */
  DCOCTL  = BSP_CONFIG_MSP430_DCOCTL;
    cbc8:	d2 42 fc 10 	mov.b	&0x10fc,&0x0056	
    cbcc:	56 00 
  BCSCTL1 = BSP_CONFIG_MSP430_BCSCTL1;
    cbce:	d2 42 fd 10 	mov.b	&0x10fd,&0x0057	
    cbd2:	57 00 

  /* Configure TimerA for use by the delay function */

  /* Reset the timer */
  TACTL |= TACLR; /* Set the TACLR */
    cbd4:	a2 d2 60 01 	bis	#4,	&0x0160	;r2 As==10

  /* Clear all settings */
  TACTL = 0x0;
    cbd8:	82 43 60 01 	mov	#0,	&0x0160	;r3 As==00

  /* Select the clk source to be - SMCLK (Sub-Main CLK)*/
  TACTL |= TASSEL_2;
    cbdc:	b2 d0 00 02 	bis	#512,	&0x0160	;#0x0200
    cbe0:	60 01 
  if (!sIterationsPerUsec)
  {
    sIterationsPerUsec = 1;
  }
#endif   /* SW_TIMER */
}
    cbe2:	30 41       	ret			

0000cbe4 <BSP_Delay>:
 **************************************************************************************************
 */
void BSP_Delay(uint16_t usec)
#if !defined(SW_TIMER)
{
  TACCTL0 &= ~CCIFG;
    cbe4:	b2 f0 fe ff 	and	#-2,	&0x0162	;#0xfffe
    cbe8:	62 01 
  TAR = 0; /* initial count */
    cbea:	82 43 70 01 	mov	#0,	&0x0170	;r3 As==00
  TACCR0 = BSP_TIMER_CLK_MHZ*usec; /* compare count. (delay in ticks) */
    cbee:	0f 5f       	rla	r15		
    cbf0:	0f 5f       	rla	r15		
    cbf2:	0f 5f       	rla	r15		
    cbf4:	82 4f 72 01 	mov	r15,	&0x0172	

  /* Start the timer in UP mode */
  TACTL |= MC_1;
    cbf8:	b2 d0 10 00 	bis	#16,	&0x0160	;#0x0010
    cbfc:	60 01 

  /* Loop till compare interrupt flag is set */
  while(!(TACCTL0 & CCIFG));
    cbfe:	92 b3 62 01 	bit	#1,	&0x0162	;r3 As==01
    cc02:	fd 27       	jz	$-4      	;abs 0xcbfe

  /* Stop the timer */
  TACTL &= ~(MC_1);
    cc04:	b2 f0 ef ff 	and	#-17,	&0x0160	;#0xffef
    cc08:	60 01 

  /* Clear the interrupt flag */
   TACCTL0 &= ~CCIFG;
    cc0a:	b2 f0 fe ff 	and	#-2,	&0x0162	;#0xfffe
    cc0e:	62 01 
}
    cc10:	30 41       	ret			

0000cc12 <BSP_InitLeds>:
 **************************************************************************************************
 */
void BSP_InitLeds(void)
{
  /* configure LEDs */
  BSP_CONFIG_LED1();
    cc12:	d2 d3 22 00 	bis.b	#1,	&0x0022	;r3 As==01
  BSP_CONFIG_LED2();
    cc16:	f2 d0 20 00 	bis.b	#32,	&0x002a	;#0x0020
    cc1a:	2a 00 

  /* peform extended configuration if needed */
  BSP_LED_EXTENDED_CONFIG();

  /* turn all LEDs off as power-up default */
  BSP_TURN_OFF_LED1();
    cc1c:	f2 f0 fe ff 	and.b	#-2,	&0x0021	;#0xfffe
    cc20:	21 00 
  BSP_TURN_OFF_LED2();
    cc22:	f2 f0 df ff 	and.b	#-33,	&0x0029	;#0xffdf
    cc26:	29 00 
  BSP_TURN_OFF_LED4();
  BSP_TURN_OFF_LED5();
  BSP_TURN_OFF_LED6();
  BSP_TURN_OFF_LED7();
  BSP_TURN_OFF_LED8();
}
    cc28:	30 41       	ret			

0000cc2a <BSP_InitDrivers>:
 **************************************************************************************************
 */
void BSP_InitDrivers(void)
{
#if (!defined BSP_NO_LEDS)
  BSP_InitLeds();
    cc2a:	b0 12 12 cc 	call	#0xcc12	
  BSP_CONFIG_BUTTON6();
  BSP_CONFIG_BUTTON7();
  BSP_CONFIG_BUTTON8();

  /* peform extended configuration if needed */
  BSP_BUTTON_EXTENDED_CONFIG();
    cc2e:	f2 d2 21 00 	bis.b	#8,	&0x0021	;r2 As==11
    cc32:	f2 d2 27 00 	bis.b	#8,	&0x0027	;r2 As==11
#endif

#if (!defined BSP_NO_BUTTONS)
  BSP_InitButtons();
#endif
}
    cc36:	30 41       	ret			

0000cc38 <BSP_Init>:
 *
 * @return      none
 **************************************************************************************************
 */
void BSP_Init(void)
{
    cc38:	21 83       	decd	r1		
 **************************************************************************************************
 */
void BSP_InitBoard(void)
{
  /* configure internal digitally controlled oscillator */
  DCOCTL  = BSP_CONFIG_MSP430_DCOCTL;
    cc3a:	d2 42 fc 10 	mov.b	&0x10fc,&0x0056	
    cc3e:	56 00 
  BCSCTL1 = BSP_CONFIG_MSP430_BCSCTL1;
    cc40:	d2 42 fd 10 	mov.b	&0x10fd,&0x0057	
    cc44:	57 00 

  /* Configure TimerA for use by the delay function */

  /* Reset the timer */
  TACTL |= TACLR; /* Set the TACLR */
    cc46:	a2 d2 60 01 	bis	#4,	&0x0160	;r2 As==10

  /* Clear all settings */
  TACTL = 0x0;
    cc4a:	82 43 60 01 	mov	#0,	&0x0160	;r3 As==00

  /* Select the clk source to be - SMCLK (Sub-Main CLK)*/
  TACTL |= TASSEL_2;
    cc4e:	b2 d0 00 02 	bis	#512,	&0x0160	;#0x0200
    cc52:	60 01 
  BSP_INIT_BOARD();
  BSP_INIT_DRIVERS();
    cc54:	b0 12 2a cc 	call	#0xcc2a	
  {
    uint16_t test = 0x00AA; /* first storage byte of 'test' is non-zero for little endian */
    BSP_ASSERT(!(*((uint8_t *)&test)) == !BSP_LITTLE_ENDIAN); /* endianess mismatch */
  }
#endif
}
    cc58:	21 53       	incd	r1		
    cc5a:	30 41       	ret			

0000cc5c <BSP_InitButtons>:
    cc5c:	f2 d2 21 00 	bis.b	#8,	&0x0021	;r2 As==11
    cc60:	f2 d2 27 00 	bis.b	#8,	&0x0027	;r2 As==11
}
    cc64:	30 41       	ret			

0000cc66 <SMPL_Init>:
 *             SMPL_NO_JOIN     No Join reply. AP possibly not yet up.
 *             SMPL_NO_CHANNEL  Only if Frequency Agility enabled. Channel scan
 *                              failed. AP possibly not yet up.
 */
smplStatus_t SMPL_Init(uint8_t (*f)(linkID_t))
{
    cc66:	21 83       	decd	r1		
  smplStatus_t rc;

  if (!sInit_done)
    cc68:	c2 93 54 02 	tst.b	&0x0254	
    cc6c:	13 20       	jnz	$+40     	;abs 0xcc94
  {
    /* set up radio. */
    MRFI_Init();
    cc6e:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    cc72:	b0 12 08 c8 	call	#0xc808	

    /* initialize network */
    if ((rc=nwk_nwkInit(f)) != SMPL_SUCCESS)
    cc76:	2f 41       	mov	@r1,	r15	
    cc78:	b0 12 aa ce 	call	#0xceaa	
    cc7c:	0f 93       	tst	r15		
    cc7e:	02 24       	jz	$+6      	;abs 0xcc84

  /* Join. if no AP or Join fails that status is returned. */
  rc = nwk_join();

  return rc;
}
    cc80:	21 53       	incd	r1		
    cc82:	30 41       	ret			
    if ((rc=nwk_nwkInit(f)) != SMPL_SUCCESS)
    {
      return rc;
    }

    MRFI_WakeUp();
    cc84:	b0 12 d2 c5 	call	#0xc5d2	
    MRFI_RxOn();
#endif

#if defined( END_DEVICE )
    /* All except End Devices are in promiscuous mode */
    MRFI_SetRxAddrFilter((uint8_t *)nwk_getMyAddress());
    cc88:	b0 12 26 dc 	call	#0xdc26	
    cc8c:	b0 12 c2 c9 	call	#0xc9c2	
    MRFI_EnableRxAddrFilter();
    cc90:	b0 12 f0 c9 	call	#0xc9f0	
#endif
  }
  sInit_done = 1;
    cc94:	d2 43 54 02 	mov.b	#1,	&0x0254	;r3 As==01

  /* Join. if no AP or Join fails that status is returned. */
  rc = nwk_join();
    cc98:	b0 12 40 d3 	call	#0xd340	

  return rc;
}
    cc9c:	21 53       	incd	r1		
    cc9e:	30 41       	ret			

0000cca0 <SMPL_LinkListen>:
*                            Interval set in #defines above. linkID not valid.
 *
 */

smplStatus_t SMPL_LinkListen(linkID_t *linkID)
{
    cca0:	0b 12       	push	r11		
    cca2:	0a 12       	push	r10		
    cca4:	09 12       	push	r9		
    cca6:	08 12       	push	r8		
    cca8:	08 4f       	mov	r15,	r8	
  uint8_t  radioState = MRFI_GetRadioState();
    ccaa:	b0 12 ea c3 	call	#0xc3ea	
    ccae:	49 4f       	mov.b	r15,	r9	

  /* Set the context. We want to reject any link frames received if
   * we're not listening. For example if we're an AP we are in
   * promiscuous mode and we'll see any broadcast link frames.
   */
  nwk_setListenContext(LINK_LISTEN_ON);
    ccb0:	4f 43       	clr.b	r15		
    ccb2:	b0 12 8e da 	call	#0xda8e	

  NWK_CHECK_FOR_SETRX(radioState);
    ccb6:	79 90 03 00 	cmp.b	#3,	r9	;#0x0003
    ccba:	04 24       	jz	$+10     	;abs 0xccc4
    ccbc:	59 93       	cmp.b	#1,	r9	;r3 As==01
    ccbe:	2d 24       	jz	$+92     	;abs 0xcd1a
    ccc0:	b0 12 ec c4 	call	#0xc4ec	
*                            Interval set in #defines above. linkID not valid.
 *
 */

smplStatus_t SMPL_LinkListen(linkID_t *linkID)
{
    ccc4:	3b 40 f4 01 	mov	#500,	r11	;#0x01f4
    ccc8:	06 3c       	jmp	$+14     	;abs 0xccd6
    /* check the semaphore. local port is assigned when the reply is sent. */
    if ((locLinkID=nwk_getLocalLinkID()))
    {
      break;
    }
    NWK_DELAY(LINKLISTEN_POLL_PERIOD_MS);
    ccca:	3f 40 0a 00 	mov	#10,	r15	;#0x000a
    ccce:	b0 12 4e c3 	call	#0xc34e	
    ccd2:	3b 53       	add	#-1,	r11	;r3 As==11
   */
  nwk_setListenContext(LINK_LISTEN_ON);

  NWK_CHECK_FOR_SETRX(radioState);

  for (i=0; i<LINKLISTEN_POLL_COUNT; ++i)
    ccd4:	05 24       	jz	$+12     	;abs 0xcce0
  {
    /* check the semaphore. local port is assigned when the reply is sent. */
    if ((locLinkID=nwk_getLocalLinkID()))
    ccd6:	b0 12 32 da 	call	#0xda32	
    ccda:	4a 4f       	mov.b	r15,	r10	
    ccdc:	4f 93       	tst.b	r15		
    ccde:	f5 27       	jz	$-20     	;abs 0xccca
      break;
    }
    NWK_DELAY(LINKLISTEN_POLL_PERIOD_MS);
  }

  NWK_CHECK_FOR_RESTORE_STATE(radioState);
    cce0:	79 90 03 00 	cmp.b	#3,	r9	;#0x0003
    cce4:	04 24       	jz	$+10     	;abs 0xccee
    cce6:	59 93       	cmp.b	#1,	r9	;r3 As==01
    cce8:	15 24       	jz	$+44     	;abs 0xcd14
    ccea:	b0 12 b8 c4 	call	#0xc4b8	

  /* If the listen is terminated without hearing a message and setting a
   * link ID the listen context must be explicitly turned off.
   */
  if (!(locLinkID))
    ccee:	4a 93       	tst.b	r10		
    ccf0:	08 24       	jz	$+18     	;abs 0xcd02
  {
    nwk_setListenContext(LINK_LISTEN_OFF);
    return SMPL_TIMEOUT;
  }

  *linkID = locLinkID;
    ccf2:	c8 4a 00 00 	mov.b	r10,	0(r8)	;0x0000(r8)

  return SMPL_SUCCESS;
    ccf6:	0f 43       	clr	r15		
}
    ccf8:	38 41       	pop	r8		
    ccfa:	39 41       	pop	r9		
    ccfc:	3a 41       	pop	r10		
    ccfe:	3b 41       	pop	r11		
    cd00:	30 41       	ret			
  /* If the listen is terminated without hearing a message and setting a
   * link ID the listen context must be explicitly turned off.
   */
  if (!(locLinkID))
  {
    nwk_setListenContext(LINK_LISTEN_OFF);
    cd02:	5f 43       	mov.b	#1,	r15	;r3 As==01
    cd04:	b0 12 8e da 	call	#0xda8e	
    return SMPL_TIMEOUT;
    cd08:	1f 43       	mov	#1,	r15	;r3 As==01
  }

  *linkID = locLinkID;

  return SMPL_SUCCESS;
}
    cd0a:	38 41       	pop	r8		
    cd0c:	39 41       	pop	r9		
    cd0e:	3a 41       	pop	r10		
    cd10:	3b 41       	pop	r11		
    cd12:	30 41       	ret			
      break;
    }
    NWK_DELAY(LINKLISTEN_POLL_PERIOD_MS);
  }

  NWK_CHECK_FOR_RESTORE_STATE(radioState);
    cd14:	b0 12 0c c5 	call	#0xc50c	
    cd18:	ea 3f       	jmp	$-42     	;abs 0xccee
   * we're not listening. For example if we're an AP we are in
   * promiscuous mode and we'll see any broadcast link frames.
   */
  nwk_setListenContext(LINK_LISTEN_ON);

  NWK_CHECK_FOR_SETRX(radioState);
    cd1a:	b0 12 d2 c5 	call	#0xc5d2	
    cd1e:	d0 3f       	jmp	$-94     	;abs 0xccc0

0000cd20 <SMPL_SendOpt>:
 *             SMPL_TX_CCA_FAIL  CCA failure.
 *             SMPL_NO_ACK       If application auto acknowledgement enabled
 *                               and no acknowledgement is received
 */
smplStatus_t SMPL_SendOpt(linkID_t lid, uint8_t *msg, uint8_t len, txOpt_t options)
{
    cd20:	0b 12       	push	r11		
    cd22:	0a 12       	push	r10		
    cd24:	09 12       	push	r9		
    cd26:	08 12       	push	r8		
    cd28:	0a 4e       	mov	r14,	r10	
    cd2a:	49 4d       	mov.b	r13,	r9	
    cd2c:	08 4c       	mov	r12,	r8	
  frameInfo_t  *pFrameInfo;
  connInfo_t   *pCInfo     = nwk_getConnInfo(lid);
    cd2e:	b0 12 b8 cf 	call	#0xcfb8	
    cd32:	0b 4f       	mov	r15,	r11	
  uint8_t       radioState;
  uint8_t       ackreq     = 0;
#if defined(ACCESS_POINT)
  uint8_t  loc;
#endif
  radioState = MRFI_GetRadioState();
    cd34:	b0 12 ea c3 	call	#0xc3ea	
  /* we have the connection info for this Link ID. make sure it is valid. */
   if (!pCInfo || ((rc=nwk_checkConnInfo(pCInfo, CHK_TX)) != SMPL_SUCCESS))
    cd38:	0b 93       	tst	r11		
    cd3a:	0d 24       	jz	$+28     	;abs 0xcd56
    cd3c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    cd3e:	0f 4b       	mov	r11,	r15	
    cd40:	b0 12 90 d0 	call	#0xd090	
    cd44:	0f 93       	tst	r15		
    cd46:	08 20       	jnz	$+18     	;abs 0xcd58
  {
    return rc;
  }

  /* parameter sanity check... */
  if (!msg || (len > MAX_APP_PAYLOAD))
    cd48:	0a 93       	tst	r10		
    cd4a:	06 24       	jz	$+14     	;abs 0xcd58
    cd4c:	79 90 0b 00 	cmp.b	#11,	r9	;#0x000b
    cd50:	03 2c       	jc	$+8      	;abs 0xcd58

  /* Build an outgoing message frame destined for the port from the
   * connection info using the destination address also from the
   * connection info.
   */
  if (SMPL_TXOPTION_NONE == options)
    cd52:	08 93       	tst	r8		
    cd54:	06 24       	jz	$+14     	;abs 0xcd62
    }
  }
#endif  /* APP_AUTO_ACK */
  else
  {
    return SMPL_BAD_PARAM;
    cd56:	2f 43       	mov	#2,	r15	;r3 As==10
    BSP_EXIT_CRITICAL_SECTION(intState);
  }

  return rc;
#endif  /* APP_AUTO_ACK */
}
    cd58:	38 41       	pop	r8		
    cd5a:	39 41       	pop	r9		
    cd5c:	3a 41       	pop	r10		
    cd5e:	3b 41       	pop	r11		
    cd60:	30 41       	ret			
   * connection info using the destination address also from the
   * connection info.
   */
  if (SMPL_TXOPTION_NONE == options)
  {
    pFrameInfo = nwk_buildFrame(pCInfo->portTx, msg, len, pCInfo->hops2target);
    cd62:	5c 4b 01 00 	mov.b	1(r11),	r12	;0x0001(r11)
    cd66:	4d 49       	mov.b	r9,	r13	
    cd68:	0e 4a       	mov	r10,	r14	
    cd6a:	5f 4b 09 00 	mov.b	9(r11),	r15	;0x0009(r11)
    cd6e:	b0 12 6c d4 	call	#0xd46c	
  else
  {
    return SMPL_BAD_PARAM;
  }

  if (!pFrameInfo)
    cd72:	0f 93       	tst	r15		
    cd74:	10 24       	jz	$+34     	;abs 0xcd96
  {
    return SMPL_NOMEM;
  }
  memcpy(MRFI_P_DST_ADDR(&pFrameInfo->mrfiPkt), pCInfo->peerAddr, NET_ADDR_SIZE);
    cd76:	df 4b 02 00 	mov.b	2(r11),	3(r15)	;0x0002(r11), 0x0003(r15)
    cd7a:	03 00 
    cd7c:	df 4b 03 00 	mov.b	3(r11),	4(r15)	;0x0003(r11), 0x0004(r15)
    cd80:	04 00 
    cd82:	df 4b 04 00 	mov.b	4(r11),	5(r15)	;0x0004(r11), 0x0005(r15)
    cd86:	05 00 
    cd88:	df 4b 05 00 	mov.b	5(r11),	6(r15)	;0x0005(r11), 0x0006(r15)
    cd8c:	06 00 
     return SMPL_SUCCESS;
  }
  else
#endif  /* ACCESS_POINT */
  {
    rc = nwk_sendFrame(pFrameInfo, MRFI_TX_TYPE_CCA);
    cd8e:	5e 43       	mov.b	#1,	r14	;r3 As==01
    cd90:	b0 12 7c d6 	call	#0xd67c	
  }

#if !defined(APP_AUTO_ACK)
  /* save a little code space with this #if */
  (void) ackreq;    /* keep compiler happy */
  return rc;
    cd94:	e1 3f       	jmp	$-60     	;abs 0xcd58
    return SMPL_BAD_PARAM;
  }

  if (!pFrameInfo)
  {
    return SMPL_NOMEM;
    cd96:	3f 40 03 00 	mov	#3,	r15	;#0x0003
    cd9a:	de 3f       	jmp	$-66     	;abs 0xcd58

0000cd9c <SMPL_Send>:
 *             SMPL_NOMEM        No room in output frame queue
 *             SMPL_TX_CCA_FAIL  CCA failure.
 */
smplStatus_t SMPL_Send(linkID_t lid, uint8_t *msg, uint8_t len)
{
  return SMPL_SendOpt(lid, msg, len, SMPL_TXOPTION_NONE);
    cd9c:	0c 43       	clr	r12		
    cd9e:	b0 12 20 cd 	call	#0xcd20	
}
    cda2:	30 41       	ret			

0000cda4 <SMPL_Receive>:
 *              SMPL_TX_CCA_FAIL    Could not send poll frame
 *              SMPL_NOMEM          No memory in output frame queue
 *              SMPL_NO_CHANNEL     Frequency Agility enabled and could not find channel
 */
smplStatus_t SMPL_Receive(linkID_t lid, uint8_t *msg, uint8_t *len)
{
    cda4:	0b 12       	push	r11		
    cda6:	0a 12       	push	r10		
    cda8:	09 12       	push	r9		
    cdaa:	21 82       	sub	#4,	r1	;r2 As==10
    cdac:	49 4f       	mov.b	r15,	r9	
    cdae:	0b 4e       	mov	r14,	r11	
    cdb0:	0a 4d       	mov	r13,	r10	
  connInfo_t  *pCInfo = nwk_getConnInfo(lid);
    cdb2:	b0 12 b8 cf 	call	#0xcfb8	
  smplStatus_t rc = SMPL_BAD_PARAM;
  rcvContext_t rcv;

  if (!pCInfo || ((rc=nwk_checkConnInfo(pCInfo, CHK_RX)) != SMPL_SUCCESS))
    cdb6:	0f 93       	tst	r15		
    cdb8:	1c 24       	jz	$+58     	;abs 0xcdf2
    cdba:	4e 43       	clr.b	r14		
    cdbc:	b0 12 90 d0 	call	#0xd090	
    cdc0:	0f 93       	tst	r15		
    cdc2:	05 24       	jz	$+12     	;abs 0xcdce
#endif

#else  /* RX_POLLS */
  return nwk_retrieveFrame(&rcv, msg, len, 0, 0);
#endif  /* RX_POLLS */
}
    cdc4:	21 52       	add	#4,	r1	;r2 As==10
    cdc6:	39 41       	pop	r9		
    cdc8:	3a 41       	pop	r10		
    cdca:	3b 41       	pop	r11		
    cdcc:	30 41       	ret			
  if (!pCInfo || ((rc=nwk_checkConnInfo(pCInfo, CHK_RX)) != SMPL_SUCCESS))
  {
    return rc;
  }

  rcv.type  = RCV_APP_LID;
    cdce:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01, 0x0000(r1)
  rcv.t.lid = lid;
    cdd2:	c1 49 02 00 	mov.b	r9,	2(r1)	;0x0002(r1)
#if defined(FREQUENCY_AGILITY)
  return SMPL_NO_CHANNEL;
#endif

#else  /* RX_POLLS */
  return nwk_retrieveFrame(&rcv, msg, len, 0, 0);
    cdd6:	03 12       	push	#0		;r3 As==00
    cdd8:	0c 43       	clr	r12		
    cdda:	0d 4a       	mov	r10,	r13	
    cddc:	0e 4b       	mov	r11,	r14	
    cdde:	0f 41       	mov	r1,	r15	
    cde0:	2f 53       	incd	r15		
    cde2:	b0 12 96 d5 	call	#0xd596	
    cde6:	21 53       	incd	r1		
#endif  /* RX_POLLS */
}
    cde8:	21 52       	add	#4,	r1	;r2 As==10
    cdea:	39 41       	pop	r9		
    cdec:	3a 41       	pop	r10		
    cdee:	3b 41       	pop	r11		
    cdf0:	30 41       	ret			
 *              SMPL_NO_CHANNEL     Frequency Agility enabled and could not find channel
 */
smplStatus_t SMPL_Receive(linkID_t lid, uint8_t *msg, uint8_t *len)
{
  connInfo_t  *pCInfo = nwk_getConnInfo(lid);
  smplStatus_t rc = SMPL_BAD_PARAM;
    cdf2:	2f 43       	mov	#2,	r15	;r3 As==10
#endif

#else  /* RX_POLLS */
  return nwk_retrieveFrame(&rcv, msg, len, 0, 0);
#endif  /* RX_POLLS */
}
    cdf4:	21 52       	add	#4,	r1	;r2 As==10
    cdf6:	39 41       	pop	r9		
    cdf8:	3a 41       	pop	r10		
    cdfa:	3b 41       	pop	r11		
    cdfc:	30 41       	ret			

0000cdfe <SMPL_Link>:
 *             SMPL_NO_LINK       No reply frame during wait window.
 *             SMPL_TX_CCA_FAIL   Could not send Link frame.
 */
smplStatus_t SMPL_Link(linkID_t *lid)
{
  return nwk_link(lid);
    cdfe:	b0 12 0e d7 	call	#0xd70e	
}
    ce02:	30 41       	ret			

0000ce04 <SMPL_Ioctl>:
 *           SMPL_BAD_PARAM is returned if this API is called before
 *                          initialization and the object is not one of
 *                          the valid exceptions.
 */
smplStatus_t SMPL_Ioctl(ioctlObject_t object, ioctlAction_t action, void *val)
{
    ce04:	21 83       	decd	r1		
    ce06:	0c 4e       	mov	r14,	r12	
  smplStatus_t rc;

  /* if init hasn't occurred see if access is still valid */
  if (!sInit_done && !ioctlPreInitAccessIsOK(object))
    ce08:	c2 93 54 02 	tst.b	&0x0254	
    ce0c:	0c 20       	jnz	$+26     	;abs 0xce26
    ce0e:	0e 4f       	mov	r15,	r14	
    ce10:	3e 50 fb ff 	add	#-5,	r14	;#0xfffb
    ce14:	3e 90 06 00 	cmp	#6,	r14	;#0x0006
    ce18:	03 28       	jnc	$+8      	;abs 0xce20
        *((uint8_t *)val) = nwk_getProtocolVersion();
        rc = SMPL_SUCCESS;
      }
      else
      {
        rc = SMPL_BAD_PARAM;
    ce1a:	2f 43       	mov	#2,	r15	;r3 As==10
      rc = SMPL_BAD_PARAM;
      break;
  }

  return rc;
}
    ce1c:	21 53       	incd	r1		
    ce1e:	30 41       	ret			
smplStatus_t SMPL_Ioctl(ioctlObject_t object, ioctlAction_t action, void *val)
{
  smplStatus_t rc;

  /* if init hasn't occurred see if access is still valid */
  if (!sInit_done && !ioctlPreInitAccessIsOK(object))
    ce20:	ce 93 b4 e3 	tst.b	-7244(r14)	;0xe3b4(r14)
    ce24:	fa 27       	jz	$-10     	;abs 0xce1a
  {
    return SMPL_BAD_PARAM;
  }

  switch (object)
    ce26:	3f 90 09 00 	cmp	#9,	r15	;#0x0009
    ce2a:	f7 2f       	jc	$-16     	;abs 0xce1a
    ce2c:	0f 5f       	rla	r15		
    ce2e:	10 4f a2 e3 	br	-7262(r15)	;0xe3a2(r15)
        rc = SMPL_BAD_PARAM;
      }
      break;

    case IOCTL_OBJ_PROTOVER:
      if (IOCTL_ACT_GET == action)
    ce32:	1c 93       	cmp	#1,	r12	;r3 As==01
    ce34:	f2 23       	jnz	$-26     	;abs 0xce1a
      {
        *((uint8_t *)val) = nwk_getProtocolVersion();
    ce36:	81 4d 00 00 	mov	r13,	0(r1)	;0x0000(r1)
    ce3a:	b0 12 3e dc 	call	#0xdc3e	
    ce3e:	2d 41       	mov	@r1,	r13	
    ce40:	cd 4f 00 00 	mov.b	r15,	0(r13)	;0x0000(r13)
        rc = SMPL_SUCCESS;
    ce44:	0f 43       	clr	r15		
    ce46:	ea 3f       	jmp	$-42     	;abs 0xce1c
    case IOCTL_OBJ_FREQ:
      rc = nwk_freqControl(action, val);
      break;
#endif
    case IOCTL_OBJ_FWVER:
      if (IOCTL_ACT_GET == action)
    ce48:	1c 93       	cmp	#1,	r12	;r3 As==01
    ce4a:	e7 23       	jnz	$-48     	;abs 0xce1a
      {
        memcpy(val, nwk_getFWVersion(), SMPL_FWVERSION_SIZE);
    ce4c:	81 4d 00 00 	mov	r13,	0(r1)	;0x0000(r1)
    ce50:	b0 12 38 dc 	call	#0xdc38	
    ce54:	2d 41       	mov	@r1,	r13	
    ce56:	fd 4f 00 00 	mov.b	@r15+,	0(r13)	;0x0000(r13)
    ce5a:	1d 53       	inc	r13		
    ce5c:	fd 4f 00 00 	mov.b	@r15+,	0(r13)	;0x0000(r13)
    ce60:	1d 53       	inc	r13		
    ce62:	fd 4f 00 00 	mov.b	@r15+,	0(r13)	;0x0000(r13)
    ce66:	ed 4f 01 00 	mov.b	@r15,	1(r13)	;0x0001(r13)
        rc = SMPL_SUCCESS;
    ce6a:	0f 43       	clr	r15		
    ce6c:	d7 3f       	jmp	$-80     	;abs 0xce1c
      rc = nwk_NVObj(action, (ioctlNVObj_t *)val);
      break;
#endif  /* EXTENDED_API */

    case IOCTL_OBJ_CONNOBJ:
      rc = nwk_connectionControl(action, val);
    ce6e:	0e 4d       	mov	r13,	r14	
    ce70:	0f 4c       	mov	r12,	r15	
    ce72:	b0 12 e0 db 	call	#0xdbe0	
      break;
    ce76:	d2 3f       	jmp	$-90     	;abs 0xce1c

    case IOCTL_OBJ_ADDR:
      if ((IOCTL_ACT_GET == action) || (IOCTL_ACT_SET == action))
    ce78:	2c 93       	cmp	#2,	r12	;r3 As==10
    ce7a:	cf 2f       	jc	$-96     	;abs 0xce1a
      {
        rc = nwk_deviceAddress(action, (addr_t *)val);
    ce7c:	0e 4d       	mov	r13,	r14	
    ce7e:	0f 4c       	mov	r12,	r15	
    ce80:	b0 12 a0 db 	call	#0xdba0	
    ce84:	cb 3f       	jmp	$-104    	;abs 0xce1c
        rc = SMPL_BAD_PARAM;
      }
      break;

    case IOCTL_OBJ_RADIO:
      rc = nwk_radioControl(action, val);
    ce86:	0e 4d       	mov	r13,	r14	
    ce88:	0f 4c       	mov	r12,	r15	
    ce8a:	b0 12 1a db 	call	#0xdb1a	
      break;
    ce8e:	c6 3f       	jmp	$-114    	;abs 0xce1c
        rc = SMPL_BAD_PARAM;
      }
      break;

    case IOCTL_OBJ_RAW_IO:
      if (IOCTL_ACT_WRITE == action)
    ce90:	3c 90 03 00 	cmp	#3,	r12	;#0x0003
    ce94:	06 24       	jz	$+14     	;abs 0xcea2
      {
        rc = nwk_rawSend((ioctlRawSend_t *)val);
      }
      else if (IOCTL_ACT_READ == action)
    ce96:	2c 93       	cmp	#2,	r12	;r3 As==10
    ce98:	c0 23       	jnz	$-126    	;abs 0xce1a
      {
        rc = nwk_rawReceive((ioctlRawReceive_t *)val);
    ce9a:	0f 4d       	mov	r13,	r15	
    ce9c:	b0 12 ee da 	call	#0xdaee	
    cea0:	bd 3f       	jmp	$-132    	;abs 0xce1c
      break;

    case IOCTL_OBJ_RAW_IO:
      if (IOCTL_ACT_WRITE == action)
      {
        rc = nwk_rawSend((ioctlRawSend_t *)val);
    cea2:	0f 4d       	mov	r13,	r15	
    cea4:	b0 12 9c da 	call	#0xda9c	
    cea8:	b9 3f       	jmp	$-140    	;abs 0xce1c

0000ceaa <nwk_nwkInit>:
 * output parameters
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_nwkInit(uint8_t (*f)(linkID_t))
{
    ceaa:	0b 12       	push	r11		
    ceac:	0b 4f       	mov	r15,	r11	
  /* Truly ugly initialization because CCE won't initialize properly. Must
   * skip first const element. Yuk.
   */
  memset((((uint8_t *)&sPersistInfo)+1), 0x0, (sizeof(sPersistInfo)-1));
    ceae:	3d 40 29 00 	mov	#41,	r13	;#0x0029
    ceb2:	0e 43       	clr	r14		
    ceb4:	3f 40 05 02 	mov	#517,	r15	;#0x0205
    ceb8:	b0 12 ee e2 	call	#0xe2ee	
  /* OK. The zeroed elements are set. Now go back and do fixups...  */

  sPersistInfo.numConnections   = SYS_NUM_CONNECTIONS;
    cebc:	f2 40 03 00 	mov.b	#3,	&0x0205	;#0x0003
    cec0:	05 02 
  sPersistInfo.curNextLinkPort  = SMPL_PORT_USER_MAX;
    cec2:	f2 40 3d 00 	mov.b	#61,	&0x0206	;#0x003d
    cec6:	06 02 
  sPersistInfo.curMaxReplyPort  = PORT_BASE_NUMBER;
    cec8:	f2 40 20 00 	mov.b	#32,	&0x0207	;#0x0020
    cecc:	07 02 
  sPersistInfo.nextLinkID       = 1;
    cece:	d2 43 08 02 	mov.b	#1,	&0x0208	;r3 As==01

  /* initialize globals */
  nwk_globalsInit();
    ced2:	b0 12 06 dc 	call	#0xdc06	

  /* initialize frame processing */
  nwk_frameInit(f);
    ced6:	0f 4b       	mov	r11,	r15	
    ced8:	b0 12 4e d4 	call	#0xd44e	

  /* initialize queue manager */
  nwk_QInit();
    cedc:	b0 12 a0 de 	call	#0xdea0	
	
  /* initialize each network application. */
  nwk_freqInit();
    cee0:	b0 12 ac dc 	call	#0xdcac	
  nwk_pingInit();
    cee4:	b0 12 b2 dc 	call	#0xdcb2	
  nwk_joinInit(f);
    cee8:	0f 4b       	mov	r11,	r15	
    ceea:	b0 12 f4 d2 	call	#0xd2f4	
  nwk_mgmtInit();
    ceee:	b0 12 ec dd 	call	#0xddec	
  nwk_linkInit();
    cef2:	b0 12 b6 d6 	call	#0xd6b6	
  nwk_securityInit();
    cef6:	b0 12 9a de 	call	#0xde9a	

  /* set up the last connection as the broadcast port mapped to the broadcast Link ID */
  if (CONNSTATE_FREE == sPersistInfo.connStruct[NUM_CONNECTIONS].connState)
    cefa:	5f 42 22 02 	mov.b	&0x0222,r15	
    cefe:	4f 93       	tst.b	r15		
    cf00:	17 20       	jnz	$+48     	;abs 0xcf30
  {
    sPersistInfo.connStruct[NUM_CONNECTIONS].connState   = CONNSTATE_CONNECTED;
    cf02:	e2 43 22 02 	mov.b	#2,	&0x0222	;r3 As==10
    sPersistInfo.connStruct[NUM_CONNECTIONS].hops2target = MAX_HOPS;
    cf06:	f2 40 03 00 	mov.b	#3,	&0x0223	;#0x0003
    cf0a:	23 02 
    sPersistInfo.connStruct[NUM_CONNECTIONS].portRx      = SMPL_PORT_USER_BCAST;
    cf0c:	f2 40 3f 00 	mov.b	#63,	&0x022a	;#0x003f
    cf10:	2a 02 
    sPersistInfo.connStruct[NUM_CONNECTIONS].portTx      = SMPL_PORT_USER_BCAST;
    cf12:	f2 40 3f 00 	mov.b	#63,	&0x022b	;#0x003f
    cf16:	2b 02 
    sPersistInfo.connStruct[NUM_CONNECTIONS].thisLinkID  = SMPL_LINKID_USER_UUD;
    cf18:	f2 43 2c 02 	mov.b	#-1,	&0x022c	;r3 As==11
    /* set peer address to broadcast so it is used when Application sends to the broadcast Link ID */
    memcpy(sPersistInfo.connStruct[NUM_CONNECTIONS].peerAddr, nwk_getBCastAddress(), NET_ADDR_SIZE);
    cf1c:	b0 12 a6 dc 	call	#0xdca6	
    cf20:	f2 4f 24 02 	mov.b	@r15+,	&0x0224	
    cf24:	f2 4f 25 02 	mov.b	@r15+,	&0x0225	
    cf28:	f2 4f 26 02 	mov.b	@r15+,	&0x0226	
    cf2c:	e2 4f 27 02 	mov.b	@r15,	&0x0227	
  }

  return SMPL_SUCCESS;
}
    cf30:	0f 43       	clr	r15		
    cf32:	3b 41       	pop	r11		
    cf34:	30 41       	ret			

0000cf36 <nwk_getNextConnection>:
{
  uint8_t  i;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i)
  {
    if (sPersistInfo.connStruct[i].connState == CONNSTATE_CONNECTED)
    cf36:	5f 42 0a 02 	mov.b	&0x020a,r15	
    cf3a:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    cf3c:	2c 24       	jz	$+90     	;abs 0xcf96
    cf3e:	0e 43       	clr	r14		
  if (SYS_NUM_CONNECTIONS == i)
  {
    return (connInfo_t *)0;
  }

  initializeConnection(&sPersistInfo.connStruct[i]);
    cf40:	0f 4e       	mov	r14,	r15	
    cf42:	0f 5f       	rla	r15		
    cf44:	0f 5e       	add	r14,	r15	
    cf46:	0f 5f       	rla	r15		
    cf48:	0f 5f       	rla	r15		
    cf4a:	3f 50 06 00 	add	#6,	r15	;#0x0006
    cf4e:	3f 50 04 02 	add	#516,	r15	;#0x0204
{
  linkID_t *locLID = &sPersistInfo.nextLinkID;
  uint8_t   tmp;

    /* this element will be populated during the exchange with the peer. */
  pCInfo->portTx = 0;
    cf52:	cf 43 09 00 	mov.b	#0,	9(r15)	;r3 As==00, 0x0009(r15)

  pCInfo->connState  =  CONNSTATE_CONNECTED;
    cf56:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
  pCInfo->thisLinkID = *locLID;
    cf5a:	5d 42 08 02 	mov.b	&0x0208,r13	
    cf5e:	cf 4d 0a 00 	mov.b	r13,	10(r15)	;0x000a(r15)
   * we can end up with confusing duplicates. We can protect aginst using
   * one that is already in use but we can't protect against a stale Link ID
   * remembered by an application that doesn't know its connection has been
   * torn down. The test for 0 will hopefully never be true (indicating a wrap).
   */
  (*locLID)++;
    cf62:	5d 53       	inc.b	r13		
    cf64:	c2 4d 08 02 	mov.b	r13,	&0x0208	

  while (!*locLID || (*locLID == SMPL_LINKID_USER_UUD) || map_lid2idx(*locLID, &tmp))
    cf68:	4e 4d       	mov.b	r13,	r14	
    cf6a:	7e 53       	add.b	#-1,	r14	;r3 As==11
    cf6c:	7e 90 fe ff 	cmp.b	#-2,	r14	;#0xfffe
    cf70:	0e 2c       	jc	$+30     	;abs 0xcf8e
 * @return   Non-zero if Link ID found and output is valid else 0.
 */
static uint8_t map_lid2idx(linkID_t lid, uint8_t *idx)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;
    cf72:	3e 40 0a 02 	mov	#522,	r14	;#0x020a

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
  {
    if ((CONNSTATE_CONNECTED == ptr->connState) && (ptr->thisLinkID == lid))
    cf76:	6c 4e       	mov.b	@r14,	r12	
    cf78:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    cf7a:	06 24       	jz	$+14     	;abs 0xcf88
static uint8_t map_lid2idx(linkID_t lid, uint8_t *idx)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
    cf7c:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    cf80:	3e 90 2e 02 	cmp	#558,	r14	;#0x022e
    cf84:	f8 23       	jnz	$-14     	;abs 0xcf76
    cf86:	30 41       	ret			
  {
    if ((CONNSTATE_CONNECTED == ptr->connState) && (ptr->thisLinkID == lid))
    cf88:	ce 9d 0a 00 	cmp.b	r13,	10(r14)	;0x000a(r14)
    cf8c:	f7 23       	jnz	$-16     	;abs 0xcf7c
   */
  (*locLID)++;

  while (!*locLID || (*locLID == SMPL_LINKID_USER_UUD) || map_lid2idx(*locLID, &tmp))
  {
    (*locLID)++;
    cf8e:	5d 53       	inc.b	r13		
    cf90:	c2 4d 08 02 	mov.b	r13,	&0x0208	
    cf94:	e9 3f       	jmp	$-44     	;abs 0xcf68
{
  uint8_t  i;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i)
  {
    if (sPersistInfo.connStruct[i].connState == CONNSTATE_CONNECTED)
    cf96:	5f 42 16 02 	mov.b	&0x0216,r15	
    cf9a:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    cf9c:	02 24       	jz	$+6      	;abs 0xcfa2
    cf9e:	1e 43       	mov	#1,	r14	;r3 As==01
    cfa0:	cf 3f       	jmp	$-96     	;abs 0xcf40
    cfa2:	5f 42 22 02 	mov.b	&0x0222,r15	
    cfa6:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    cfa8:	02 24       	jz	$+6      	;abs 0xcfae
    cfaa:	2e 43       	mov	#2,	r14	;r3 As==10
    cfac:	c9 3f       	jmp	$-108    	;abs 0xcf40
    break;
  }

  if (SYS_NUM_CONNECTIONS == i)
  {
    return (connInfo_t *)0;
    cfae:	0f 43       	clr	r15		
  }

  initializeConnection(&sPersistInfo.connStruct[i]);

  return &sPersistInfo.connStruct[i];
}
    cfb0:	30 41       	ret			

0000cfb2 <nwk_freeConnection>:
 * @return   None.
 */
void nwk_freeConnection(connInfo_t *pCInfo)
{
#if NUM_CONNECTIONS > 0
  pCInfo->connState = CONNSTATE_FREE;
    cfb2:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
#endif
}
    cfb6:	30 41       	ret			

0000cfb8 <nwk_getConnInfo>:
static uint8_t map_lid2idx(linkID_t lid, uint8_t *idx)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
    cfb8:	4d 43       	clr.b	r13		
 * @return   Non-zero if Link ID found and output is valid else 0.
 */
static uint8_t map_lid2idx(linkID_t lid, uint8_t *idx)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;
    cfba:	3e 40 0a 02 	mov	#522,	r14	;#0x020a

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
  {
    if ((CONNSTATE_CONNECTED == ptr->connState) && (ptr->thisLinkID == lid))
    cfbe:	6c 4e       	mov.b	@r14,	r12	
    cfc0:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    cfc2:	08 24       	jz	$+18     	;abs 0xcfd4
static uint8_t map_lid2idx(linkID_t lid, uint8_t *idx)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
    cfc4:	5d 53       	inc.b	r13		
    cfc6:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    cfca:	7d 90 03 00 	cmp.b	#3,	r13	;#0x0003
    cfce:	f7 23       	jnz	$-16     	;abs 0xcfbe
{
  uint8_t idx, rc;

  rc = map_lid2idx(linkID, &idx);

  return (rc && (CONNSTATE_CONNECTED == sPersistInfo.connStruct[idx].connState)) ? &sPersistInfo.connStruct[idx] : (connInfo_t *)0;
    cfd0:	0f 43       	clr	r15		
    cfd2:	30 41       	ret			
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
  {
    if ((CONNSTATE_CONNECTED == ptr->connState) && (ptr->thisLinkID == lid))
    cfd4:	5f 9e 0a 00 	cmp.b	10(r14),r15	;0x000a(r14)
    cfd8:	f5 23       	jnz	$-20     	;abs 0xcfc4
{
  uint8_t idx, rc;

  rc = map_lid2idx(linkID, &idx);

  return (rc && (CONNSTATE_CONNECTED == sPersistInfo.connStruct[idx].connState)) ? &sPersistInfo.connStruct[idx] : (connInfo_t *)0;
    cfda:	4d 4d       	mov.b	r13,	r13	
    cfdc:	0f 4d       	mov	r13,	r15	
    cfde:	0f 5f       	rla	r15		
    cfe0:	0f 5d       	add	r13,	r15	
    cfe2:	0e 4f       	mov	r15,	r14	
    cfe4:	0e 5e       	rla	r14		
    cfe6:	0e 5e       	rla	r14		
    cfe8:	3e 50 0a 02 	add	#522,	r14	;#0x020a
    cfec:	6e 4e       	mov.b	@r14,	r14	
    cfee:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    cff0:	07 20       	jnz	$+16     	;abs 0xd000
    cff2:	0f 5f       	rla	r15		
    cff4:	0f 5f       	rla	r15		
    cff6:	3f 50 06 00 	add	#6,	r15	;#0x0006
    cffa:	3f 50 04 02 	add	#516,	r15	;#0x0204
    cffe:	30 41       	ret			
    d000:	0f 43       	clr	r15		
}
    d002:	30 41       	ret			

0000d004 <nwk_isLinkDuplicate>:
 *
 * @return   Returns pointer to connection entry if the address and remote Port
 *           match an existing entry, otherwise 0.
 */
connInfo_t *nwk_isLinkDuplicate(uint8_t *addr, uint8_t remotePort)
{
    d004:	0b 12       	push	r11		
    d006:	0a 12       	push	r10		
    d008:	09 12       	push	r9		
    d00a:	0a 4f       	mov	r15,	r10	
    d00c:	49 4e       	mov.b	r14,	r9	
#if NUM_CONNECTIONS > 0
  uint8_t       i;
  connInfo_t   *ptr = sPersistInfo.connStruct;
    d00e:	3b 40 0a 02 	mov	#522,	r11	;#0x020a

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    d012:	6d 4b       	mov.b	@r11,	r13	
    d014:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    d016:	0b 24       	jz	$+24     	;abs 0xd02e
{
#if NUM_CONNECTIONS > 0
  uint8_t       i;
  connInfo_t   *ptr = sPersistInfo.connStruct;

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
    d018:	3b 50 0c 00 	add	#12,	r11	;#0x000c
    d01c:	3b 90 22 02 	cmp	#546,	r11	;#0x0222
    d020:	f8 23       	jnz	$-14     	;abs 0xd012
      }
    }
  }
#endif

  return (connInfo_t *)NULL;
    d022:	0b 43       	clr	r11		
}
    d024:	0f 4b       	mov	r11,	r15	
    d026:	39 41       	pop	r9		
    d028:	3a 41       	pop	r10		
    d02a:	3b 41       	pop	r11		
    d02c:	30 41       	ret			

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    {
      if (!(memcmp(ptr->peerAddr, addr, NET_ADDR_SIZE)) &&
    d02e:	2d 42       	mov	#4,	r13	;r2 As==10
    d030:	0e 4a       	mov	r10,	r14	
    d032:	0f 4b       	mov	r11,	r15	
    d034:	2f 53       	incd	r15		
    d036:	b0 12 da e0 	call	#0xe0da	
    d03a:	0f 93       	tst	r15		
    d03c:	ed 23       	jnz	$-36     	;abs 0xd018
    d03e:	cb 99 09 00 	cmp.b	r9,	9(r11)	;0x0009(r11)
    d042:	ea 23       	jnz	$-42     	;abs 0xd018
    d044:	ef 3f       	jmp	$-32     	;abs 0xd024

0000d046 <nwk_findAddressMatch>:
 * output parameters
 *
 * @return   Returns non-zero if a match is found, otherwise 0.
 */
uint8_t nwk_findAddressMatch(mrfiPacket_t *frame)
{
    d046:	0b 12       	push	r11		
    d048:	0b 4f       	mov	r15,	r11	
  connInfo_t   *ptr = sPersistInfo.connStruct;

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {

    if (CONNSTATE_CONNECTED == ptr->connState)
    d04a:	5f 42 0a 02 	mov.b	&0x020a,r15	
    d04e:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    d050:	13 24       	jz	$+40     	;abs 0xd078
    d052:	5f 42 16 02 	mov.b	&0x0216,r15	
    d056:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    d058:	03 24       	jz	$+8      	;abs 0xd060
      }
    }
  }
#endif

  return 0;
    d05a:	4f 43       	clr.b	r15		
}
    d05c:	3b 41       	pop	r11		
    d05e:	30 41       	ret			
  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {

    if (CONNSTATE_CONNECTED == ptr->connState)
    {
      if (!(memcmp(ptr->peerAddr, MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE)))
    d060:	2d 42       	mov	#4,	r13	;r2 As==10
    d062:	0e 4b       	mov	r11,	r14	
    d064:	3e 50 05 00 	add	#5,	r14	;#0x0005
    d068:	3f 40 18 02 	mov	#536,	r15	;#0x0218
    d06c:	b0 12 da e0 	call	#0xe0da	
    d070:	0f 93       	tst	r15		
    d072:	f3 23       	jnz	$-24     	;abs 0xd05a
      {
        return 1;
    d074:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d076:	f2 3f       	jmp	$-26     	;abs 0xd05c
  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {

    if (CONNSTATE_CONNECTED == ptr->connState)
    {
      if (!(memcmp(ptr->peerAddr, MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE)))
    d078:	2d 42       	mov	#4,	r13	;r2 As==10
    d07a:	0e 4b       	mov	r11,	r14	
    d07c:	3e 50 05 00 	add	#5,	r14	;#0x0005
    d080:	3f 40 0c 02 	mov	#524,	r15	;#0x020c
    d084:	b0 12 da e0 	call	#0xe0da	
    d088:	0f 93       	tst	r15		
    d08a:	e3 23       	jnz	$-56     	;abs 0xd052
      {
        return 1;
    d08c:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d08e:	e6 3f       	jmp	$-50     	;abs 0xd05c

0000d090 <nwk_checkConnInfo>:
smplStatus_t nwk_checkConnInfo(connInfo_t *ptr, uint8_t which)
{
  uint8_t  port;

  /* make sure port isn't null and that the entry is active */
  port = (CHK_RX == which) ? ptr->portRx : ptr->portTx;
    d090:	4e 93       	tst.b	r14		
    d092:	06 20       	jnz	$+14     	;abs 0xd0a0
    d094:	5e 4f 08 00 	mov.b	8(r15),	r14	;0x0008(r15)
  if (!port || (CONNSTATE_FREE == ptr->connState))
    d098:	4e 93       	tst.b	r14		
    d09a:	06 20       	jnz	$+14     	;abs 0xd0a8
  {
    return SMPL_BAD_PARAM;
    d09c:	2f 43       	mov	#2,	r15	;r3 As==10
    d09e:	30 41       	ret			
smplStatus_t nwk_checkConnInfo(connInfo_t *ptr, uint8_t which)
{
  uint8_t  port;

  /* make sure port isn't null and that the entry is active */
  port = (CHK_RX == which) ? ptr->portRx : ptr->portTx;
    d0a0:	5e 4f 09 00 	mov.b	9(r15),	r14	;0x0009(r15)
  if (!port || (CONNSTATE_FREE == ptr->connState))
    d0a4:	4e 93       	tst.b	r14		
    d0a6:	fa 27       	jz	$-10     	;abs 0xd09c
    d0a8:	6f 4f       	mov.b	@r15,	r15	
    d0aa:	4f 93       	tst.b	r15		
    d0ac:	f7 27       	jz	$-16     	;abs 0xd09c
  {
    return SMPL_BAD_PARAM;
  }

  /* validate port number */
  if (port < PORT_BASE_NUMBER)
    d0ae:	7e 90 20 00 	cmp.b	#32,	r14	;#0x0020
    d0b2:	f4 2b       	jnc	$-22     	;abs 0xd09c
  {
    return SMPL_BAD_PARAM;
  }

  return SMPL_SUCCESS;
    d0b4:	0f 43       	clr	r15		
}
    d0b6:	30 41       	ret			

0000d0b8 <nwk_isConnectionValid>:
 * @param   lid   - link ID of found connection
 *
 * @return   0 if connection specified in frame is not valid, otherwise non-zero.
 */
uint8_t nwk_isConnectionValid(mrfiPacket_t *frame, linkID_t *lid)
{
    d0b8:	0b 12       	push	r11		
    d0ba:	0a 12       	push	r10		
    d0bc:	09 12       	push	r9		
    d0be:	08 12       	push	r8		
    d0c0:	0a 4e       	mov	r14,	r10	
  uint8_t       i;
  connInfo_t   *ptr  = sPersistInfo.connStruct;
  uint8_t       port = GET_FROM_FRAME(MRFI_P_PAYLOAD(frame), F_PORT_OS);
    d0c2:	59 4f 09 00 	mov.b	9(r15),	r9	;0x0009(r15)
    d0c6:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f
 * @return   0 if connection specified in frame is not valid, otherwise non-zero.
 */
uint8_t nwk_isConnectionValid(mrfiPacket_t *frame, linkID_t *lid)
{
  uint8_t       i;
  connInfo_t   *ptr  = sPersistInfo.connStruct;
    d0ca:	3b 40 0a 02 	mov	#522,	r11	;#0x020a
    {
      /* check port first since we're done if the port is the user bcast port. */
      if (port == ptr->portRx)
      {
        /* yep...ports match. */
        if ((SMPL_PORT_USER_BCAST == port) || !(memcmp(ptr->peerAddr, MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE)))
    d0ce:	08 4f       	mov	r15,	r8	
    d0d0:	38 50 05 00 	add	#5,	r8	;#0x0005
  connInfo_t   *ptr  = sPersistInfo.connStruct;
  uint8_t       port = GET_FROM_FRAME(MRFI_P_PAYLOAD(frame), F_PORT_OS);

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i,++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    d0d4:	6d 4b       	mov.b	@r11,	r13	
    d0d6:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    d0d8:	0b 24       	jz	$+24     	;abs 0xd0f0
{
  uint8_t       i;
  connInfo_t   *ptr  = sPersistInfo.connStruct;
  uint8_t       port = GET_FROM_FRAME(MRFI_P_PAYLOAD(frame), F_PORT_OS);

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i,++ptr)
    d0da:	3b 50 0c 00 	add	#12,	r11	;#0x000c
    d0de:	3b 90 2e 02 	cmp	#558,	r11	;#0x022e
    d0e2:	f8 23       	jnz	$-14     	;abs 0xd0d4
      }
    }
  }

  /* no matches */
  return 0;
    d0e4:	4f 43       	clr.b	r15		
}
    d0e6:	38 41       	pop	r8		
    d0e8:	39 41       	pop	r9		
    d0ea:	3a 41       	pop	r10		
    d0ec:	3b 41       	pop	r11		
    d0ee:	30 41       	ret			
  for (i=0; i<SYS_NUM_CONNECTIONS; ++i,++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    {
      /* check port first since we're done if the port is the user bcast port. */
      if (port == ptr->portRx)
    d0f0:	cb 99 08 00 	cmp.b	r9,	8(r11)	;0x0008(r11)
    d0f4:	f2 23       	jnz	$-26     	;abs 0xd0da
      {
        /* yep...ports match. */
        if ((SMPL_PORT_USER_BCAST == port) || !(memcmp(ptr->peerAddr, MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE)))
    d0f6:	79 90 3f 00 	cmp.b	#63,	r9	;#0x003f
    d0fa:	08 24       	jz	$+18     	;abs 0xd10c
    d0fc:	2d 42       	mov	#4,	r13	;r2 As==10
    d0fe:	0e 48       	mov	r8,	r14	
    d100:	0f 4b       	mov	r11,	r15	
    d102:	2f 53       	incd	r15		
    d104:	b0 12 da e0 	call	#0xe0da	
    d108:	0f 93       	tst	r15		
    d10a:	e7 23       	jnz	$-48     	;abs 0xd0da
        {
          uint8_t rc = 1;

          /* we're done. */
          *lid = ptr->thisLinkID;
    d10c:	da 4b 0a 00 	mov.b	10(r11),0(r10)	;0x000a(r11), 0x0000(r10)
    d110:	00 00 
          }
#endif  /* APP_AUTO_ACK */
          /* Unconditionally kill the reply delay semaphore. This used to be done
           * unconditionally in the calling routine.
           */
          MRFI_PostKillSem();
    d112:	b0 12 dc c3 	call	#0xc3dc	
          return rc;
    d116:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d118:	e6 3f       	jmp	$-50     	;abs 0xd0e6

0000d11a <nwk_allocateLocalRxPort>:
 * @param   newPtr->portRx  - element is populated with port number.
 *
 * @return   Non-zero if port number assigned. 0 if no port available.
 */
uint8_t nwk_allocateLocalRxPort(uint8_t which, connInfo_t *newPtr)
{
    d11a:	0b 12       	push	r11		
    d11c:	0a 12       	push	r10		
    d11e:	09 12       	push	r9		
    d120:	08 12       	push	r8		
    d122:	07 12       	push	r7		
    d124:	21 83       	decd	r1		
    d126:	49 4f       	mov.b	r15,	r9	
    d128:	0a 4e       	mov	r14,	r10	
#if NUM_CONNECTIONS > 0
  uint8_t     num, i;
  uint8_t     marker[NUM_CONNECTIONS];
  connInfo_t *ptr = sPersistInfo.connStruct;

  memset(&marker, 0x0, sizeof(marker));
    d12a:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00, 0x0000(r1)
uint8_t nwk_allocateLocalRxPort(uint8_t which, connInfo_t *newPtr)
{
#if NUM_CONNECTIONS > 0
  uint8_t     num, i;
  uint8_t     marker[NUM_CONNECTIONS];
  connInfo_t *ptr = sPersistInfo.connStruct;
    d12e:	3b 40 0a 02 	mov	#522,	r11	;#0x020a
        if (ptr->portRx > sPersistInfo.curNextLinkPort)
        {
          marker[SMPL_PORT_USER_MAX - ptr->portRx] = 1;
        }
      }
      else if (!memcmp(ptr->peerAddr, newPtr->peerAddr, NET_ADDR_SIZE))
    d132:	07 4e       	mov	r14,	r7	
    d134:	27 53       	incd	r7		
  memset(&marker, 0x0, sizeof(marker));

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {
    /* Mark the port number as used unless it's a statically allocated port */
    if ((ptr != newPtr) && (CONNSTATE_CONNECTED == ptr->connState) && (ptr->portRx <= SMPL_PORT_USER_MAX))
    d136:	0b 9a       	cmp	r10,	r11	
    d138:	03 24       	jz	$+8      	;abs 0xd140
    d13a:	6f 4b       	mov.b	@r11,	r15	
    d13c:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    d13e:	1f 24       	jz	$+64     	;abs 0xd17e
  uint8_t     marker[NUM_CONNECTIONS];
  connInfo_t *ptr = sPersistInfo.connStruct;

  memset(&marker, 0x0, sizeof(marker));

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
    d140:	3b 50 0c 00 	add	#12,	r11	;#0x000c
    d144:	3b 90 22 02 	cmp	#546,	r11	;#0x0222
    d148:	f6 23       	jnz	$-18     	;abs 0xd136
  }

  num = 0;
  for (i=0; i<NUM_CONNECTIONS; ++i)
  {
    if (!marker[i])
    d14a:	c1 93 00 00 	tst.b	0(r1)		;0x0000(r1)
    d14e:	3c 24       	jz	$+122    	;abs 0xd1c8
    d150:	c1 93 01 00 	tst.b	1(r1)		;0x0001(r1)
    d154:	40 24       	jz	$+130    	;abs 0xd1d6
          marker[ptr->portRx - PORT_BASE_NUMBER] = 1;
      }
    }
  }

  num = 0;
    d156:	4f 43       	clr.b	r15		
      }
      break;
    }
  }

  if (LINK_REPLY == which)
    d158:	69 93       	cmp.b	#2,	r9	;r3 As==10
    d15a:	06 24       	jz	$+14     	;abs 0xd168
  else
  {
    /* if the number we have doesn't overlap the assignment of ports used
     * for sending link frame replies, use it.
     */
    if (num >= sPersistInfo.curMaxReplyPort)
    d15c:	5f 92 07 02 	cmp.b	&0x0207,r15	
    d160:	0c 28       	jnc	$+26     	;abs 0xd17a
    {
      if (num == sPersistInfo.curNextLinkPort)
    d162:	c2 9f 06 02 	cmp.b	r15,	&0x0206	
    d166:	22 24       	jz	$+70     	;abs 0xd1ac
       */
      num = 0;
    }
  }

  newPtr->portRx = num;
    d168:	ca 4f 08 00 	mov.b	r15,	8(r10)	;0x0008(r10)
  return num;
#else
  return 0;
#endif  /* NUM_CONNECTIONS > 0 */

}
    d16c:	21 53       	incd	r1		
    d16e:	37 41       	pop	r7		
    d170:	38 41       	pop	r8		
    d172:	39 41       	pop	r9		
    d174:	3a 41       	pop	r10		
    d176:	3b 41       	pop	r11		
    d178:	30 41       	ret			
      /* the port number we need has already been used in the other context. It may or
       * may not have been used for the same address but we don't bother to check...we
       * just reject the asignment. This is the overly cautious part but is extermely
       * unlikely to ever occur.
       */
      num = 0;
    d17a:	4f 43       	clr.b	r15		
    d17c:	f5 3f       	jmp	$-20     	;abs 0xd168
  memset(&marker, 0x0, sizeof(marker));

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {
    /* Mark the port number as used unless it's a statically allocated port */
    if ((ptr != newPtr) && (CONNSTATE_CONNECTED == ptr->connState) && (ptr->portRx <= SMPL_PORT_USER_MAX))
    d17e:	58 4b 08 00 	mov.b	8(r11),	r8	;0x0008(r11)
    d182:	78 90 3e 00 	cmp.b	#62,	r8	;#0x003e
    d186:	dc 2f       	jc	$-70     	;abs 0xd140
    {
      if (LINK_SEND == which)
    d188:	59 93       	cmp.b	#1,	r9	;r3 As==01
    d18a:	15 24       	jz	$+44     	;abs 0xd1b6
        if (ptr->portRx > sPersistInfo.curNextLinkPort)
        {
          marker[SMPL_PORT_USER_MAX - ptr->portRx] = 1;
        }
      }
      else if (!memcmp(ptr->peerAddr, newPtr->peerAddr, NET_ADDR_SIZE))
    d18c:	2d 42       	mov	#4,	r13	;r2 As==10
    d18e:	0e 47       	mov	r7,	r14	
    d190:	0f 4b       	mov	r11,	r15	
    d192:	2f 53       	incd	r15		
    d194:	b0 12 da e0 	call	#0xe0da	
    d198:	0f 93       	tst	r15		
    d19a:	d2 23       	jnz	$-90     	;abs 0xd140
      {
          marker[ptr->portRx - PORT_BASE_NUMBER] = 1;
    d19c:	48 48       	mov.b	r8,	r8	
    d19e:	3e 40 e0 ff 	mov	#-32,	r14	;#0xffe0
    d1a2:	0e 51       	add	r1,	r14	
    d1a4:	08 5e       	add	r14,	r8	
    d1a6:	d8 43 00 00 	mov.b	#1,	0(r8)	;r3 As==01, 0x0000(r8)
    d1aa:	ca 3f       	jmp	$-106    	;abs 0xd140
     */
    if (num >= sPersistInfo.curMaxReplyPort)
    {
      if (num == sPersistInfo.curNextLinkPort)
      {
        sPersistInfo.curNextLinkPort--;
    d1ac:	4e 4f       	mov.b	r15,	r14	
    d1ae:	7e 53       	add.b	#-1,	r14	;r3 As==11
    d1b0:	c2 4e 06 02 	mov.b	r14,	&0x0206	
    d1b4:	d9 3f       	jmp	$-76     	;abs 0xd168
    /* Mark the port number as used unless it's a statically allocated port */
    if ((ptr != newPtr) && (CONNSTATE_CONNECTED == ptr->connState) && (ptr->portRx <= SMPL_PORT_USER_MAX))
    {
      if (LINK_SEND == which)
      {
        if (ptr->portRx > sPersistInfo.curNextLinkPort)
    d1b6:	c2 98 06 02 	cmp.b	r8,	&0x0206	
    d1ba:	c2 2f       	jc	$-122    	;abs 0xd140
        {
          marker[SMPL_PORT_USER_MAX - ptr->portRx] = 1;
    d1bc:	48 48       	mov.b	r8,	r8	
    d1be:	0f 41       	mov	r1,	r15	
    d1c0:	0f 88       	sub	r8,	r15	
    d1c2:	df 43 3d 00 	mov.b	#1,	61(r15)	;r3 As==01, 0x003d(r15)
    d1c6:	bc 3f       	jmp	$-134    	;abs 0xd140
  }

  num = 0;
  for (i=0; i<NUM_CONNECTIONS; ++i)
  {
    if (!marker[i])
    d1c8:	4e 43       	clr.b	r14		
    {
      if (LINK_REPLY == which)
    d1ca:	69 93       	cmp.b	#2,	r9	;r3 As==10
    d1cc:	06 24       	jz	$+14     	;abs 0xd1da
      {
        num = PORT_BASE_NUMBER + i;
      }
      else
      {
        num = SMPL_PORT_USER_MAX - i;
    d1ce:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    d1d2:	4f 8e       	sub.b	r14,	r15	
    d1d4:	c3 3f       	jmp	$-120    	;abs 0xd15c
      }
    }
  }

  num = 0;
  for (i=0; i<NUM_CONNECTIONS; ++i)
    d1d6:	5e 43       	mov.b	#1,	r14	;r3 As==01
    d1d8:	f8 3f       	jmp	$-14     	;abs 0xd1ca
  {
    if (!marker[i])
    {
      if (LINK_REPLY == which)
      {
        num = PORT_BASE_NUMBER + i;
    d1da:	4f 4e       	mov.b	r14,	r15	
    d1dc:	7f 50 20 00 	add.b	#32,	r15	;#0x0020
  if (LINK_REPLY == which)
  {
    /* if the number we have doesn't overlap the assignment of ports used
     * for sending link frames, use it.
     */
    if (num <= sPersistInfo.curNextLinkPort)
    d1e0:	c2 9f 06 02 	cmp.b	r15,	&0x0206	
    d1e4:	ca 2b       	jnc	$-106    	;abs 0xd17a
    {
      if (num > sPersistInfo.curMaxReplyPort)
    d1e6:	c2 9f 07 02 	cmp.b	r15,	&0x0207	
    d1ea:	be 2f       	jc	$-130    	;abs 0xd168
      {
        /* remember maximum port number used */
        sPersistInfo.curMaxReplyPort = num;
    d1ec:	c2 4f 07 02 	mov.b	r15,	&0x0207	
    d1f0:	bb 3f       	jmp	$-136    	;abs 0xd168

0000d1f2 <nwk_isValidReply>:
 *               SMPL_NOT_REPLY: not a reply
 *               SMPL_MY_REPLY : a reply that matches input parameters
 *               SMPL_A_REPLY  : a reply but does not match input parameters
 */
uint8_t nwk_isValidReply(mrfiPacket_t *frame, uint8_t tid, uint8_t infoOffset, uint8_t tidOffset)
{
    d1f2:	0b 12       	push	r11		
    d1f4:	0b 4f       	mov	r15,	r11	
  uint8_t rc = SMPL_NOT_REPLY;

  if ((*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+infoOffset) & NWK_APP_REPLY_BIT))
    d1f6:	4d 4d       	mov.b	r13,	r13	
    d1f8:	0d 5f       	add	r15,	r13	
    d1fa:	cd 93 0c 00 	tst.b	12(r13)	;0x000c(r13)
    d1fe:	04 38       	jl	$+10     	;abs 0xd208
 *               SMPL_MY_REPLY : a reply that matches input parameters
 *               SMPL_A_REPLY  : a reply but does not match input parameters
 */
uint8_t nwk_isValidReply(mrfiPacket_t *frame, uint8_t tid, uint8_t infoOffset, uint8_t tidOffset)
{
  uint8_t rc = SMPL_NOT_REPLY;
    d200:	6e 43       	mov.b	#2,	r14	;r3 As==10
      rc = SMPL_A_REPLY;
    }
  }

  return rc;
}
    d202:	4f 4e       	mov.b	r14,	r15	
    d204:	3b 41       	pop	r11		
    d206:	30 41       	ret			
{
  uint8_t rc = SMPL_NOT_REPLY;

  if ((*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+infoOffset) & NWK_APP_REPLY_BIT))
  {
    if ((*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+tidOffset) == tid) &&
    d208:	4c 4c       	mov.b	r12,	r12	
    d20a:	0c 5f       	add	r15,	r12	
    d20c:	5e 9c 0c 00 	cmp.b	12(r12),r14	;0x000c(r12)
    d210:	04 24       	jz	$+10     	;abs 0xd21a
    {
      rc = SMPL_MY_REPLY;
    }
    else
    {
      rc = SMPL_A_REPLY;
    d212:	5e 43       	mov.b	#1,	r14	;r3 As==01
    }
  }

  return rc;
}
    d214:	4f 4e       	mov.b	r14,	r15	
    d216:	3b 41       	pop	r11		
    d218:	30 41       	ret			
  uint8_t rc = SMPL_NOT_REPLY;

  if ((*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+infoOffset) & NWK_APP_REPLY_BIT))
  {
    if ((*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+tidOffset) == tid) &&
        !memcmp(MRFI_P_DST_ADDR(frame), nwk_getMyAddress(), NET_ADDR_SIZE))
    d21a:	b0 12 26 dc 	call	#0xdc26	
    d21e:	2d 42       	mov	#4,	r13	;r2 As==10
    d220:	0e 4f       	mov	r15,	r14	
    d222:	0f 4b       	mov	r11,	r15	
    d224:	1f 53       	inc	r15		
    d226:	b0 12 da e0 	call	#0xe0da	
 * @return   reply category:
 *               SMPL_NOT_REPLY: not a reply
 *               SMPL_MY_REPLY : a reply that matches input parameters
 *               SMPL_A_REPLY  : a reply but does not match input parameters
 */
uint8_t nwk_isValidReply(mrfiPacket_t *frame, uint8_t tid, uint8_t infoOffset, uint8_t tidOffset)
    d22a:	5e 43       	mov.b	#1,	r14	;r3 As==01
    d22c:	0f 93       	tst	r15		
    d22e:	e9 23       	jnz	$-44     	;abs 0xd202
    d230:	4e 43       	clr.b	r14		
    d232:	e7 3f       	jmp	$-48     	;abs 0xd202

0000d234 <nwk_findPeer>:
 * output parameters
 *
 * @return   Pointer to matching connection table entry else 0.
 */
connInfo_t *nwk_findPeer(addr_t *peerAddr, uint8_t peerPort)
{
    d234:	0b 12       	push	r11		
    d236:	0a 12       	push	r10		
    d238:	09 12       	push	r9		
    d23a:	0a 4f       	mov	r15,	r10	
    d23c:	49 4e       	mov.b	r14,	r9	
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;
    d23e:	3b 40 0a 02 	mov	#522,	r11	;#0x020a

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    d242:	6d 4b       	mov.b	@r11,	r13	
    d244:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    d246:	0b 24       	jz	$+24     	;abs 0xd25e
connInfo_t *nwk_findPeer(addr_t *peerAddr, uint8_t peerPort)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
    d248:	3b 50 0c 00 	add	#12,	r11	;#0x000c
    d24c:	3b 90 2e 02 	cmp	#558,	r11	;#0x022e
    d250:	f8 23       	jnz	$-14     	;abs 0xd242
        }
      }
    }
  }

  return (connInfo_t *)NULL;
    d252:	0b 43       	clr	r11		
}
    d254:	0f 4b       	mov	r11,	r15	
    d256:	39 41       	pop	r9		
    d258:	3a 41       	pop	r10		
    d25a:	3b 41       	pop	r11		
    d25c:	30 41       	ret			

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    {
      if (!memcmp(peerAddr, ptr->peerAddr, NET_ADDR_SIZE))
    d25e:	2d 42       	mov	#4,	r13	;r2 As==10
    d260:	0e 4b       	mov	r11,	r14	
    d262:	2e 53       	incd	r14		
    d264:	0f 4a       	mov	r10,	r15	
    d266:	b0 12 da e0 	call	#0xe0da	
    d26a:	0f 93       	tst	r15		
    d26c:	ed 23       	jnz	$-36     	;abs 0xd248
      {
        if (peerPort == ptr->portTx)
    d26e:	cb 99 09 00 	cmp.b	r9,	9(r11)	;0x0009(r11)
    d272:	ea 23       	jnz	$-42     	;abs 0xd248
    d274:	ef 3f       	jmp	$-32     	;abs 0xd254

0000d276 <nwk_checkAppMsgTID>:
 *           processed. The last-seen TID should be updated with the current
 *           application payload TID.
 *
 */
uint8_t nwk_checkAppMsgTID(appPTid_t lastTID, appPTid_t appMsgTID)
{
    d276:	4d 4f       	mov.b	r15,	r13	
  uint8_t rc = 0;

  /* If the values are equal this is a duplicate. We're done. */
  if (lastTID != appMsgTID)
    d278:	4f 9e       	cmp.b	r14,	r15	
    d27a:	10 24       	jz	$+34     	;abs 0xd29c
  {
    /* Is the new TID bigger? */
    if (appMsgTID > lastTID)
    d27c:	08 2c       	jc	$+18     	;abs 0xd28e
       * (duplicate) message that occurred just before the TID wrapped. This is
       * considered a duplicate and we should discard it.
       */
      if (!(DUP_TID_AFTER_WRAP(lastTID, appMsgTID)))
      {
        rc = 1;
    d27e:	5f 43       	mov.b	#1,	r15	;r3 As==01
    {
      /* In this case the current payload is OK unless we've received a late
       * (duplicate) message that occurred just before the TID wrapped. This is
       * considered a duplicate and we should discard it.
       */
      if (!(DUP_TID_AFTER_WRAP(lastTID, appMsgTID)))
    d280:	7e 90 fd ff 	cmp.b	#-3,	r14	;#0xfffd
    d284:	0f 28       	jnc	$+32     	;abs 0xd2a4
 *           Otherwise returns non-zero. In this case the message should be
 *           processed. The last-seen TID should be updated with the current
 *           application payload TID.
 *
 */
uint8_t nwk_checkAppMsgTID(appPTid_t lastTID, appPTid_t appMsgTID)
    d286:	7d 90 03 00 	cmp.b	#3,	r13	;#0x0003
    d28a:	08 28       	jnc	$+18     	;abs 0xd29c
      }
    }
  }

  return rc;
}
    d28c:	30 41       	ret			
    {
      /* New TID is smaller. Accept the payload if this is the wrap case or we missed
       * the specific wrap frame but are still within the range in which we assume
       * we missed it. Otherwise is a genuine late frame so we should ignore it.
       */
      if (CHECK_TID_WRAP(lastTID, appMsgTID))
    d28e:	7f 90 fd ff 	cmp.b	#-3,	r15	;#0xfffd
    d292:	06 28       	jnc	$+14     	;abs 0xd2a0
 *           application payload TID.
 *
 */
uint8_t nwk_checkAppMsgTID(appPTid_t lastTID, appPTid_t appMsgTID)
{
  uint8_t rc = 0;
    d294:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d296:	7e 90 03 00 	cmp.b	#3,	r14	;#0x0003
    d29a:	f8 2b       	jnc	$-14     	;abs 0xd28c
    d29c:	4f 43       	clr.b	r15		
    d29e:	30 41       	ret			
    d2a0:	4f 43       	clr.b	r15		
      }
    }
  }

  return rc;
}
    d2a2:	30 41       	ret			
    d2a4:	30 41       	ret			

0000d2a6 <nwk_getNumObjectFromMsg>:
 *                 guaranteed only for object size cases defined (and
 *                 vacuously size 1).
 *
 */
void nwk_getNumObjectFromMsg(void *src, void *dest, uint8_t objSize)
{
    d2a6:	0c 4e       	mov	r14,	r12	
  /* Take care of alignment */
  memmove(dest, src, objSize);
    d2a8:	4d 4d       	mov.b	r13,	r13	
    d2aa:	0e 4f       	mov	r15,	r14	
    d2ac:	0f 4c       	mov	r12,	r15	
    d2ae:	b0 12 f4 e1 	call	#0xe1f4	
      *((uint32_t *)dest) = ntohl(*((uint32_t *)dest));
      break;
  }

  return;
}
    d2b2:	30 41       	ret			

0000d2b4 <nwk_putNumObjectIntoMsg>:
 * @return   void. There is no warning if there is no case for the supplied
 *                 object size. A simple copy is then done.
 *
 */
void nwk_putNumObjectIntoMsg(void *src, void *dest, uint8_t objSize)
{
    d2b4:	0b 12       	push	r11		
    d2b6:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    d2ba:	0b 4e       	mov	r14,	r11	
  uint8_t *ptr;
  uint16_t u16;
  uint32_t u32;

  /* Take care of endianess */
  switch(objSize)
    d2bc:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    d2be:	0c 24       	jz	$+26     	;abs 0xd2d8
    d2c0:	6d 92       	cmp.b	#4,	r13	;r2 As==10
    d2c2:	0e 24       	jz	$+30     	;abs 0xd2e0
    d2c4:	0c 4f       	mov	r15,	r12	
      ptr = (uint8_t *)src;
      break;
  }

  /* Take care of alignment */
  memmove(dest, ptr, objSize);
    d2c6:	4d 4d       	mov.b	r13,	r13	
    d2c8:	0e 4c       	mov	r12,	r14	
    d2ca:	0f 4b       	mov	r11,	r15	
    d2cc:	b0 12 f4 e1 	call	#0xe1f4	

  return;
}
    d2d0:	31 50 06 00 	add	#6,	r1	;#0x0006
    d2d4:	3b 41       	pop	r11		
    d2d6:	30 41       	ret			
    case 1:
      ptr = (uint8_t *)src;
      break;

    case 2:
      u16 = htons(*((uint16_t *)src));
    d2d8:	a1 4f 00 00 	mov	@r15,	0(r1)	;0x0000(r1)
      ptr = (uint8_t *)&u16;
    d2dc:	0c 41       	mov	r1,	r12	
      break;
    d2de:	f3 3f       	jmp	$-24     	;abs 0xd2c6

    case 4:
      u32 = htonl(*((uint32_t *)src));
    d2e0:	a1 4f 02 00 	mov	@r15,	2(r1)	;0x0002(r1)
    d2e4:	91 4f 02 00 	mov	2(r15),	4(r1)	;0x0002(r15), 0x0004(r1)
    d2e8:	04 00 
      ptr = (uint8_t *)&u32;
    d2ea:	0c 41       	mov	r1,	r12	
    d2ec:	2c 53       	incd	r12		
      break;
    d2ee:	eb 3f       	jmp	$-40     	;abs 0xd2c6

0000d2f0 <nwk_NVObj>:

  return rc;
#else  /* NVOBJECT_SUPPORT */
  return SMPL_BAD_PARAM;
#endif
}
    d2f0:	2f 43       	mov	#2,	r15	;r3 As==10
    d2f2:	30 41       	ret			

0000d2f4 <nwk_joinInit>:
 *
 * @return   void
 */
void nwk_joinInit(uint8_t (*pf)(linkID_t))
{
  if (!sJoinToken) 
    d2f4:	82 93 58 02 	tst	&0x0258	
    d2f8:	09 20       	jnz	$+20     	;abs 0xd30c
    d2fa:	82 93 5a 02 	tst	&0x025a	
    d2fe:	06 20       	jnz	$+14     	;abs 0xd30c
  {
    sJoinToken = DEFAULT_JOIN_TOKEN;
    d300:	b2 40 08 07 	mov	#1800,	&0x0258	;#0x0708
    d304:	58 02 
    d306:	b2 40 06 05 	mov	#1286,	&0x025a	;#0x0506
    d30a:	5a 02 
  }
  
  spCallback = pf;
    d30c:	82 4f 5c 02 	mov	r15,	&0x025c	
  (void) spCallback;  /* keep compiler happy if we don't use this */

  sTid = MRFI_RandomByte() ;
    d310:	b0 12 2a c3 	call	#0xc32a	
    d314:	c2 4f 56 02 	mov.b	r15,	&0x0256	
#endif
  spSandFContext = nwk_getSFInfoPtr();
#endif

  return;
}
    d318:	30 41       	ret			

0000d31a <nwk_setJoinToken>:
 * @return   void
 */
void nwk_setJoinToken(uint32_t token)
{
  /* only set if the supplied token is non-zero. */
  if (token)
    d31a:	0e 93       	tst	r14		
    d31c:	03 20       	jnz	$+8      	;abs 0xd324
    d31e:	0f 93       	tst	r15		
    d320:	01 20       	jnz	$+4      	;abs 0xd324
    d322:	30 41       	ret			
  {
    sJoinToken = token;
    d324:	82 4e 58 02 	mov	r14,	&0x0258	
    d328:	82 4f 5a 02 	mov	r15,	&0x025a	
    d32c:	30 41       	ret			

0000d32e <nwk_getJoinToken>:
 * @return   Current link token
 */
void nwk_getJoinToken(uint32_t *pToken)
{
  /* only set if the supplied token is non-zero. */
  if (pToken)
    d32e:	0f 93       	tst	r15		
    d330:	06 24       	jz	$+14     	;abs 0xd33e
  {
    *pToken = sJoinToken;
    d332:	9f 42 58 02 	mov	&0x0258,0(r15)	;0x0000(r15)
    d336:	00 00 
    d338:	9f 42 5a 02 	mov	&0x025a,2(r15)	;0x0002(r15)
    d33c:	02 00 
    d33e:	30 41       	ret			

0000d340 <nwk_join>:
 * output parameters
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_join(void)
{
    d340:	0b 12       	push	r11		
    d342:	31 50 e8 ff 	add	#-24,	r1	;#0xffe8
  uint8_t      msg[JOIN_FRAME_SIZE];
  uint32_t     linkToken;
  addr_t       apAddr;
  uint8_t      radioState = MRFI_GetRadioState();
    d346:	b0 12 ea c3 	call	#0xc3ea	
    d34a:	4b 4f       	mov.b	r15,	r11	
    nwk_setChannel(&channels[i]);
#else
  {
#endif

    ioctl_info.send.addr = (addr_t *)nwk_getBCastAddress();
    d34c:	b0 12 a6 dc 	call	#0xdca6	
    d350:	81 4f 10 00 	mov	r15,	16(r1)	;0x0010(r1)
    ioctl_info.send.msg  = msg;
    d354:	0f 41       	mov	r1,	r15	
    d356:	3f 52       	add	#8,	r15	;r2 As==11
    d358:	81 4f 12 00 	mov	r15,	18(r1)	;0x0012(r1)
    ioctl_info.send.len  = sizeof(msg);
    d35c:	f1 42 14 00 	mov.b	#8,	20(r1)	;r2 As==11, 0x0014(r1)
    ioctl_info.send.port = SMPL_PORT_JOIN;
    d360:	f1 40 03 00 	mov.b	#3,	21(r1)	;#0x0003, 0x0015(r1)
    d364:	15 00 

    /* Put join token in */
    nwk_putNumObjectIntoMsg((void *)&sJoinToken, msg+J_JOIN_TOKEN_OS, sizeof(sJoinToken));
    d366:	6d 42       	mov.b	#4,	r13	;r2 As==10
    d368:	0e 41       	mov	r1,	r14	
    d36a:	3e 50 0a 00 	add	#10,	r14	;#0x000a
    d36e:	3f 40 58 02 	mov	#600,	r15	;#0x0258
    d372:	b0 12 b4 d2 	call	#0xd2b4	
    /* set app info byte */
    msg[JB_REQ_OS] = JOIN_REQ_JOIN;
    d376:	d1 43 08 00 	mov.b	#1,	8(r1)	;r3 As==01, 0x0008(r1)
    msg[JB_TID_OS] = sTid;
    d37a:	d1 42 56 02 	mov.b	&0x0256,9(r1)	;0x0009(r1)
    d37e:	09 00 
    /* Set number of connections supported. Used only by AP if it is
     * a data hub.
     */
    msg[J_NUMCONN_OS] = NUM_CONNECTIONS;
    d380:	e1 43 0e 00 	mov.b	#2,	14(r1)	;r3 As==10, 0x000e(r1)
    /* protocol version number */
    msg[J_PROTOCOL_VERSION_OS] = nwk_getProtocolVersion();
    d384:	b0 12 3e dc 	call	#0xdc3e	
    d388:	c1 4f 0f 00 	mov.b	r15,	15(r1)	;0x000f(r1)

    SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_WRITE, &ioctl_info.send);
    d38c:	0d 41       	mov	r1,	r13	
    d38e:	3d 50 10 00 	add	#16,	r13	;#0x0010
    d392:	3e 40 03 00 	mov	#3,	r14	;#0x0003
    d396:	2f 43       	mov	#2,	r15	;r3 As==10
    d398:	b0 12 04 ce 	call	#0xce04	

    ioctl_info.recv.port = SMPL_PORT_JOIN;
    d39c:	f1 40 03 00 	mov.b	#3,	21(r1)	;#0x0003, 0x0015(r1)
    d3a0:	15 00 
    ioctl_info.recv.msg  = msg;
    d3a2:	0f 41       	mov	r1,	r15	
    d3a4:	3f 52       	add	#8,	r15	;r2 As==11
    d3a6:	81 4f 12 00 	mov	r15,	18(r1)	;0x0012(r1)
    ioctl_info.recv.addr = &apAddr;    /* save AP address from reply */
    d3aa:	81 41 10 00 	mov	r1,	16(r1)	;0x0010(r1)

    NWK_CHECK_FOR_SETRX(radioState);
    d3ae:	7b 90 03 00 	cmp.b	#3,	r11	;#0x0003
    d3b2:	33 24       	jz	$+104    	;abs 0xd41a
    d3b4:	5b 93       	cmp.b	#1,	r11	;r3 As==01
    d3b6:	34 24       	jz	$+106    	;abs 0xd420
    d3b8:	b0 12 ec c4 	call	#0xc4ec	
    NWK_REPLY_DELAY();
    d3bc:	b0 12 66 c3 	call	#0xc366	
    NWK_CHECK_FOR_RESTORE_STATE(radioState);
    d3c0:	b0 12 b8 c4 	call	#0xc4b8	

    if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
    d3c4:	0d 41       	mov	r1,	r13	
    d3c6:	3d 50 10 00 	add	#16,	r13	;#0x0010
    d3ca:	2e 43       	mov	#2,	r14	;r3 As==10
    d3cc:	2f 43       	mov	#2,	r15	;r3 As==10
    d3ce:	b0 12 04 ce 	call	#0xce04	
    d3d2:	0f 93       	tst	r15		
    d3d4:	06 24       	jz	$+14     	;abs 0xd3e2
{
  uint8_t      msg[JOIN_FRAME_SIZE];
  uint32_t     linkToken;
  addr_t       apAddr;
  uint8_t      radioState = MRFI_GetRadioState();
  smplStatus_t rc = SMPL_NO_JOIN;
    d3d6:	3f 40 06 00 	mov	#6,	r15	;#0x0006
    /* TODO: process encryption stuff */
  }

  return rc;

}
    d3da:	31 50 18 00 	add	#24,	r1	;#0x0018
    d3de:	3b 41       	pop	r11		
    d3e0:	30 41       	ret			
    NWK_REPLY_DELAY();
    NWK_CHECK_FOR_RESTORE_STATE(radioState);

    if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
    {
      uint8_t firstByte = msg[JB_REQ_OS] & (~NWK_APP_REPLY_BIT);
    d3e2:	5f 41 08 00 	mov.b	8(r1),	r15	;0x0008(r1)
    d3e6:	7f f0 7f 00 	and.b	#127,	r15	;#0x007f

      /* Sanity check for correct reply frame. Older version
       * has the length instead of the request as the first byte.
       */
      if ((firstByte == JOIN_REQ_JOIN) ||
    d3ea:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    d3ec:	03 24       	jz	$+8      	;abs 0xd3f4
    d3ee:	7f 90 06 00 	cmp.b	#6,	r15	;#0x0006
    d3f2:	f1 23       	jnz	$-28     	;abs 0xd3d6
          (firstByte == JOIN_REPLY_LEGACY_MSG_LENGTH)
         )
      {
        /* join reply returns link token */
        memcpy(&linkToken, msg+JR_LINK_TOKEN_OS, sizeof(linkToken));
    d3f4:	91 41 0a 00 	mov	10(r1),	4(r1)	;0x000a(r1), 0x0004(r1)
    d3f8:	04 00 
    d3fa:	91 41 0c 00 	mov	12(r1),	6(r1)	;0x000c(r1), 0x0006(r1)
    d3fe:	06 00 

        nwk_setLinkToken(linkToken);
    d400:	1e 41 04 00 	mov	4(r1),	r14	;0x0004(r1)
    d404:	1f 41 06 00 	mov	6(r1),	r15	;0x0006(r1)
    d408:	b0 12 e8 d6 	call	#0xd6e8	
        /* save AP address */
        nwk_setAPAddress(&apAddr);
    d40c:	0f 41       	mov	r1,	r15	
    d40e:	b0 12 64 dc 	call	#0xdc64	
        sTid++;   /* guard against duplicates */
    d412:	d2 53 56 02 	inc.b	&0x0256	
        rc = SMPL_SUCCESS;
    d416:	0f 43       	clr	r15		
    d418:	e0 3f       	jmp	$-62     	;abs 0xd3da
    ioctl_info.recv.port = SMPL_PORT_JOIN;
    ioctl_info.recv.msg  = msg;
    ioctl_info.recv.addr = &apAddr;    /* save AP address from reply */

    NWK_CHECK_FOR_SETRX(radioState);
    NWK_REPLY_DELAY();
    d41a:	b0 12 66 c3 	call	#0xc366	
    d41e:	d2 3f       	jmp	$-90     	;abs 0xd3c4

    ioctl_info.recv.port = SMPL_PORT_JOIN;
    ioctl_info.recv.msg  = msg;
    ioctl_info.recv.addr = &apAddr;    /* save AP address from reply */

    NWK_CHECK_FOR_SETRX(radioState);
    d420:	b0 12 d2 c5 	call	#0xc5d2	
    d424:	b0 12 ec c4 	call	#0xc4ec	
    NWK_REPLY_DELAY();
    d428:	b0 12 66 c3 	call	#0xc366	
    NWK_CHECK_FOR_RESTORE_STATE(radioState);
    d42c:	b0 12 0c c5 	call	#0xc50c	
    d430:	c9 3f       	jmp	$-108    	;abs 0xd3c4

0000d432 <nwk_processJoin>:
  uint8_t    replyType;

  /* Make sure this is a reply and see if we sent this. Validate the
   * packet for reception by client app.
   */
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, JB_REQ_OS, JB_TID_OS)))
    d432:	5e 42 56 02 	mov.b	&0x0256,r14	
    d436:	5c 43       	mov.b	#1,	r12	;r3 As==01
    d438:	4d 43       	clr.b	r13		
    d43a:	b0 12 f2 d1 	call	#0xd1f2	
    d43e:	4f 93       	tst.b	r15		
    d440:	02 24       	jz	$+6      	;abs 0xd446
 *
 * @return   Keep frame for application, release frame, or replay frame.
 */
fhStatus_t nwk_processJoin(mrfiPacket_t *frame)
{
  fhStatus_t rc = FHS_RELEASE;
    d442:	0f 43       	clr	r15		
#endif /* not END_DEVICE */

  (void) replyType;  /* keep compiler happy */

  return rc;
}
    d444:	30 41       	ret			
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, JB_REQ_OS, JB_TID_OS)))
  {
    /* It's a match and it's a reply. Validate the received packet by
     * returning a 1 so it can be received by the client app.
     */
    MRFI_PostKillSem();
    d446:	b0 12 dc c3 	call	#0xc3dc	
    rc = FHS_KEEP;
    d44a:	1f 43       	mov	#1,	r15	;r3 As==01
    d44c:	30 41       	ret			

0000d44e <nwk_frameInit>:
    sMyTxType = F_TX_DEVICE_AP;
  #else
    sMyTxType = F_TX_DEVICE_RE;
  #endif
#else
    sMyTxType = F_TX_DEVICE_ED;
    d44e:	c2 43 5e 02 	mov.b	#0,	&0x025e	;r3 As==00
  #endif
#endif
/****** DONE fill static values for the DEVICEINFO byte that will go in each frame ******/

#if !defined(RX_POLLS)
  spCallback = pF;
    d452:	82 4f 60 02 	mov	r15,	&0x0260	
#else
  (void) pF;
#endif

  sMyAddr = nwk_getMyAddress();
    d456:	b0 12 26 dc 	call	#0xdc26	
    d45a:	82 4f 62 02 	mov	r15,	&0x0262	

  while (!(sTRACTID=MRFI_RandomByte())) ;
    d45e:	b0 12 2a c3 	call	#0xc32a	
    d462:	c2 4f 64 02 	mov.b	r15,	&0x0264	
    d466:	4f 93       	tst.b	r15		
    d468:	fa 27       	jz	$-10     	;abs 0xd45e

  return;
}
    d46a:	30 41       	ret			

0000d46c <nwk_buildFrame>:
 *
 * @return   pointer to frameInfo_t structure created. NULL if there is
 *           no room in output queue.
 */
frameInfo_t *nwk_buildFrame(uint8_t port, uint8_t *msg, uint8_t len, uint8_t hops)
{
    d46c:	0b 12       	push	r11		
    d46e:	0a 12       	push	r10		
    d470:	09 12       	push	r9		
    d472:	08 12       	push	r8		
    d474:	07 12       	push	r7		
    d476:	06 12       	push	r6		
    d478:	46 4f       	mov.b	r15,	r6	
    d47a:	08 4e       	mov	r14,	r8	
    d47c:	49 4d       	mov.b	r13,	r9	
    d47e:	47 4c       	mov.b	r12,	r7	
  frameInfo_t  *fInfoPtr;

  if (!(fInfoPtr=nwk_QfindSlot(OUTQ)))
    d480:	6f 43       	mov.b	#2,	r15	;r3 As==10
    d482:	b0 12 02 df 	call	#0xdf02	
    d486:	0b 4f       	mov	r15,	r11	
    d488:	0f 93       	tst	r15		
    d48a:	32 24       	jz	$+102    	;abs 0xd4f0
  {
    return (frameInfo_t *)NULL;
  }

  MRFI_SET_PAYLOAD_LEN(&fInfoPtr->mrfiPkt, len+F_APP_PAYLOAD_OS);
    d48c:	4f 49       	mov.b	r9,	r15	
    d48e:	7f 50 0b 00 	add.b	#11,	r15	;#0x000b
    d492:	cb 4f 02 00 	mov.b	r15,	2(r11)	;0x0002(r11)

  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_ENCRYPT_OS, 0);
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_PORT_OS, port);
    d496:	5a 4b 0b 00 	mov.b	11(r11),r10	;0x000b(r11)
    d49a:	7a f0 80 ff 	and.b	#-128,	r10	;#0xff80
    d49e:	4a d6       	bis.b	r6,	r10	
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_TRACTID_OS, sTRACTID);
    d4a0:	5f 42 64 02 	mov.b	&0x0264,r15	
    d4a4:	cb 4f 0d 00 	mov.b	r15,	13(r11)	;0x000d(r11)
  while (!(++sTRACTID)) ;  /* transaction ID can't be 0 */
    d4a8:	01 3c       	jmp	$+4      	;abs 0xd4ac
    d4aa:	4f 43       	clr.b	r15		
    d4ac:	5f 53       	inc.b	r15		
    d4ae:	fd 27       	jz	$-4      	;abs 0xd4aa
    d4b0:	c2 4f 64 02 	mov.b	r15,	&0x0264	
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_RX_TYPE, sMyRxType);
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_HOP_COUNT, hops);
    d4b4:	5f 4b 0c 00 	mov.b	12(r11),r15	;0x000c(r11)
    d4b8:	7f f0 b8 ff 	and.b	#-72,	r15	;#0xffb8
    d4bc:	4f d7       	bis.b	r7,	r15	

  /* reset ack-relevant bits */
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_ACK_REQ, 0);
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_ACK_RPLY, 0);
    d4be:	7f f0 77 00 	and.b	#119,	r15	;#0x0077
    d4c2:	cb 4f 0c 00 	mov.b	r15,	12(r11)	;0x000c(r11)

  /* reset forwarding bit */
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_FWD_FRAME, 0);
    d4c6:	7a f0 7f 00 	and.b	#127,	r10	;#0x007f
    d4ca:	cb 4a 0b 00 	mov.b	r10,	11(r11)	;0x000b(r11)

  memcpy(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt)+F_APP_PAYLOAD_OS, msg, len);
    d4ce:	4d 49       	mov.b	r9,	r13	
    d4d0:	0e 48       	mov	r8,	r14	
    d4d2:	0f 4b       	mov	r11,	r15	
    d4d4:	3f 50 0e 00 	add	#14,	r15	;#0x000e
    d4d8:	b0 12 fa e0 	call	#0xe0fa	
  memcpy(MRFI_P_SRC_ADDR(&fInfoPtr->mrfiPkt), sMyAddr, NET_ADDR_SIZE);
    d4dc:	1f 42 62 02 	mov	&0x0262,r15	
    d4e0:	fb 4f 07 00 	mov.b	@r15+,	7(r11)	;0x0007(r11)
    d4e4:	fb 4f 08 00 	mov.b	@r15+,	8(r11)	;0x0008(r11)
    d4e8:	fb 4f 09 00 	mov.b	@r15+,	9(r11)	;0x0009(r11)
    d4ec:	eb 4f 0a 00 	mov.b	@r15,	10(r11)	;0x000a(r11)

  return fInfoPtr;
}
    d4f0:	0f 4b       	mov	r11,	r15	
    d4f2:	36 41       	pop	r6		
    d4f4:	37 41       	pop	r7		
    d4f6:	38 41       	pop	r8		
    d4f8:	39 41       	pop	r9		
    d4fa:	3a 41       	pop	r10		
    d4fc:	3b 41       	pop	r11		
    d4fe:	30 41       	ret			

0000d500 <MRFI_RxCompleteISR>:
 * output parameters
 *
 * @return      void
 */
void MRFI_RxCompleteISR()
{
    d500:	0b 12       	push	r11		
    d502:	0a 12       	push	r10		
    d504:	09 12       	push	r9		
    d506:	21 83       	decd	r1		
  frameInfo_t  *fInfoPtr;

  /* room for more? */
  if ((fInfoPtr=nwk_QfindSlot(INQ)))
    d508:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d50a:	b0 12 02 df 	call	#0xdf02	
    d50e:	0b 4f       	mov	r15,	r11	
    d510:	0f 93       	tst	r15		
    d512:	31 24       	jz	$+100    	;abs 0xd576
  {
    MRFI_Receive(&fInfoPtr->mrfiPkt);
    d514:	0a 4f       	mov	r15,	r10	
    d516:	2a 53       	incd	r10		
    d518:	0f 4a       	mov	r10,	r15	
    d51a:	b0 12 e0 c2 	call	#0xc2e0	
 *
 * @return   void
 */
static void dispatchFrame(frameInfo_t *fiPtr)
{
  uint8_t     port       = GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_PORT_OS);
    d51e:	59 4b 0b 00 	mov.b	11(r11),r9	;0x000b(r11)
#if !defined(END_DEVICE)
  uint8_t isForMe;
#endif

  /* be sure it's not an echo... */
  if (!memcmp(MRFI_P_SRC_ADDR(&fiPtr->mrfiPkt), sMyAddr, NET_ADDR_SIZE))
    d522:	2d 42       	mov	#4,	r13	;r2 As==10
    d524:	1e 42 62 02 	mov	&0x0262,r14	
    d528:	0f 4b       	mov	r11,	r15	
    d52a:	3f 50 07 00 	add	#7,	r15	;#0x0007
    d52e:	b0 12 da e0 	call	#0xe0da	
    d532:	0f 93       	tst	r15		
    d534:	1e 24       	jz	$+62     	;abs 0xd572
    /* Encyrption bit is not on when when it should be */
    fiPtr->fi_usage = FI_AVAILABLE;
    return;
  }
#else
  if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_ENCRYPT_OS))
    d536:	39 b0 40 00 	bit	#64,	r9	;#0x0040
    d53a:	1b 20       	jnz	$+56     	;abs 0xd572
 *
 * @return   void
 */
static void dispatchFrame(frameInfo_t *fiPtr)
{
  uint8_t     port       = GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_PORT_OS);
    d53c:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f
#endif  /* SMPL_SECURE */

  /* If it's a network application port dispatch to service routine. Dispose
   * of frame depending on return code.
   */
  if (port && (port <= nwkAppSize))
    d540:	18 24       	jz	$+50     	;abs 0xd572
    d542:	79 90 07 00 	cmp.b	#7,	r9	;#0x0007
    d546:	1c 28       	jnc	$+58     	;abs 0xd580
      fiPtr->fi_usage = FI_AVAILABLE;
    }
    return;
  }
  /* sanity check */
  else if ((port != SMPL_PORT_USER_BCAST) && ((port < PORT_BASE_NUMBER) || (port > SMPL_PORT_STATIC_MAX)))
    d548:	79 50 e0 ff 	add.b	#-32,	r9	;#0xffe0
    d54c:	79 90 20 00 	cmp.b	#32,	r9	;#0x0020
    d550:	10 2c       	jc	$+34     	;abs 0xd572
  {
    fiPtr->fi_usage = FI_AVAILABLE;
  }
#else
  /* it's destined for a user app. */
  if (nwk_isConnectionValid(&fiPtr->mrfiPkt, &lid))
    d552:	0e 41       	mov	r1,	r14	
    d554:	0f 4a       	mov	r10,	r15	
    d556:	b0 12 b8 d0 	call	#0xd0b8	
    d55a:	4f 93       	tst.b	r15		
    d55c:	0a 24       	jz	$+22     	;abs 0xd572
  {
    fiPtr->fi_usage = FI_INUSE_UNTIL_DEL;
    d55e:	db 43 00 00 	mov.b	#1,	0(r11)	;r3 As==01, 0x0000(r11)
    if (spCallback && spCallback(lid))
    d562:	1e 42 60 02 	mov	&0x0260,r14	
    d566:	0e 93       	tst	r14		
    d568:	06 24       	jz	$+14     	;abs 0xd576
    d56a:	6f 41       	mov.b	@r1,	r15	
    d56c:	8e 12       	call	r14		
    d56e:	4f 93       	tst.b	r15		
    d570:	02 24       	jz	$+6      	;abs 0xd576
      return;
    }
  }
  else
  {
    fiPtr->fi_usage = FI_AVAILABLE;
    d572:	cb 43 00 00 	mov.b	#0,	0(r11)	;r3 As==00, 0x0000(r11)

    dispatchFrame(fInfoPtr);
  }

  return;
}
    d576:	21 53       	incd	r1		
    d578:	39 41       	pop	r9		
    d57a:	3a 41       	pop	r10		
    d57c:	3b 41       	pop	r11		
    d57e:	30 41       	ret			
    {
      fiPtr->fi_usage = FI_AVAILABLE;
      return;
    }
#endif
    rc = func[port-1](&fiPtr->mrfiPkt);
    d580:	49 49       	mov.b	r9,	r9	
    d582:	39 53       	add	#-1,	r9	;r3 As==11
    d584:	09 59       	rla	r9		
    d586:	0f 4a       	mov	r10,	r15	
    d588:	99 12 ba e3 	call	-7238(r9)	;0xe3ba(r9)
    if (FHS_KEEP == rc)
    d58c:	1f 93       	cmp	#1,	r15	;r3 As==01
    d58e:	f1 23       	jnz	$-28     	;abs 0xd572
    {
      fiPtr->fi_usage = FI_INUSE_UNTIL_DEL;
    d590:	db 43 00 00 	mov.b	#1,	0(r11)	;r3 As==01, 0x0000(r11)
    d594:	f0 3f       	jmp	$-30     	;abs 0xd576

0000d596 <nwk_retrieveFrame>:
 *            SMPL_NO_FRAME  - no frame found for specified destination
 *            SMPL_BAD_PARAM - no valid connection info for the Link ID
 *
 */
smplStatus_t nwk_retrieveFrame(rcvContext_t *rcv, uint8_t *msg, uint8_t *len, addr_t *srcAddr, uint8_t *hopCount)
{
    d596:	0b 12       	push	r11		
    d598:	0a 12       	push	r10		
    d59a:	09 12       	push	r9		
    d59c:	08 12       	push	r8		
    d59e:	07 12       	push	r7		
    d5a0:	06 12       	push	r6		
    d5a2:	09 4f       	mov	r15,	r9	
    d5a4:	07 4e       	mov	r14,	r7	
    d5a6:	0a 4d       	mov	r13,	r10	
    d5a8:	08 4c       	mov	r12,	r8	
    d5aa:	16 41 0e 00 	mov	14(r1),	r6	;0x000e(r1)
  frameInfo_t *fPtr;
  uint8_t      done;

  do {
    /* look for a frame on requested port. */
    *len = 0;
    d5ae:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00, 0x0000(r13)
    done = 1;

    fPtr = nwk_QfindOldest(INQ, rcv, USAGE_NORMAL);
    d5b2:	5d 43       	mov.b	#1,	r13	;r3 As==01
    d5b4:	0e 4f       	mov	r15,	r14	
    d5b6:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d5b8:	b0 12 92 df 	call	#0xdf92	
    d5bc:	0b 4f       	mov	r15,	r11	
    if (fPtr)
    d5be:	0f 93       	tst	r15		
    d5c0:	38 24       	jz	$+114    	;abs 0xd632
    {
      connInfo_t  *pCInfo = 0;

      if (RCV_APP_LID == rcv->type)
    d5c2:	99 93 00 00 	cmp	#1,	0(r9)	;r3 As==01, 0x0000(r9)
    d5c6:	3d 24       	jz	$+124    	;abs 0xd642
        }
#endif  /* SMPL_SECURE */
      }

      /* it's on the requested port. */
      *len = MRFI_GET_PAYLOAD_LEN(&fPtr->mrfiPkt) - F_APP_PAYLOAD_OS;
    d5c8:	5d 4f 02 00 	mov.b	2(r15),	r13	;0x0002(r15)
    d5cc:	7d 50 f5 ff 	add.b	#-11,	r13	;#0xfff5
    d5d0:	ca 4d 00 00 	mov.b	r13,	0(r10)	;0x0000(r10)
      memcpy(msg, MRFI_P_PAYLOAD(&fPtr->mrfiPkt)+F_APP_PAYLOAD_OS, *len);
    d5d4:	4d 4d       	mov.b	r13,	r13	
    d5d6:	0e 4f       	mov	r15,	r14	
    d5d8:	3e 50 0e 00 	add	#14,	r14	;#0x000e
    d5dc:	0f 47       	mov	r7,	r15	
    d5de:	b0 12 fa e0 	call	#0xe0fa	
      {
        /* Save Rx metrics... */
        pCInfo->sigInfo.rssi = fPtr->mrfiPkt.rxMetrics[MRFI_RX_METRICS_RSSI_OFS];
        pCInfo->sigInfo.lqi  = fPtr->mrfiPkt.rxMetrics[MRFI_RX_METRICS_CRC_LQI_OFS];
      }
      if (srcAddr)
    d5e2:	08 93       	tst	r8		
    d5e4:	0f 24       	jz	$+32     	;abs 0xd604
      {
        /* copy source address if requested */
        memcpy(srcAddr, MRFI_P_SRC_ADDR(&fPtr->mrfiPkt), NET_ADDR_SIZE);
    d5e6:	d8 4b 07 00 	mov.b	7(r11),	0(r8)	;0x0007(r11), 0x0000(r8)
    d5ea:	00 00 
    d5ec:	0c 48       	mov	r8,	r12	
    d5ee:	1c 53       	inc	r12		
    d5f0:	dc 4b 08 00 	mov.b	8(r11),	0(r12)	;0x0008(r11), 0x0000(r12)
    d5f4:	00 00 
    d5f6:	1c 53       	inc	r12		
    d5f8:	dc 4b 09 00 	mov.b	9(r11),	0(r12)	;0x0009(r11), 0x0000(r12)
    d5fc:	00 00 
    d5fe:	dc 4b 0a 00 	mov.b	10(r11),1(r12)	;0x000a(r11), 0x0001(r12)
    d602:	01 00 
      }
      if (hopCount)
    d604:	06 93       	tst	r6		
    d606:	06 24       	jz	$+14     	;abs 0xd614
      {
        /* copy hop count if requested */
        *hopCount = GET_FROM_FRAME(MRFI_P_PAYLOAD(&fPtr->mrfiPkt), F_HOP_COUNT);
    d608:	5f 4b 0c 00 	mov.b	12(r11),r15	;0x000c(r11)
    d60c:	7f f0 07 00 	and.b	#7,	r15	;#0x0007
    d610:	c6 4f 00 00 	mov.b	r15,	0(r6)	;0x0000(r6)
      }
      /* input frame no longer needed. free it. */
      nwk_QadjustOrder(INQ, fPtr->orderStamp);
    d614:	5e 4b 01 00 	mov.b	1(r11),	r14	;0x0001(r11)
    d618:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d61a:	b0 12 be de 	call	#0xdebe	

      fPtr->fi_usage = FI_AVAILABLE;
    d61e:	cb 43 00 00 	mov.b	#0,	0(r11)	;r3 As==00, 0x0000(r11)
      return SMPL_SUCCESS;
    d622:	0f 43       	clr	r15		
    }
  } while (!done);

  return SMPL_NO_FRAME;
}
    d624:	36 41       	pop	r6		
    d626:	37 41       	pop	r7		
    d628:	38 41       	pop	r8		
    d62a:	39 41       	pop	r9		
    d62c:	3a 41       	pop	r10		
    d62e:	3b 41       	pop	r11		
    d630:	30 41       	ret			
      fPtr->fi_usage = FI_AVAILABLE;
      return SMPL_SUCCESS;
    }
  } while (!done);

  return SMPL_NO_FRAME;
    d632:	2f 42       	mov	#4,	r15	;r2 As==10
}
    d634:	36 41       	pop	r6		
    d636:	37 41       	pop	r7		
    d638:	38 41       	pop	r8		
    d63a:	39 41       	pop	r9		
    d63c:	3a 41       	pop	r10		
    d63e:	3b 41       	pop	r11		
    d640:	30 41       	ret			
    {
      connInfo_t  *pCInfo = 0;

      if (RCV_APP_LID == rcv->type)
      {
        pCInfo = nwk_getConnInfo(rcv->t.lid);
    d642:	5f 49 02 00 	mov.b	2(r9),	r15	;0x0002(r9)
    d646:	b0 12 b8 cf 	call	#0xcfb8	
    d64a:	09 4f       	mov	r15,	r9	
        if (!pCInfo)
    d64c:	0f 93       	tst	r15		
    d64e:	14 24       	jz	$+42     	;abs 0xd678
        }
#endif  /* SMPL_SECURE */
      }

      /* it's on the requested port. */
      *len = MRFI_GET_PAYLOAD_LEN(&fPtr->mrfiPkt) - F_APP_PAYLOAD_OS;
    d650:	5d 4b 02 00 	mov.b	2(r11),	r13	;0x0002(r11)
    d654:	7d 50 f5 ff 	add.b	#-11,	r13	;#0xfff5
    d658:	ca 4d 00 00 	mov.b	r13,	0(r10)	;0x0000(r10)
      memcpy(msg, MRFI_P_PAYLOAD(&fPtr->mrfiPkt)+F_APP_PAYLOAD_OS, *len);
    d65c:	4d 4d       	mov.b	r13,	r13	
    d65e:	0e 4b       	mov	r11,	r14	
    d660:	3e 50 0e 00 	add	#14,	r14	;#0x000e
    d664:	0f 47       	mov	r7,	r15	
    d666:	b0 12 fa e0 	call	#0xe0fa	
      /* save signal info */
      if (pCInfo)
      {
        /* Save Rx metrics... */
        pCInfo->sigInfo.rssi = fPtr->mrfiPkt.rxMetrics[MRFI_RX_METRICS_RSSI_OFS];
    d66a:	d9 4b 18 00 	mov.b	24(r11),6(r9)	;0x0018(r11), 0x0006(r9)
    d66e:	06 00 
        pCInfo->sigInfo.lqi  = fPtr->mrfiPkt.rxMetrics[MRFI_RX_METRICS_CRC_LQI_OFS];
    d670:	d9 4b 19 00 	mov.b	25(r11),7(r9)	;0x0019(r11), 0x0007(r9)
    d674:	07 00 
    d676:	b5 3f       	jmp	$-148    	;abs 0xd5e2
      if (RCV_APP_LID == rcv->type)
      {
        pCInfo = nwk_getConnInfo(rcv->t.lid);
        if (!pCInfo)
        {
          return SMPL_BAD_PARAM;
    d678:	2f 43       	mov	#2,	r15	;r3 As==10
    d67a:	d4 3f       	jmp	$-86     	;abs 0xd624

0000d67c <nwk_sendFrame>:
 * @return    SMPL_SUCCESS
 *            SMPL_TX_CCA_FAIL Tx failed because of CCA failure.
 *                             Tx FIFO flushed in this case.
 */
smplStatus_t nwk_sendFrame(frameInfo_t *pFrameInfo, uint8_t txOption)
{
    d67c:	0b 12       	push	r11		
    d67e:	0b 4f       	mov	r15,	r11	
  smplStatus_t rc;

  /* set the type of device sending the frame in the header */
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&pFrameInfo->mrfiPkt), F_TX_DEVICE, sMyTxType);
    d680:	5f 4f 0c 00 	mov.b	12(r15),r15	;0x000c(r15)
    d684:	7f f0 cf ff 	and.b	#-49,	r15	;#0xffcf
    d688:	5f d2 5e 02 	bis.b	&0x025e,r15	
    d68c:	cb 4f 0c 00 	mov.b	r15,	12(r11)	;0x000c(r11)

  if (MRFI_TX_RESULT_SUCCESS == MRFI_Transmit(&pFrameInfo->mrfiPkt, txOption))
    d690:	0f 4b       	mov	r11,	r15	
    d692:	2f 53       	incd	r15		
    d694:	b0 12 3e c6 	call	#0xc63e	
    d698:	4f 93       	tst.b	r15		
    d69a:	06 24       	jz	$+14     	;abs 0xd6a8
  else
  {
    /* Tx failed -- probably CCA. free up frame buffer. We do not have NWK
     * level retries. Let application do it.
     */
    rc = SMPL_TX_CCA_FAIL;
    d69c:	3f 40 09 00 	mov	#9,	r15	;#0x0009
  }

  /* TX is done. free up the frame buffer */
  pFrameInfo->fi_usage = FI_AVAILABLE;
    d6a0:	cb 43 00 00 	mov.b	#0,	0(r11)	;r3 As==00, 0x0000(r11)

  return rc;
}
    d6a4:	3b 41       	pop	r11		
    d6a6:	30 41       	ret			
  /* set the type of device sending the frame in the header */
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&pFrameInfo->mrfiPkt), F_TX_DEVICE, sMyTxType);

  if (MRFI_TX_RESULT_SUCCESS == MRFI_Transmit(&pFrameInfo->mrfiPkt, txOption))
  {
    rc = SMPL_SUCCESS;
    d6a8:	0f 43       	clr	r15		
     */
    rc = SMPL_TX_CCA_FAIL;
  }

  /* TX is done. free up the frame buffer */
  pFrameInfo->fi_usage = FI_AVAILABLE;
    d6aa:	cb 43 00 00 	mov.b	#0,	0(r11)	;r3 As==00, 0x0000(r11)

  return rc;
}
    d6ae:	3b 41       	pop	r11		
    d6b0:	30 41       	ret			

0000d6b2 <nwk_getMyRxType>:
 * @return      The address LSB.
 */
uint8_t nwk_getMyRxType(void)
{
  return sMyRxType;
}
    d6b2:	4f 43       	clr.b	r15		
    d6b4:	30 41       	ret			

0000d6b6 <nwk_linkInit>:
 *
 * @return   void
 */
void nwk_linkInit(void)
{
  if (!sLinkToken)
    d6b6:	82 93 6c 02 	tst	&0x026c	
    d6ba:	09 20       	jnz	$+20     	;abs 0xd6ce
    d6bc:	82 93 6e 02 	tst	&0x026e	
    d6c0:	06 20       	jnz	$+14     	;abs 0xd6ce
  {
    /* if the link token has not been set externally by the time we get here
     * (such as by the ioctl token-setting interface) assign the default
     */
    sLinkToken = DEFAULT_LINK_TOKEN;
    d6c2:	b2 40 04 03 	mov	#772,	&0x026c	;#0x0304
    d6c6:	6c 02 
    d6c8:	b2 40 02 01 	mov	#258,	&0x026e	;#0x0102
    d6cc:	6e 02 
  }

  /* set a non-zero TID. */
  while (!(sTid = MRFI_RandomByte()))  ;
    d6ce:	b0 12 2a c3 	call	#0xc32a	
    d6d2:	c2 4f 66 02 	mov.b	r15,	&0x0266	
    d6d6:	4f 93       	tst.b	r15		
    d6d8:	fa 27       	jz	$-10     	;abs 0xd6ce

#if NUM_CONNECTIONS > 0
  memset((void *)&sServiceLinkID, 0x0, sizeof(sServiceLinkID));
    d6da:	c2 43 68 02 	mov.b	#0,	&0x0268	;r3 As==00
    d6de:	3f 40 68 02 	mov	#616,	r15	;#0x0268
    d6e2:	cf 43 01 00 	mov.b	#0,	1(r15)	;r3 As==00, 0x0001(r15)
#endif

  return;
}
    d6e6:	30 41       	ret			

0000d6e8 <nwk_setLinkToken>:
 * @return   void
 */
void nwk_setLinkToken(uint32_t token)
{
  /* only set if the supplied token is non-zero. */
  if (token)
    d6e8:	0e 93       	tst	r14		
    d6ea:	03 20       	jnz	$+8      	;abs 0xd6f2
    d6ec:	0f 93       	tst	r15		
    d6ee:	01 20       	jnz	$+4      	;abs 0xd6f2
    d6f0:	30 41       	ret			
  {
    sLinkToken = token;
    d6f2:	82 4e 6c 02 	mov	r14,	&0x026c	
    d6f6:	82 4f 6e 02 	mov	r15,	&0x026e	
    d6fa:	30 41       	ret			

0000d6fc <nwk_getLinkToken>:
 * @return   Current link token
 */
void nwk_getLinkToken(uint32_t *pToken)
{
  /* only set if the supplied token is non-zero. */
  if (pToken)
    d6fc:	0f 93       	tst	r15		
    d6fe:	06 24       	jz	$+14     	;abs 0xd70c
  {
    *pToken = sLinkToken;
    d700:	9f 42 6c 02 	mov	&0x026c,0(r15)	;0x0000(r15)
    d704:	00 00 
    d706:	9f 42 6e 02 	mov	&0x026e,2(r15)	;0x0002(r15)
    d70a:	02 00 
    d70c:	30 41       	ret			

0000d70e <nwk_link>:
 * @param   lid     - pointer to Link ID (port) assigned for this link
 *
 * @return   Status of the operation.
 */
smplStatus_t nwk_link(linkID_t *lid)
{
    d70e:	0b 12       	push	r11		
    d710:	0a 12       	push	r10		
    d712:	09 12       	push	r9		
    d714:	31 50 ea ff 	add	#-22,	r1	;#0xffea
    d718:	09 4f       	mov	r15,	r9	
  uint8_t       msg[LINK_FRAME_SIZE];
  connInfo_t   *pCInfo = nwk_getNextConnection();
    d71a:	b0 12 36 cf 	call	#0xcf36	
    d71e:	0b 4f       	mov	r15,	r11	
  smplStatus_t  rc;

  if (pCInfo)
    d720:	0f 93       	tst	r15		
    d722:	12 24       	jz	$+38     	;abs 0xd748
    {
      ioctlRawSend_t    send;
      ioctlRawReceive_t recv;
    } ioctl_info;

    if (!nwk_allocateLocalRxPort(LINK_SEND, pCInfo))
    d724:	0e 4f       	mov	r15,	r14	
    d726:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d728:	b0 12 1a d1 	call	#0xd11a	
    d72c:	4f 93       	tst.b	r15		
    d72e:	15 20       	jnz	$+44     	;abs 0xd75a
    {
      nwk_freeConnection(pCInfo);
    d730:	0f 4b       	mov	r11,	r15	
    d732:	b0 12 b2 cf 	call	#0xcfb2	
      return SMPL_NOMEM;
    d736:	3a 40 03 00 	mov	#3,	r10	;#0x0003
    }
    return SMPL_SUCCESS;
  }

  return SMPL_NOMEM;
}
    d73a:	0f 4a       	mov	r10,	r15	
    d73c:	31 50 16 00 	add	#22,	r1	;#0x0016
    d740:	39 41       	pop	r9		
    d742:	3a 41       	pop	r10		
    d744:	3b 41       	pop	r11		
    d746:	30 41       	ret			
      sTid = 1;
    }
    return SMPL_SUCCESS;
  }

  return SMPL_NOMEM;
    d748:	3a 40 03 00 	mov	#3,	r10	;#0x0003
}
    d74c:	0f 4a       	mov	r10,	r15	
    d74e:	31 50 16 00 	add	#22,	r1	;#0x0016
    d752:	39 41       	pop	r9		
    d754:	3a 41       	pop	r10		
    d756:	3b 41       	pop	r11		
    d758:	30 41       	ret			
    {
      nwk_freeConnection(pCInfo);
      return SMPL_NOMEM;
    }

    memcpy(addr.addr, nwk_getBCastAddress(), NET_ADDR_SIZE);
    d75a:	b0 12 a6 dc 	call	#0xdca6	
    d75e:	0e 4f       	mov	r15,	r14	
    d760:	f1 4e 00 00 	mov.b	@r14+,	0(r1)	;0x0000(r1)
    d764:	0d 41       	mov	r1,	r13	
    d766:	1d 53       	inc	r13		
    d768:	fd 4e 00 00 	mov.b	@r14+,	0(r13)	;0x0000(r13)
    d76c:	1d 53       	inc	r13		
    d76e:	fd 4e 00 00 	mov.b	@r14+,	0(r13)	;0x0000(r13)
    d772:	ed 4e 01 00 	mov.b	@r14,	1(r13)	;0x0001(r13)
    ioctl_info.send.addr = &addr;
    d776:	81 41 04 00 	mov	r1,	4(r1)	;0x0004(r1)
    ioctl_info.send.msg  = msg;
    d77a:	0e 41       	mov	r1,	r14	
    d77c:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    d780:	81 4e 06 00 	mov	r14,	6(r1)	;0x0006(r1)
    ioctl_info.send.len  = sizeof(msg);
    d784:	f1 40 09 00 	mov.b	#9,	8(r1)	;#0x0009, 0x0008(r1)
    d788:	08 00 
    ioctl_info.send.port = SMPL_PORT_LINK;
    d78a:	e1 43 09 00 	mov.b	#2,	9(r1)	;r3 As==10, 0x0009(r1)

    /* Put link token in */
    nwk_putNumObjectIntoMsg((void *)&sLinkToken, msg+L_LINK_TOKEN_OS, sizeof(sLinkToken));
    d78e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    d790:	2e 53       	incd	r14		
    d792:	3f 40 6c 02 	mov	#620,	r15	;#0x026c
    d796:	b0 12 b4 d2 	call	#0xd2b4	

    /* set port to which the remote device should send */
    msg[L_RMT_PORT_OS] = pCInfo->portRx;
    d79a:	d1 4b 08 00 	mov.b	8(r11),	18(r1)	;0x0008(r11), 0x0012(r1)
    d79e:	12 00 

    /* set the transaction ID. this allows target to figure out duplicates */
    msg[LB_TID_OS] = sTid;
    d7a0:	d1 42 66 02 	mov.b	&0x0266,13(r1)	;0x000d(r1)
    d7a4:	0d 00 

    /* set my Rx type */
    msg[L_MY_RXTYPE_OS] = nwk_getMyRxType();
    d7a6:	b0 12 b2 d6 	call	#0xd6b2	
    d7aa:	c1 4f 13 00 	mov.b	r15,	19(r1)	;0x0013(r1)

    /* set request byte */
    msg[LB_REQ_OS] = LINK_REQ_LINK;
    d7ae:	d1 43 0c 00 	mov.b	#1,	12(r1)	;r3 As==01, 0x000c(r1)

    /* protocol version number */
    msg[L_PROTOCOL_VERSION_OS] = nwk_getProtocolVersion();
    d7b2:	b0 12 3e dc 	call	#0xdc3e	
    d7b6:	c1 4f 14 00 	mov.b	r15,	20(r1)	;0x0014(r1)

    nwk_putNumObjectIntoMsg((void *)&pCInfo->connTxCTR, (void *)&msg[L_CTR_OS], 4);
#endif


    if (SMPL_SUCCESS != (rc=SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_WRITE, &ioctl_info.send)))
    d7ba:	0d 41       	mov	r1,	r13	
    d7bc:	2d 52       	add	#4,	r13	;r2 As==10
    d7be:	3e 40 03 00 	mov	#3,	r14	;#0x0003
    d7c2:	2f 43       	mov	#2,	r15	;r3 As==10
    d7c4:	b0 12 04 ce 	call	#0xce04	
    d7c8:	0a 4f       	mov	r15,	r10	
    d7ca:	0f 93       	tst	r15		
    d7cc:	b6 23       	jnz	$-146    	;abs 0xd73a
    {
      return rc;
    }

    {
      uint8_t radioState = MRFI_GetRadioState();
    d7ce:	b0 12 ea c3 	call	#0xc3ea	

      ioctl_info.recv.port = SMPL_PORT_LINK;
    d7d2:	e1 43 09 00 	mov.b	#2,	9(r1)	;r3 As==10, 0x0009(r1)
      ioctl_info.recv.msg  = msg;
    d7d6:	0e 41       	mov	r1,	r14	
    d7d8:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    d7dc:	81 4e 06 00 	mov	r14,	6(r1)	;0x0006(r1)
      ioctl_info.recv.addr = (addr_t *)pCInfo->peerAddr;
    d7e0:	0e 4b       	mov	r11,	r14	
    d7e2:	2e 53       	incd	r14		
    d7e4:	81 4e 04 00 	mov	r14,	4(r1)	;0x0004(r1)

      NWK_CHECK_FOR_SETRX(radioState);
    d7e8:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    d7ec:	1f 24       	jz	$+64     	;abs 0xd82c
    d7ee:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    d7f0:	40 24       	jz	$+130    	;abs 0xd872
    d7f2:	b0 12 ec c4 	call	#0xc4ec	
      NWK_REPLY_DELAY();
    d7f6:	b0 12 66 c3 	call	#0xc366	
      NWK_CHECK_FOR_RESTORE_STATE(radioState);
    d7fa:	b0 12 b8 c4 	call	#0xc4b8	

      if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
    d7fe:	0d 41       	mov	r1,	r13	
    d800:	2d 52       	add	#4,	r13	;r2 As==10
    d802:	2e 43       	mov	#2,	r14	;r3 As==10
    d804:	2f 43       	mov	#2,	r15	;r3 As==10
    d806:	b0 12 04 ce 	call	#0xce04	
    d80a:	0f 93       	tst	r15		
    d80c:	2a 20       	jnz	$+86     	;abs 0xd862
      {
        uint8_t firstByte = msg[LB_REQ_OS] & (~NWK_APP_REPLY_BIT);
    d80e:	5f 41 0c 00 	mov.b	12(r1),	r15	;0x000c(r1)
    d812:	7f f0 7f 00 	and.b	#127,	r15	;#0x007f

        /* Sanity check for correct reply frame. Older version
         * has the length instead of the request as the first byte.
         */
        if ((firstByte != LINK_REQ_LINK) &&
    d816:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    d818:	0c 24       	jz	$+26     	;abs 0xd832
    d81a:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    d81e:	09 24       	jz	$+20     	;abs 0xd832
            (firstByte != LINK_REPLY_LEGACY_MSG_LENGTH)
           )
        {
          /* invalidate connection object */
          nwk_freeConnection(pCInfo);
    d820:	0f 4b       	mov	r11,	r15	
    d822:	b0 12 b2 cf 	call	#0xcfb2	
          return SMPL_NO_LINK;
    d826:	3a 40 05 00 	mov	#5,	r10	;#0x0005
    d82a:	87 3f       	jmp	$-240    	;abs 0xd73a
      ioctl_info.recv.port = SMPL_PORT_LINK;
      ioctl_info.recv.msg  = msg;
      ioctl_info.recv.addr = (addr_t *)pCInfo->peerAddr;

      NWK_CHECK_FOR_SETRX(radioState);
      NWK_REPLY_DELAY();
    d82c:	b0 12 66 c3 	call	#0xc366	
    d830:	e6 3f       	jmp	$-50     	;abs 0xd7fe
        /* no successful receive */
        nwk_freeConnection(pCInfo);
        return SMPL_TIMEOUT;
      }

      pCInfo->connState = CONNSTATE_CONNECTED;
    d832:	eb 43 00 00 	mov.b	#2,	0(r11)	;r3 As==10, 0x0000(r11)
      pCInfo->portTx    = msg[LR_RMT_PORT_OS];    /* link reply returns remote port */
    d836:	db 41 0e 00 	mov.b	14(r1),	9(r11)	;0x000e(r1), 0x0009(r11)
    d83a:	09 00 
      *lid              = pCInfo->thisLinkID;     /* return our local port number */
    d83c:	d9 4b 0a 00 	mov.b	10(r11),0(r9)	;0x000a(r11), 0x0000(r9)
    d840:	00 00 
      /* Set hop count. If it's a polling device set the count to the
       * distance to the AP. Otherwise, set it to the max less the remaining
       * which will be the path taken for this frame. It will be no worse
       * then tha max and probably will be better.
       */
      if (F_RX_TYPE_POLLS == msg[LR_MY_RXTYPE_OS])
    d842:	f1 90 40 00 	cmp.b	#64,	15(r1)	;#0x0040, 0x000f(r1)
    d846:	0f 00 
    d848:	11 24       	jz	$+36     	;abs 0xd86c
         * was marginal.
         */
#if defined(DEVICE_DOES_NOT_MOVE)
        pCInfo->hops2target = MAX_HOPS - ioctl_info.recv.hopCount;
#else
        pCInfo->hops2target = MAX_HOPS;
    d84a:	fb 40 03 00 	mov.b	#3,	1(r11)	;#0x0003, 0x0001(r11)
    d84e:	01 00 
      nwk_getNumObjectFromMsg((void *)&msg[LR_CTR_OS], (void *)&pCInfo->connRxCTR, 4);
#endif
    }

    /* guard against duplicates... */
    ++sTid;
    d850:	d2 53 66 02 	inc.b	&0x0266	
    if (!sTid)
    d854:	5f 42 66 02 	mov.b	&0x0266,r15	
    d858:	4f 93       	tst.b	r15		
    d85a:	6f 23       	jnz	$-288    	;abs 0xd73a
    {
      sTid = 1;
    d85c:	d2 43 66 02 	mov.b	#1,	&0x0266	;r3 As==01
    d860:	6c 3f       	jmp	$-294    	;abs 0xd73a
        }
      }
      else
      {
        /* no successful receive */
        nwk_freeConnection(pCInfo);
    d862:	0f 4b       	mov	r11,	r15	
    d864:	b0 12 b2 cf 	call	#0xcfb2	
        return SMPL_TIMEOUT;
    d868:	1a 43       	mov	#1,	r10	;r3 As==01
    d86a:	67 3f       	jmp	$-304    	;abs 0xd73a
       * which will be the path taken for this frame. It will be no worse
       * then tha max and probably will be better.
       */
      if (F_RX_TYPE_POLLS == msg[LR_MY_RXTYPE_OS])
      {
        pCInfo->hops2target = MAX_HOPS_FROM_AP;
    d86c:	db 43 01 00 	mov.b	#1,	1(r11)	;r3 As==01, 0x0001(r11)
    d870:	ef 3f       	jmp	$-32     	;abs 0xd850

      ioctl_info.recv.port = SMPL_PORT_LINK;
      ioctl_info.recv.msg  = msg;
      ioctl_info.recv.addr = (addr_t *)pCInfo->peerAddr;

      NWK_CHECK_FOR_SETRX(radioState);
    d872:	b0 12 d2 c5 	call	#0xc5d2	
    d876:	b0 12 ec c4 	call	#0xc4ec	
      NWK_REPLY_DELAY();
    d87a:	b0 12 66 c3 	call	#0xc366	
      NWK_CHECK_FOR_RESTORE_STATE(radioState);
    d87e:	b0 12 0c c5 	call	#0xc50c	
    d882:	bd 3f       	jmp	$-132    	;abs 0xd7fe

0000d884 <nwk_processLink>:
 * output parameters
 *
 * @return   Keep frame for application, release frame, or replay frame..
 */
fhStatus_t nwk_processLink(mrfiPacket_t *frame)
{
    d884:	0b 12       	push	r11		
    d886:	0a 12       	push	r10		
    d888:	09 12       	push	r9		
    d88a:	08 12       	push	r8		
    d88c:	31 82       	sub	#8,	r1	;r2 As==11
    d88e:	0b 4f       	mov	r15,	r11	

  /* If we sent this then this is the reply. Validate the
   * packet for reception by client app. If we didn't send
   * it then we are the target. send the reply.
   */
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, LB_REQ_OS, LB_TID_OS)))
    d890:	5e 42 66 02 	mov.b	&0x0266,r14	
    d894:	5c 43       	mov.b	#1,	r12	;r3 As==01
    d896:	4d 43       	clr.b	r13		
    d898:	b0 12 f2 d1 	call	#0xd1f2	
    d89c:	4f 93       	tst.b	r15		
    d89e:	56 24       	jz	$+174    	;abs 0xd94c
static fhStatus_t handleLinkRequest(mrfiPacket_t *frame)
{
  fhStatus_t rc = FHS_RELEASE;
  uint8_t    isReplySent;

  if (LINK_LEGACY_MSG_LENGTH == (MRFI_GET_PAYLOAD_LEN(frame) - F_APP_PAYLOAD_OS))
    d8a0:	6f 4b       	mov.b	@r11,	r15	
    d8a2:	7f 90 13 00 	cmp.b	#19,	r15	;#0x0013
    d8a6:	0a 24       	jz	$+22     	;abs 0xd8bc
  {
    /* Legacy frame. Spoof a link request */
    *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS) = LINK_REQ_LINK;
  }

  switch (*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS))
    d8a8:	db 93 0c 00 	cmp.b	#1,	12(r11)	;r3 As==01, 0x000c(r11)
    d8ac:	58 24       	jz	$+178    	;abs 0xd95e
  else
  {
    /* No, we didn't send it. Process request assuming it's
     * intended for us.
     */
    rc = handleLinkRequest(frame);
    d8ae:	0f 43       	clr	r15		
  }

  (void) replyType;  /* keep compiler happy when ED built... */

  return rc;
}
    d8b0:	31 52       	add	#8,	r1	;r2 As==11
    d8b2:	38 41       	pop	r8		
    d8b4:	39 41       	pop	r9		
    d8b6:	3a 41       	pop	r10		
    d8b8:	3b 41       	pop	r11		
    d8ba:	30 41       	ret			
  uint8_t    isReplySent;

  if (LINK_LEGACY_MSG_LENGTH == (MRFI_GET_PAYLOAD_LEN(frame) - F_APP_PAYLOAD_OS))
  {
    /* Legacy frame. Spoof a link request */
    *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS) = LINK_REQ_LINK;
    d8bc:	db 43 0c 00 	mov.b	#1,	12(r11)	;r3 As==01, 0x000c(r11)

  /* see if token is correct */
  {
    uint32_t lt;

    nwk_getNumObjectFromMsg(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_LINK_TOKEN_OS, &lt, sizeof(lt));
    d8c0:	6d 42       	mov.b	#4,	r13	;r2 As==10
    d8c2:	0e 41       	mov	r1,	r14	
    d8c4:	2e 52       	add	#4,	r14	;r2 As==10
    d8c6:	0f 4b       	mov	r11,	r15	
    d8c8:	3f 50 0e 00 	add	#14,	r15	;#0x000e
    d8cc:	b0 12 a6 d2 	call	#0xd2a6	
    if (lt != sLinkToken)
    d8d0:	91 92 6c 02 	cmp	&0x026c,4(r1)	;0x0004(r1)
    d8d4:	04 00 
    d8d6:	eb 23       	jnz	$-40     	;abs 0xd8ae
    d8d8:	91 92 6e 02 	cmp	&0x026e,6(r1)	;0x0006(r1)
    d8dc:	06 00 
    d8de:	e7 23       	jnz	$-48     	;abs 0xd8ae
  }

  /* if we get here the token matched. */

  /* is this a duplicate request? */
  remotePort = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_RMT_PORT_OS);
    d8e0:	58 4b 12 00 	mov.b	18(r11),r8	;0x0012(r11)
  if ((pCInfo=nwk_isLinkDuplicate(MRFI_P_SRC_ADDR(frame), remotePort)))
    d8e4:	0a 4b       	mov	r11,	r10	
    d8e6:	3a 50 05 00 	add	#5,	r10	;#0x0005
    d8ea:	4e 48       	mov.b	r8,	r14	
    d8ec:	0f 4a       	mov	r10,	r15	
    d8ee:	b0 12 04 d0 	call	#0xd004	
    d8f2:	0f 93       	tst	r15		
    d8f4:	3f 24       	jz	$+128    	;abs 0xd974
  {
    /* resend reply */
    msg[LB_REQ_OS] = LINK_REQ_LINK | NWK_APP_REPLY_BIT;
    d8f6:	f1 40 81 ff 	mov.b	#-127,	0(r1)	;#0xff81, 0x0000(r1)
    d8fa:	00 00 

    /* sender's TID */
    msg[LB_TID_OS] = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+LB_TID_OS);
    d8fc:	d1 4b 0d 00 	mov.b	13(r11),1(r1)	;0x000d(r11), 0x0001(r1)
    d900:	01 00 

    /* Send reply with the local port number so the remote device knows where to
     * send packets.
     */
    msg[LR_RMT_PORT_OS] = pCInfo->portRx;
    d902:	d1 4f 08 00 	mov.b	8(r15),	2(r1)	;0x0008(r15), 0x0002(r1)
    d906:	02 00 

    /* put my Rx type in there. used to know how to set hops when sending back. */
    msg[LR_MY_RXTYPE_OS] = nwk_getMyRxType();
    d908:	b0 12 b2 d6 	call	#0xd6b2	
    d90c:	c1 4f 03 00 	mov.b	r15,	3(r1)	;0x0003(r1)
    /* Set the Tx counter value for peer's Rx counter object */
    nwk_putNumObjectIntoMsg((void *)&pCInfo->connTxCTR, (void *)&msg[LR_CTR_OS], 4);
    /* We also need to save the newly generated Rx counter value. */
    nwk_getNumObjectFromMsg((void *)(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_CTR_OS), (void *)&pCInfo->connRxCTR, 4);
#endif
    if ((pOutFrame = nwk_buildFrame(SMPL_PORT_LINK, msg, sizeof(msg), MAX_HOPS-(GET_FROM_FRAME(MRFI_P_PAYLOAD(frame),F_HOP_COUNT)))))
    d910:	5f 4b 0a 00 	mov.b	10(r11),r15	;0x000a(r11)
    d914:	7f f0 07 00 	and.b	#7,	r15	;#0x0007
    d918:	7c 40 03 00 	mov.b	#3,	r12	;#0x0003
    d91c:	4c 8f       	sub.b	r15,	r12	
    d91e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    d920:	0e 41       	mov	r1,	r14	
    d922:	6f 43       	mov.b	#2,	r15	;r3 As==10
    d924:	b0 12 6c d4 	call	#0xd46c	
    d928:	0f 93       	tst	r15		
    d92a:	c1 27       	jz	$-124    	;abs 0xd8ae
    {
      /* destination address is the source adddress of the received frame. */
      memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
    d92c:	ef 4a 03 00 	mov.b	@r10,	3(r15)	;0x0003(r15)
    d930:	df 4b 06 00 	mov.b	6(r11),	4(r15)	;0x0006(r11), 0x0004(r15)
    d934:	04 00 
    d936:	df 4b 07 00 	mov.b	7(r11),	5(r15)	;0x0007(r11), 0x0005(r15)
    d93a:	05 00 
    d93c:	df 4b 08 00 	mov.b	8(r11),	6(r15)	;0x0008(r11), 0x0006(r15)
    d940:	06 00 
#if defined(SMPL_SECURE)
      nwk_setSecureFrame(&pOutFrame->mrfiPkt, sizeof(msg), 0);
#endif  /* SMPL_SECURE */
      nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_FORCED);
    d942:	4e 43       	clr.b	r14		
    d944:	b0 12 7c d6 	call	#0xd67c	
  else
  {
    /* No, we didn't send it. Process request assuming it's
     * intended for us.
     */
    rc = handleLinkRequest(frame);
    d948:	0f 43       	clr	r15		
    d94a:	b2 3f       	jmp	$-154    	;abs 0xd8b0
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, LB_REQ_OS, LB_TID_OS)))
  {
    /* It's a match and it's a reply. Validate the received packet by
     * returning a 1 so it can be received by the client app.
     */
    MRFI_PostKillSem();
    d94c:	b0 12 dc c3 	call	#0xc3dc	
    rc = FHS_KEEP;
    d950:	1f 43       	mov	#1,	r15	;r3 As==01
  }

  (void) replyType;  /* keep compiler happy when ED built... */

  return rc;
}
    d952:	31 52       	add	#8,	r1	;r2 As==11
    d954:	38 41       	pop	r8		
    d956:	39 41       	pop	r9		
    d958:	3a 41       	pop	r10		
    d95a:	3b 41       	pop	r11		
    d95c:	30 41       	ret			
  connInfo_t  *pCInfo;
  uint8_t      remotePort;
  uint8_t      msg[LINK_REPLY_FRAME_SIZE];

  /* Is this a legacy frame? If so continue. Otherwise check version.*/
  if ((MRFI_GET_PAYLOAD_LEN(frame) - F_APP_PAYLOAD_OS) > LINK_LEGACY_MSG_LENGTH)
    d95e:	4f 4f       	mov.b	r15,	r15	
    d960:	3f 90 14 00 	cmp	#20,	r15	;#0x0014
    d964:	ad 3b       	jl	$-164    	;abs 0xd8c0
  {
    /* see if protocol version is correct... */
    if (*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_PROTOCOL_VERSION_OS) != nwk_getProtocolVersion())
    d966:	5a 4b 14 00 	mov.b	20(r11),r10	;0x0014(r11)
    d96a:	b0 12 3e dc 	call	#0xdc3e	
    d96e:	4a 9f       	cmp.b	r15,	r10	
    d970:	9e 23       	jnz	$-194    	;abs 0xd8ae
    d972:	a6 3f       	jmp	$-178    	;abs 0xd8c0
      nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_FORCED);
    }
    return SENT_REPLY;
  }

  if (!sListenActive)
    d974:	5f 42 6a 02 	mov.b	&0x026a,r15	
    d978:	4f 93       	tst.b	r15		
    d97a:	99 27       	jz	$-204    	;abs 0xd8ae
  pCInfo = nwk_findAlreadyJoined(frame);

  if (!pCInfo)
#endif
  {
    pCInfo = nwk_getNextConnection();
    d97c:	b0 12 36 cf 	call	#0xcf36	
    d980:	09 4f       	mov	r15,	r9	
  }

  if (pCInfo)
    d982:	0f 93       	tst	r15		
    d984:	94 27       	jz	$-214    	;abs 0xd8ae
  {
    /* yes there's room and it's not a dup. address. */
    memcpy(&pCInfo->peerAddr, MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
    d986:	2d 42       	mov	#4,	r13	;r2 As==10
    d988:	0e 4a       	mov	r10,	r14	
    d98a:	2f 53       	incd	r15		
    d98c:	b0 12 fa e0 	call	#0xe0fa	

    if (!nwk_allocateLocalRxPort(LINK_REPLY, pCInfo))
    d990:	0e 49       	mov	r9,	r14	
    d992:	6f 43       	mov.b	#2,	r15	;r3 As==10
    d994:	b0 12 1a d1 	call	#0xd11a	
    d998:	4f 93       	tst.b	r15		
    d99a:	43 24       	jz	$+136    	;abs 0xda22

    /* The local Rx port is the one returned in the connection structure. The
     * caller is waiting on this to be set. The code here is running in an ISR
     * thread so the caller will see this change after RETI.
     */
    if (NUM_CONNECTIONS == sNumLinkers)
    d99c:	5f 42 67 02 	mov.b	&0x0267,r15	
    d9a0:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    d9a2:	3f 24       	jz	$+128    	;abs 0xda22
      /* Something is wrong -- no room to stack Link request */
      nwk_freeConnection(pCInfo);
      /* we're done with the packet */
      return SENT_REPLY;
    }
    sServiceLinkID[sNumLinkers++] = pCInfo->thisLinkID;
    d9a4:	5e 42 67 02 	mov.b	&0x0267,r14	
    d9a8:	4f 4e       	mov.b	r14,	r15	
    d9aa:	5d 49 0a 00 	mov.b	10(r9),	r13	;0x000a(r9)
    d9ae:	3f 50 68 02 	add	#616,	r15	;#0x0268
    d9b2:	cf 4d 00 00 	mov.b	r13,	0(r15)	;0x0000(r15)
    d9b6:	5e 53       	inc.b	r14		
    d9b8:	c2 4e 67 02 	mov.b	r14,	&0x0267	

    /* save the remote Tx port */
    pCInfo->portTx = remotePort;
    d9bc:	c9 48 09 00 	mov.b	r8,	9(r9)	;0x0009(r9)

    /* connection is valid... */
    pCInfo->connState = CONNSTATE_CONNECTED;
    d9c0:	e9 43 00 00 	mov.b	#2,	0(r9)	;r3 As==10, 0x0000(r9)
    /* Set hop count. If it's a polling device set the count to the
     * distance to the AP. otherwise, set it to the max less the remaining
     * which will be the path taken for this frame. It will be no worse
     * then tha max and probably will be better.
     */
    if (F_RX_TYPE_POLLS == *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_MY_RXTYPE_OS))
    d9c4:	fb 90 40 00 	cmp.b	#64,	19(r11)	;#0x0040, 0x0013(r11)
    d9c8:	13 00 
    d9ca:	30 24       	jz	$+98     	;abs 0xda2c
       * was marginal.
       */
#if defined(DEVICE_DOES_NOT_MOVE)
      pCInfo->hops2target = MAX_HOPS - GET_FROM_FRAME(MRFI_P_PAYLOAD(frame), F_HOP_COUNT);
#else
      pCInfo->hops2target = MAX_HOPS;
    d9cc:	f9 40 03 00 	mov.b	#3,	1(r9)	;#0x0003, 0x0001(r9)
    d9d0:	01 00 
#endif
    }
    /* Send reply with the local port number so the remote device knows where to
     * send packets.
     */
    msg[LR_RMT_PORT_OS]  = pCInfo->portRx;
    d9d2:	d1 49 08 00 	mov.b	8(r9),	2(r1)	;0x0008(r9), 0x0002(r1)
    d9d6:	02 00 

    /* put my Rx type in there. used to know how to set hops when sending back. */
    msg[LR_MY_RXTYPE_OS] = nwk_getMyRxType();
    d9d8:	b0 12 b2 d6 	call	#0xd6b2	
    d9dc:	c1 4f 03 00 	mov.b	r15,	3(r1)	;0x0003(r1)

    msg[LB_REQ_OS] = LINK_REQ_LINK | NWK_APP_REPLY_BIT;
    d9e0:	f1 40 81 ff 	mov.b	#-127,	0(r1)	;#0xff81, 0x0000(r1)
    d9e4:	00 00 

    /* sender's TID */
    msg[LB_TID_OS] = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+LB_TID_OS);
    d9e6:	d1 4b 0d 00 	mov.b	13(r11),1(r1)	;0x000d(r11), 0x0001(r1)
    d9ea:	01 00 
                        ((uint32_t)(MRFI_RandomByte())<<16) | \
                        ((uint32_t)(MRFI_RandomByte())<<24);

    nwk_putNumObjectIntoMsg((void *)&pCInfo->connTxCTR, (void *)&msg[LR_CTR_OS], 4);
#endif
    if ((pOutFrame = nwk_buildFrame(SMPL_PORT_LINK, msg, sizeof(msg), MAX_HOPS-(GET_FROM_FRAME(MRFI_P_PAYLOAD(frame),F_HOP_COUNT)))))
    d9ec:	5f 4b 0a 00 	mov.b	10(r11),r15	;0x000a(r11)
    d9f0:	7f f0 07 00 	and.b	#7,	r15	;#0x0007
    d9f4:	7c 40 03 00 	mov.b	#3,	r12	;#0x0003
    d9f8:	4c 8f       	sub.b	r15,	r12	
    d9fa:	6d 42       	mov.b	#4,	r13	;r2 As==10
    d9fc:	0e 41       	mov	r1,	r14	
    d9fe:	6f 43       	mov.b	#2,	r15	;r3 As==10
    da00:	b0 12 6c d4 	call	#0xd46c	
    da04:	0b 4f       	mov	r15,	r11	
    da06:	0f 93       	tst	r15		
    da08:	0c 24       	jz	$+26     	;abs 0xda22
    {
      /* destination address is the source adddress of the received frame. */
      memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
    da0a:	2d 42       	mov	#4,	r13	;r2 As==10
    da0c:	0e 4a       	mov	r10,	r14	
    da0e:	3f 50 03 00 	add	#3,	r15	;#0x0003
    da12:	b0 12 fa e0 	call	#0xe0fa	
#if defined(SMPL_SECURE)
      nwk_setSecureFrame(&pOutFrame->mrfiPkt, sizeof(msg), 0);
#endif
      if (SMPL_SUCCESS != nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_FORCED))
    da16:	4e 43       	clr.b	r14		
    da18:	0f 4b       	mov	r11,	r15	
    da1a:	b0 12 7c d6 	call	#0xd67c	
    da1e:	0f 93       	tst	r15		
    da20:	46 27       	jz	$-370    	;abs 0xd8ae
      }
    }
    else
    {
      /* better release the connection structure */
      nwk_freeConnection(pCInfo);
    da22:	0f 49       	mov	r9,	r15	
    da24:	b0 12 b2 cf 	call	#0xcfb2	
  else
  {
    /* No, we didn't send it. Process request assuming it's
     * intended for us.
     */
    rc = handleLinkRequest(frame);
    da28:	0f 43       	clr	r15		
    da2a:	42 3f       	jmp	$-378    	;abs 0xd8b0
    if (F_RX_TYPE_POLLS == *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_MY_RXTYPE_OS))
    {
      /* It polls. so. we'll be sending to the AP which will store the
       * frame. The AP is only MAX_HOPS_FROM_AP hops away from us.
       */
      pCInfo->hops2target = MAX_HOPS_FROM_AP;
    da2c:	d9 43 01 00 	mov.b	#1,	1(r9)	;r3 As==01, 0x0001(r9)
    da30:	d0 3f       	jmp	$-94     	;abs 0xd9d2

0000da32 <nwk_getLocalLinkID>:
#if NUM_CONNECTIONS > 0
  uint8_t     i;
  bspIState_t intState;


  BSP_ENTER_CRITICAL_SECTION(intState);
    da32:	0f 42       	mov	r2,	r15	
    da34:	3f f2       	and	#8,	r15	;r2 As==11
    da36:	32 c2       	dint			
    da38:	03 43       	nop			
  if (sNumLinkers)
    da3a:	5e 42 67 02 	mov.b	&0x0267,r14	
    da3e:	4e 93       	tst.b	r14		
    da40:	1d 24       	jz	$+60     	;abs 0xda7c
  {
    sNumLinkers--;
    da42:	f2 53 67 02 	add.b	#-1,	&0x0267	;r3 As==11
    BSP_EXIT_CRITICAL_SECTION(intState);
    da46:	0f 93       	tst	r15		
    da48:	20 20       	jnz	$+66     	;abs 0xda8a
 *
 * @return   void
 */
void nwk_setListenContext(uint8_t context)
{
  sListenActive = (context == LINK_LISTEN_ON) ? 1 : 0;
    da4a:	c2 43 6a 02 	mov.b	#0,	&0x026a	;r3 As==00
  {
    sNumLinkers--;
    BSP_EXIT_CRITICAL_SECTION(intState);

    nwk_setListenContext(LINK_LISTEN_OFF);
    lid = sServiceLinkID[0];
    da4e:	5f 42 68 02 	mov.b	&0x0268,r15	
     * window of opportunity for a "typical" scenario to get hosed. But for
     * a "typical" scenario to get hosed a number of improbable events have to
     * occur. These are deemed far less likely than the multiple-ED-activation
     * scenario in the AP-as-dat-hub case.
     */
    for (i=0; i<sNumLinkers; ++i)
    da52:	5e 42 67 02 	mov.b	&0x0267,r14	
    da56:	4e 93       	tst.b	r14		
    da58:	14 24       	jz	$+42     	;abs 0xda82
    da5a:	4d 43       	clr.b	r13		
    {
      sServiceLinkID[i] = sServiceLinkID[i+1];
    da5c:	4c 4d       	mov.b	r13,	r12	
    da5e:	0e 4c       	mov	r12,	r14	
    da60:	1e 53       	inc	r14		
    da62:	3e 50 68 02 	add	#616,	r14	;#0x0268
    da66:	6e 4e       	mov.b	@r14,	r14	
    da68:	3c 50 68 02 	add	#616,	r12	;#0x0268
    da6c:	cc 4e 00 00 	mov.b	r14,	0(r12)	;0x0000(r12)
     * window of opportunity for a "typical" scenario to get hosed. But for
     * a "typical" scenario to get hosed a number of improbable events have to
     * occur. These are deemed far less likely than the multiple-ED-activation
     * scenario in the AP-as-dat-hub case.
     */
    for (i=0; i<sNumLinkers; ++i)
    da70:	5d 53       	inc.b	r13		
    da72:	5e 42 67 02 	mov.b	&0x0267,r14	
    da76:	4d 9e       	cmp.b	r14,	r13	
    da78:	f1 2b       	jnc	$-28     	;abs 0xda5c
    da7a:	30 41       	ret			
      sServiceLinkID[i] = sServiceLinkID[i+1];
    }
  }
  else
  {
    BSP_EXIT_CRITICAL_SECTION(intState);
    da7c:	0f 93       	tst	r15		
    da7e:	02 20       	jnz	$+6      	;abs 0xda84
 *
 * @return   Local port assigned when the link reply was received.
 */
linkID_t nwk_getLocalLinkID(void)
{
  linkID_t    lid = 0;
    da80:	4f 43       	clr.b	r15		
    BSP_EXIT_CRITICAL_SECTION(intState);
  }
#endif  /* NUM_CONNECTIONS */

  return lid;
}
    da82:	30 41       	ret			
      sServiceLinkID[i] = sServiceLinkID[i+1];
    }
  }
  else
  {
    BSP_EXIT_CRITICAL_SECTION(intState);
    da84:	32 d2       	eint			
 *
 * @return   Local port assigned when the link reply was received.
 */
linkID_t nwk_getLocalLinkID(void)
{
  linkID_t    lid = 0;
    da86:	4f 43       	clr.b	r15		
    da88:	30 41       	ret			

  BSP_ENTER_CRITICAL_SECTION(intState);
  if (sNumLinkers)
  {
    sNumLinkers--;
    BSP_EXIT_CRITICAL_SECTION(intState);
    da8a:	32 d2       	eint			
    da8c:	de 3f       	jmp	$-66     	;abs 0xda4a

0000da8e <nwk_setListenContext>:
 *
 * @return   void
 */
void nwk_setListenContext(uint8_t context)
{
  sListenActive = (context == LINK_LISTEN_ON) ? 1 : 0;
    da8e:	5e 43       	mov.b	#1,	r14	;r3 As==01
    da90:	4f 93       	tst.b	r15		
    da92:	01 24       	jz	$+4      	;abs 0xda96
    da94:	4e 43       	clr.b	r14		
    da96:	c2 4e 6a 02 	mov.b	r14,	&0x026a	
}
    da9a:	30 41       	ret			

0000da9c <nwk_rawSend>:
 * @return         SMPL_SUCCESS
 *                 SMPL_NOMEM       - no room in output frame queue
 *                 SMPL_TX_CCA_FAIL - CCA failure
 */
smplStatus_t nwk_rawSend(ioctlRawSend_t *info)
{
    da9c:	0b 12       	push	r11		
    da9e:	0b 4f       	mov	r15,	r11	
  uint8_t      hops;

  /* If we know frame is going to or from the AP then we can reduce the hop
   * count.
   */
  switch (info->port)
    daa0:	5f 4f 05 00 	mov.b	5(r15),	r15	;0x0005(r15)
    daa4:	4e 4f       	mov.b	r15,	r14	
    daa6:	7e 50 fd ff 	add.b	#-3,	r14	;#0xfffd
    daaa:	6e 92       	cmp.b	#4,	r14	;r2 As==10
    daac:	19 2c       	jc	$+52     	;abs 0xdae0
    daae:	4e 4e       	mov.b	r14,	r14	
    dab0:	5c 4e c6 e3 	mov.b	-7226(r14),r12	;0xe3c6(r14)
    default:
      hops = MAX_HOPS;
      break;
  }

  if ((pOutFrame = nwk_buildFrame(info->port, info->msg, info->len, hops)))
    dab4:	5d 4b 04 00 	mov.b	4(r11),	r13	;0x0004(r11)
    dab8:	1e 4b 02 00 	mov	2(r11),	r14	;0x0002(r11)
    dabc:	b0 12 6c d4 	call	#0xd46c	
    dac0:	0f 93       	tst	r15		
    dac2:	11 24       	jz	$+36     	;abs 0xdae6
  {
    memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), info->addr, NET_ADDR_SIZE);
    dac4:	2e 4b       	mov	@r11,	r14	
    dac6:	ff 4e 03 00 	mov.b	@r14+,	3(r15)	;0x0003(r15)
    daca:	ff 4e 04 00 	mov.b	@r14+,	4(r15)	;0x0004(r15)
    dace:	ff 4e 05 00 	mov.b	@r14+,	5(r15)	;0x0005(r15)
    dad2:	ef 4e 06 00 	mov.b	@r14,	6(r15)	;0x0006(r15)
#ifdef SMPL_SECURE
    nwk_setSecureFrame(&pOutFrame->mrfiPkt, info->len, 0);
#endif  /* SMPL_SECURE */
    return nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_CCA);
    dad6:	5e 43       	mov.b	#1,	r14	;r3 As==01
    dad8:	b0 12 7c d6 	call	#0xd67c	
  }
  return SMPL_NOMEM;
}
    dadc:	3b 41       	pop	r11		
    dade:	30 41       	ret			
  uint8_t      hops;

  /* If we know frame is going to or from the AP then we can reduce the hop
   * count.
   */
  switch (info->port)
    dae0:	7c 40 03 00 	mov.b	#3,	r12	;#0x0003
    dae4:	e7 3f       	jmp	$-48     	;abs 0xdab4
#ifdef SMPL_SECURE
    nwk_setSecureFrame(&pOutFrame->mrfiPkt, info->len, 0);
#endif  /* SMPL_SECURE */
    return nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_CCA);
  }
  return SMPL_NOMEM;
    dae6:	3f 40 03 00 	mov	#3,	r15	;#0x0003
}
    daea:	3b 41       	pop	r11		
    daec:	30 41       	ret			

0000daee <nwk_rawReceive>:
 *                       hop count of retrieved frame.
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_rawReceive(ioctlRawReceive_t *info)
{
    daee:	21 82       	sub	#4,	r1	;r2 As==10
  rcvContext_t rcv;

  rcv.type   = RCV_NWK_PORT;
    daf0:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00, 0x0000(r1)
  rcv.t.port = info->port;
    daf4:	d1 4f 05 00 	mov.b	5(r15),	2(r1)	;0x0005(r15), 0x0002(r1)
    daf8:	02 00 

  return nwk_retrieveFrame(&rcv, info->msg, &info->len, info->addr, &info->hopCount);
    dafa:	0e 4f       	mov	r15,	r14	
    dafc:	3e 50 06 00 	add	#6,	r14	;#0x0006
    db00:	0e 12       	push	r14		
    db02:	2c 4f       	mov	@r15,	r12	
    db04:	0d 4f       	mov	r15,	r13	
    db06:	2d 52       	add	#4,	r13	;r2 As==10
    db08:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    db0c:	0f 41       	mov	r1,	r15	
    db0e:	2f 53       	incd	r15		
    db10:	b0 12 96 d5 	call	#0xd596	
}
    db14:	31 50 06 00 	add	#6,	r1	;#0x0006
    db18:	30 41       	ret			

0000db1a <nwk_radioControl>:
 * output parameters
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
    db1a:	21 83       	decd	r1		
  smplStatus_t rc = SMPL_SUCCESS;

  if (IOCTL_ACT_RADIO_SLEEP == action)
    db1c:	2f 92       	cmp	#4,	r15	;r2 As==10
    db1e:	19 24       	jz	$+52     	;abs 0xdb52
  {
    /* go to sleep mode. */
    MRFI_RxIdle();
    MRFI_Sleep();
  }
  else if (IOCTL_ACT_RADIO_AWAKE == action)
    db20:	3f 90 05 00 	cmp	#5,	r15	;#0x0005
    db24:	1d 24       	jz	$+60     	;abs 0xdb60
#if !defined( END_DEVICE )
    MRFI_RxOn();
#endif

  }
  else if (IOCTL_ACT_RADIO_SIGINFO == action)
    db26:	3f 90 06 00 	cmp	#6,	r15	;#0x0006
    db2a:	1f 24       	jz	$+64     	;abs 0xdb6a
    {
      return SMPL_BAD_PARAM;
    }
    memcpy(&pSigInfo->sigInfo, &pCInfo->sigInfo, sizeof(pCInfo->sigInfo));
  }
  else if (IOCTL_ACT_RADIO_RSSI == action)
    db2c:	3f 90 07 00 	cmp	#7,	r15	;#0x0007
    db30:	2e 24       	jz	$+94     	;abs 0xdb8e
  {
    *((rssi_t *)val) = MRFI_Rssi();
  }
  else if (IOCTL_ACT_RADIO_RXON == action)
    db32:	3f 92       	cmp	#8,	r15	;r2 As==11
    db34:	06 24       	jz	$+14     	;abs 0xdb42
  {
    MRFI_RxOn();
  }
  else if (IOCTL_ACT_RADIO_RXIDLE == action)
    db36:	3f 90 09 00 	cmp	#9,	r15	;#0x0009
    db3a:	07 24       	jz	$+16     	;abs 0xdb4a
    return SMPL_SUCCESS;
  }
#endif  /* EXTENDED_API */
  else
  {
    rc = SMPL_BAD_PARAM;
    db3c:	2f 43       	mov	#2,	r15	;r3 As==10
  }
  return rc;
}
    db3e:	21 53       	incd	r1		
    db40:	30 41       	ret			
  {
    *((rssi_t *)val) = MRFI_Rssi();
  }
  else if (IOCTL_ACT_RADIO_RXON == action)
  {
    MRFI_RxOn();
    db42:	b0 12 ec c4 	call	#0xc4ec	
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    db46:	0f 43       	clr	r15		
    db48:	fa 3f       	jmp	$-10     	;abs 0xdb3e
  {
    MRFI_RxOn();
  }
  else if (IOCTL_ACT_RADIO_RXIDLE == action)
  {
    MRFI_RxIdle();
    db4a:	b0 12 b8 c4 	call	#0xc4b8	
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    db4e:	0f 43       	clr	r15		
    db50:	f6 3f       	jmp	$-18     	;abs 0xdb3e

  if (IOCTL_ACT_RADIO_SLEEP == action)
  {
    /* go to sleep mode. */
    MRFI_RxIdle();
    db52:	b0 12 b8 c4 	call	#0xc4b8	
    MRFI_Sleep();
    db56:	b0 12 0c c5 	call	#0xc50c	
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    db5a:	0f 43       	clr	r15		
  else
  {
    rc = SMPL_BAD_PARAM;
  }
  return rc;
}
    db5c:	21 53       	incd	r1		
    db5e:	30 41       	ret			
    MRFI_RxIdle();
    MRFI_Sleep();
  }
  else if (IOCTL_ACT_RADIO_AWAKE == action)
  {
    MRFI_WakeUp();
    db60:	b0 12 d2 c5 	call	#0xc5d2	
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    db64:	0f 43       	clr	r15		
  else
  {
    rc = SMPL_BAD_PARAM;
  }
  return rc;
}
    db66:	21 53       	incd	r1		
    db68:	30 41       	ret			

  }
  else if (IOCTL_ACT_RADIO_SIGINFO == action)
  {
    ioctlRadioSiginfo_t *pSigInfo = (ioctlRadioSiginfo_t *)val;
    connInfo_t          *pCInfo   = nwk_getConnInfo(pSigInfo->lid);
    db6a:	6f 4e       	mov.b	@r14,	r15	
    db6c:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    db70:	b0 12 b8 cf 	call	#0xcfb8	

    if (!pCInfo)
    db74:	2e 41       	mov	@r1,	r14	
    db76:	0f 93       	tst	r15		
    db78:	e1 27       	jz	$-60     	;abs 0xdb3c
    {
      return SMPL_BAD_PARAM;
    }
    memcpy(&pSigInfo->sigInfo, &pCInfo->sigInfo, sizeof(pCInfo->sigInfo));
    db7a:	2e 53       	incd	r14		
    db7c:	3f 50 06 00 	add	#6,	r15	;#0x0006
    db80:	ee 4f 00 00 	mov.b	@r15,	0(r14)	;0x0000(r14)
    db84:	de 4f 01 00 	mov.b	1(r15),	1(r14)	;0x0001(r15), 0x0001(r14)
    db88:	01 00 
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    db8a:	0f 43       	clr	r15		
    db8c:	d8 3f       	jmp	$-78     	;abs 0xdb3e
    }
    memcpy(&pSigInfo->sigInfo, &pCInfo->sigInfo, sizeof(pCInfo->sigInfo));
  }
  else if (IOCTL_ACT_RADIO_RSSI == action)
  {
    *((rssi_t *)val) = MRFI_Rssi();
    db8e:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    db92:	b0 12 4e c5 	call	#0xc54e	
    db96:	2e 41       	mov	@r1,	r14	
    db98:	ce 4f 00 00 	mov.b	r15,	0(r14)	;0x0000(r14)
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    db9c:	0f 43       	clr	r15		
    db9e:	cf 3f       	jmp	$-96     	;abs 0xdb3e

0000dba0 <nwk_deviceAddress>:
 * @return   SMPL_SUCCESS
 *           SMPL_BAD_PARAM  Action request illegal or a Set request
 *                           was not respected.
 */
smplStatus_t nwk_deviceAddress(ioctlAction_t action, addr_t *addr)
{
    dba0:	21 83       	decd	r1		
  smplStatus_t rc = SMPL_BAD_PARAM;

  if (IOCTL_ACT_GET == action)
    dba2:	1f 93       	cmp	#1,	r15	;r3 As==01
    dba4:	0c 24       	jz	$+26     	;abs 0xdbbe
  {
    memcpy(addr, nwk_getMyAddress(), sizeof(addr_t));
    rc = SMPL_SUCCESS;
  }
  else if (IOCTL_ACT_SET == action)
    dba6:	0f 93       	tst	r15		
    dba8:	03 24       	jz	$+8      	;abs 0xdbb0
 *           SMPL_BAD_PARAM  Action request illegal or a Set request
 *                           was not respected.
 */
smplStatus_t nwk_deviceAddress(ioctlAction_t action, addr_t *addr)
{
  smplStatus_t rc = SMPL_BAD_PARAM;
    dbaa:	2f 43       	mov	#2,	r15	;r3 As==10
      rc = SMPL_SUCCESS;
    }
  }

  return rc;
}
    dbac:	21 53       	incd	r1		
    dbae:	30 41       	ret			
    memcpy(addr, nwk_getMyAddress(), sizeof(addr_t));
    rc = SMPL_SUCCESS;
  }
  else if (IOCTL_ACT_SET == action)
  {
    if (nwk_setMyAddress(addr))
    dbb0:	0f 4e       	mov	r14,	r15	
    dbb2:	b0 12 42 dc 	call	#0xdc42	
    dbb6:	4f 93       	tst.b	r15		
    dbb8:	f8 27       	jz	$-14     	;abs 0xdbaa
    {
      rc = SMPL_SUCCESS;
    dbba:	0f 43       	clr	r15		
    dbbc:	f7 3f       	jmp	$-16     	;abs 0xdbac
{
  smplStatus_t rc = SMPL_BAD_PARAM;

  if (IOCTL_ACT_GET == action)
  {
    memcpy(addr, nwk_getMyAddress(), sizeof(addr_t));
    dbbe:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    dbc2:	b0 12 26 dc 	call	#0xdc26	
    dbc6:	2e 41       	mov	@r1,	r14	
    dbc8:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dbcc:	1e 53       	inc	r14		
    dbce:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dbd2:	1e 53       	inc	r14		
    dbd4:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dbd8:	ee 4f 01 00 	mov.b	@r15,	1(r14)	;0x0001(r14)
    rc = SMPL_SUCCESS;
    dbdc:	0f 43       	clr	r15		
    dbde:	e6 3f       	jmp	$-50     	;abs 0xdbac

0000dbe0 <nwk_connectionControl>:
 *                           No connection table info for Link ID
 */
smplStatus_t nwk_connectionControl(ioctlAction_t action, void *val)
{
  connInfo_t *pCInfo;
  linkID_t    lid = *((linkID_t *)val);
    dbe0:	6e 4e       	mov.b	@r14,	r14	

  if (IOCTL_ACT_DELETE != action)
    dbe2:	3f 90 0e 00 	cmp	#14,	r15	;#0x000e
    dbe6:	02 24       	jz	$+6      	;abs 0xdbec
  }

  if ((SMPL_LINKID_USER_UUD == lid) ||
      (!(pCInfo=nwk_getConnInfo(lid))))
  {
    return SMPL_BAD_PARAM;
    dbe8:	2f 43       	mov	#2,	r15	;r3 As==10
    dbea:	30 41       	ret			
  if (IOCTL_ACT_DELETE != action)
  {
    return SMPL_BAD_PARAM;
  }

  if ((SMPL_LINKID_USER_UUD == lid) ||
    dbec:	7e 93       	cmp.b	#-1,	r14	;r3 As==11
    dbee:	fc 27       	jz	$-6      	;abs 0xdbe8
    dbf0:	4f 4e       	mov.b	r14,	r15	
    dbf2:	b0 12 b8 cf 	call	#0xcfb8	
    dbf6:	0f 93       	tst	r15		
    dbf8:	04 24       	jz	$+10     	;abs 0xdc02
      (!(pCInfo=nwk_getConnInfo(lid))))
  {
    return SMPL_BAD_PARAM;
  }

  nwk_freeConnection(pCInfo);
    dbfa:	b0 12 b2 cf 	call	#0xcfb2	

  return SMPL_SUCCESS;
    dbfe:	0f 43       	clr	r15		
    dc00:	30 41       	ret			
  }

  if ((SMPL_LINKID_USER_UUD == lid) ||
      (!(pCInfo=nwk_getConnInfo(lid))))
  {
    return SMPL_BAD_PARAM;
    dc02:	2f 43       	mov	#2,	r15	;r3 As==10
  }

  nwk_freeConnection(pCInfo);

  return SMPL_SUCCESS;
}
    dc04:	30 41       	ret			

0000dc06 <nwk_globalsInit>:
 * @return   void
 */
void nwk_globalsInit(void)
{

  memset(&sAPAddress, 0x00, sizeof(addr_t));
    dc06:	82 43 70 02 	mov	#0,	&0x0270	;r3 As==00
    dc0a:	82 43 72 02 	mov	#0,	&0x0272	;r3 As==00

  /* populate RAM address from ROM default if it hasn't laready been set
   * using the IOCTL interface.
   */
  if (!sRAMAddressIsSet)
    dc0e:	c2 93 74 02 	tst.b	&0x0274	
    dc12:	08 20       	jnz	$+18     	;abs 0xdc24
  {
    memcpy(&sMyRAMAddress, &sMyROMAddress, sizeof(addr_t));
    dc14:	92 42 ca e3 	mov	&0xe3ca,&0x0276	
    dc18:	76 02 
    dc1a:	92 42 cc e3 	mov	&0xe3cc,&0x0278	
    dc1e:	78 02 
    sRAMAddressIsSet = 1;  /* RAM address is now valid */
    dc20:	d2 43 74 02 	mov.b	#1,	&0x0274	;r3 As==01
    dc24:	30 41       	ret			

0000dc26 <nwk_getMyAddress>:
   * to be careful -- if this routine is called immediately it will return
   * the ROM address. If the application then sets the address using the
   * IOCTL before doing the SMPL_Init() the original pointer is no longer
   * valid as it points to the wrong address.
   */
  return sRAMAddressIsSet ? &sMyRAMAddress : &sMyROMAddress;
    dc26:	c2 93 74 02 	tst.b	&0x0274	
    dc2a:	03 20       	jnz	$+8      	;abs 0xdc32
    dc2c:	3f 40 ca e3 	mov	#-7222,	r15	;#0xe3ca
}
    dc30:	30 41       	ret			
   * to be careful -- if this routine is called immediately it will return
   * the ROM address. If the application then sets the address using the
   * IOCTL before doing the SMPL_Init() the original pointer is no longer
   * valid as it points to the wrong address.
   */
  return sRAMAddressIsSet ? &sMyRAMAddress : &sMyROMAddress;
    dc32:	3f 40 76 02 	mov	#630,	r15	;#0x0276
    dc36:	30 41       	ret			

0000dc38 <nwk_getFWVersion>:
 * @return   pointer to a constant uint16_t object.
 */
uint8_t const *nwk_getFWVersion()
{
  return sVersionInfo.fwVerString;
}
    dc38:	3f 40 cf e3 	mov	#-7217,	r15	;#0xe3cf
    dc3c:	30 41       	ret			

0000dc3e <nwk_getProtocolVersion>:
 * @return   Protocol version.
 */
uint8_t nwk_getProtocolVersion(void)
{
  return sVersionInfo.protocolVersion;
}
    dc3e:	6f 43       	mov.b	#2,	r15	;r3 As==10
    dc40:	30 41       	ret			

0000dc42 <nwk_setMyAddress>:
 */
uint8_t nwk_setMyAddress(addr_t *addr)
{
  uint8_t rc = 0;

  if (!sRAMAddressIsSet)
    dc42:	c2 93 74 02 	tst.b	&0x0274	
    dc46:	02 24       	jz	$+6      	;abs 0xdc4c
 *
 * @return   Returns non-zero if request is respected, otherwise returns 0.
 */
uint8_t nwk_setMyAddress(addr_t *addr)
{
  uint8_t rc = 0;
    dc48:	4f 43       	clr.b	r15		
    sRAMAddressIsSet = 1;  /* RAM address is now valid */
    rc = 1;
  }

  return rc;
}
    dc4a:	30 41       	ret			
{
  uint8_t rc = 0;

  if (!sRAMAddressIsSet)
  {
    memcpy(&sMyRAMAddress, addr, sizeof(addr_t));
    dc4c:	f2 4f 76 02 	mov.b	@r15+,	&0x0276	
    dc50:	f2 4f 77 02 	mov.b	@r15+,	&0x0277	
    dc54:	f2 4f 78 02 	mov.b	@r15+,	&0x0278	
    dc58:	e2 4f 79 02 	mov.b	@r15,	&0x0279	
    sRAMAddressIsSet = 1;  /* RAM address is now valid */
    dc5c:	d2 43 74 02 	mov.b	#1,	&0x0274	;r3 As==01
    rc = 1;
    dc60:	5f 43       	mov.b	#1,	r15	;r3 As==01
    dc62:	30 41       	ret			

0000dc64 <nwk_setAPAddress>:
 * @return   void
 */
void nwk_setAPAddress(addr_t *addr)
{

  memcpy((void *)&sAPAddress, (void *)addr, NET_ADDR_SIZE);
    dc64:	3e 40 70 02 	mov	#624,	r14	;#0x0270
    dc68:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dc6c:	1e 53       	inc	r14		
    dc6e:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dc72:	1e 53       	inc	r14		
    dc74:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dc78:	ee 4f 01 00 	mov.b	@r15,	1(r14)	;0x0001(r14)

  return;
}
    dc7c:	30 41       	ret			

0000dc7e <nwk_getAPAddress>:
 *
 * @return   Pointer to a constant address object or null if the address has not
 *           yet been set.
 */
addr_t const *nwk_getAPAddress(void)
{
    dc7e:	21 82       	sub	#4,	r1	;r2 As==10
  addr_t addr;

  memset(&addr, 0x0, sizeof(addr));
    dc80:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00, 0x0000(r1)
    dc84:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00, 0x0002(r1)

  return !memcmp(&sAPAddress, &addr, NET_ADDR_SIZE) ? 0 : &sAPAddress;
    dc88:	2d 42       	mov	#4,	r13	;r2 As==10
    dc8a:	0e 41       	mov	r1,	r14	
    dc8c:	3f 40 70 02 	mov	#624,	r15	;#0x0270
    dc90:	b0 12 da e0 	call	#0xe0da	
    dc94:	0f 93       	tst	r15		
    dc96:	04 24       	jz	$+10     	;abs 0xdca0
    dc98:	3f 40 70 02 	mov	#624,	r15	;#0x0270
}
    dc9c:	21 52       	add	#4,	r1	;r2 As==10
    dc9e:	30 41       	ret			
{
  addr_t addr;

  memset(&addr, 0x0, sizeof(addr));

  return !memcmp(&sAPAddress, &addr, NET_ADDR_SIZE) ? 0 : &sAPAddress;
    dca0:	0f 43       	clr	r15		
}
    dca2:	21 52       	add	#4,	r1	;r2 As==10
    dca4:	30 41       	ret			

0000dca6 <nwk_getBCastAddress>:
 * @return   Pointer to a constant address object.
 */
addr_t const *nwk_getBCastAddress(void)
{
  return (addr_t const *)mrfiBroadcastAddr;
}
    dca6:	3f 40 5a e3 	mov	#-7334,	r15	;#0xe35a
    dcaa:	30 41       	ret			

0000dcac <nwk_freqInit>:
 * @return   none.
 */
void nwk_freqInit(void)
{
  return;
}
    dcac:	30 41       	ret			

0000dcae <nwk_processFreq>:
 * @return   Disposition for frame: either release (FHS_RELEASE) or replay (FHS_REPLAY).
 */
fhStatus_t nwk_processFreq(mrfiPacket_t *frame)
{
  return FHS_RELEASE;
}
    dcae:	0f 43       	clr	r15		
    dcb0:	30 41       	ret			

0000dcb2 <nwk_pingInit>:
 *
 * @return   void
 */
void nwk_pingInit(void)
{
  sTid = MRFI_RandomByte();
    dcb2:	b0 12 2a c3 	call	#0xc32a	
    dcb6:	c2 4f 7a 02 	mov.b	r15,	&0x027a	

  return;
}
    dcba:	30 41       	ret			

0000dcbc <nwk_ping>:
 * @return   SMPL_SUCCESS   valid reply received
 *           SMPL_TIMEOUT   no valid reply received
 *           SMPL_NO_CHANNEL  no channels returned on a scan
 */
smplStatus_t nwk_ping(linkID_t lid)
{
    dcbc:	0b 12       	push	r11		
    dcbe:	0a 12       	push	r10		
    dcc0:	09 12       	push	r9		
    dcc2:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    dcc6:	49 4f       	mov.b	r15,	r9	
  connInfo_t  *pCInfo   = nwk_getConnInfo(lid);
    dcc8:	b0 12 b8 cf 	call	#0xcfb8	
    dccc:	0a 4f       	mov	r15,	r10	
  smplStatus_t rc       = SMPL_BAD_PARAM;
  uint8_t      done     = 0;
  uint8_t      repeatIt = 2;
  uint8_t      msg[MAX_PING_APP_FRAME];
  uint8_t      radioState = MRFI_GetRadioState();
    dcce:	b0 12 ea c3 	call	#0xc3ea	
    dcd2:	4b 4f       	mov.b	r15,	r11	
  {
    ioctlRawSend_t    send;
    ioctlRawReceive_t recv;
  } ioctl_info;

  if (!pCInfo || (SMPL_LINKID_USER_UUD == lid))
    dcd4:	0a 93       	tst	r10		
    dcd6:	02 24       	jz	$+6      	;abs 0xdcdc
    dcd8:	79 93       	cmp.b	#-1,	r9	;r3 As==11
    dcda:	07 20       	jnz	$+16     	;abs 0xdcea
  {
    /* either link ID bogus or tried to ping the unconnected user datagram link ID. */
    return rc;
    dcdc:	2f 43       	mov	#2,	r15	;r3 As==10
    }
  } while (repeatIt);

  return done ? SMPL_SUCCESS : SMPL_TIMEOUT;

}
    dcde:	31 50 0a 00 	add	#10,	r1	;#0x000a
    dce2:	39 41       	pop	r9		
    dce4:	3a 41       	pop	r10		
    dce6:	3b 41       	pop	r11		
    dce8:	30 41       	ret			
#else
    {
      repeatIt = 0;
#endif  /* defined(FREQUENCY_AGILITY) && !defined(ACCESS_POINT) */

      ioctl_info.send.addr = (addr_t *)pCInfo->peerAddr;
    dcea:	2a 53       	incd	r10		
    dcec:	81 4a 02 00 	mov	r10,	2(r1)	;0x0002(r1)
      ioctl_info.send.msg  = msg;
    dcf0:	81 41 04 00 	mov	r1,	4(r1)	;0x0004(r1)
      ioctl_info.send.len  = sizeof(msg);
    dcf4:	e1 43 06 00 	mov.b	#2,	6(r1)	;r3 As==10, 0x0006(r1)
      ioctl_info.send.port = SMPL_PORT_PING;
    dcf8:	d1 43 07 00 	mov.b	#1,	7(r1)	;r3 As==01, 0x0007(r1)

      /* fill in msg */
      msg[PB_REQ_OS] = PING_REQ_PING;
    dcfc:	d1 43 00 00 	mov.b	#1,	0(r1)	;r3 As==01, 0x0000(r1)
      msg[PB_TID_OS] = sTid;
    dd00:	d1 42 7a 02 	mov.b	&0x027a,1(r1)	;0x0001(r1)
    dd04:	01 00 

      SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_WRITE, &ioctl_info.send);
    dd06:	0d 41       	mov	r1,	r13	
    dd08:	2d 53       	incd	r13		
    dd0a:	3e 40 03 00 	mov	#3,	r14	;#0x0003
    dd0e:	2f 43       	mov	#2,	r15	;r3 As==10
    dd10:	b0 12 04 ce 	call	#0xce04	

      ioctl_info.recv.port = SMPL_PORT_PING;
    dd14:	d1 43 07 00 	mov.b	#1,	7(r1)	;r3 As==01, 0x0007(r1)
      ioctl_info.recv.msg  = msg;
    dd18:	81 41 04 00 	mov	r1,	4(r1)	;0x0004(r1)
      ioctl_info.recv.addr = 0;
    dd1c:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00, 0x0002(r1)

      NWK_CHECK_FOR_SETRX(radioState);
    dd20:	7b 90 03 00 	cmp.b	#3,	r11	;#0x0003
    dd24:	19 24       	jz	$+52     	;abs 0xdd58
    dd26:	5b 93       	cmp.b	#1,	r11	;r3 As==01
    dd28:	21 24       	jz	$+68     	;abs 0xdd6c
    dd2a:	b0 12 ec c4 	call	#0xc4ec	
      NWK_REPLY_DELAY();
    dd2e:	b0 12 66 c3 	call	#0xc366	
      NWK_CHECK_FOR_RESTORE_STATE(radioState);
    dd32:	b0 12 b8 c4 	call	#0xc4b8	

      if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
    dd36:	0d 41       	mov	r1,	r13	
    dd38:	2d 53       	incd	r13		
    dd3a:	2e 43       	mov	#2,	r14	;r3 As==10
    dd3c:	2f 43       	mov	#2,	r15	;r3 As==10
    dd3e:	b0 12 04 ce 	call	#0xce04	
    dd42:	0f 93       	tst	r15		
    dd44:	0c 20       	jnz	$+26     	;abs 0xdd5e
      {
        repeatIt = 0;
        done     = 1;
        sTid++;   /* guard against duplicates */
    dd46:	d2 53 7a 02 	inc.b	&0x027a	
    dd4a:	0f 43       	clr	r15		
    }
  } while (repeatIt);

  return done ? SMPL_SUCCESS : SMPL_TIMEOUT;

}
    dd4c:	31 50 0a 00 	add	#10,	r1	;#0x000a
    dd50:	39 41       	pop	r9		
    dd52:	3a 41       	pop	r10		
    dd54:	3b 41       	pop	r11		
    dd56:	30 41       	ret			
      ioctl_info.recv.port = SMPL_PORT_PING;
      ioctl_info.recv.msg  = msg;
      ioctl_info.recv.addr = 0;

      NWK_CHECK_FOR_SETRX(radioState);
      NWK_REPLY_DELAY();
    dd58:	b0 12 66 c3 	call	#0xc366	
    dd5c:	ec 3f       	jmp	$-38     	;abs 0xdd36
      NWK_CHECK_FOR_RESTORE_STATE(radioState);

      if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
    dd5e:	1f 43       	mov	#1,	r15	;r3 As==01
    }
  } while (repeatIt);

  return done ? SMPL_SUCCESS : SMPL_TIMEOUT;

}
    dd60:	31 50 0a 00 	add	#10,	r1	;#0x000a
    dd64:	39 41       	pop	r9		
    dd66:	3a 41       	pop	r10		
    dd68:	3b 41       	pop	r11		
    dd6a:	30 41       	ret			

      ioctl_info.recv.port = SMPL_PORT_PING;
      ioctl_info.recv.msg  = msg;
      ioctl_info.recv.addr = 0;

      NWK_CHECK_FOR_SETRX(radioState);
    dd6c:	b0 12 d2 c5 	call	#0xc5d2	
    dd70:	b0 12 ec c4 	call	#0xc4ec	
      NWK_REPLY_DELAY();
    dd74:	b0 12 66 c3 	call	#0xc366	
      NWK_CHECK_FOR_RESTORE_STATE(radioState);
    dd78:	b0 12 0c c5 	call	#0xc50c	
    dd7c:	dc 3f       	jmp	$-70     	;abs 0xdd36

0000dd7e <nwk_processPing>:
 * output parameters
 *
 * @return    Keep frame for application, release frame, or replay frame.
 */
fhStatus_t nwk_processPing(mrfiPacket_t *frame)
{
    dd7e:	0b 12       	push	r11		
    dd80:	0b 4f       	mov	r15,	r11	

  /* If we sent this then this is the reply. Validate the
   * packet for reception by client app. If we didn't send
   * it then we are the target. Send the reply.
   */
  replyType = nwk_isValidReply(frame, sTid, PB_REQ_OS, PB_TID_OS);
    dd82:	5e 42 7a 02 	mov.b	&0x027a,r14	
    dd86:	5c 43       	mov.b	#1,	r12	;r3 As==01
    dd88:	4d 43       	clr.b	r13		
    dd8a:	b0 12 f2 d1 	call	#0xd1f2	
  if (SMPL_MY_REPLY == replyType)
    dd8e:	4f 93       	tst.b	r15		
    dd90:	28 24       	jz	$+82     	;abs 0xdde2
 *
 * @return   void
 */
static void handlePingRequest(mrfiPacket_t *frame)
{
  switch (*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS))
    dd92:	db 93 0c 00 	cmp.b	#1,	12(r11)	;r3 As==01, 0x000c(r11)
    dd96:	03 24       	jz	$+8      	;abs 0xdd9e
  else
  {
    /* No, we didn't send it. Send reply assuming it's a Ping intended for us. */
    handlePingRequest(frame);

    rc = FHS_RELEASE;
    dd98:	0f 43       	clr	r15		
  }

  return rc;
}
    dd9a:	3b 41       	pop	r11		
    dd9c:	30 41       	ret			
  frameInfo_t *pOutFrame;

  /* Build the reply frame. The application payload is the one included in the
   * received frame payload.
   */
  if ((pOutFrame = nwk_buildFrame(SMPL_PORT_PING, MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS, MRFI_GET_PAYLOAD_LEN(frame)-F_APP_PAYLOAD_OS, MAX_HOPS)))
    dd9e:	7c 40 03 00 	mov.b	#3,	r12	;#0x0003
    dda2:	6d 4b       	mov.b	@r11,	r13	
    dda4:	7d 50 f5 ff 	add.b	#-11,	r13	;#0xfff5
    dda8:	0e 4b       	mov	r11,	r14	
    ddaa:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    ddae:	5f 43       	mov.b	#1,	r15	;r3 As==01
    ddb0:	b0 12 6c d4 	call	#0xd46c	
    ddb4:	0f 93       	tst	r15		
    ddb6:	f0 27       	jz	$-30     	;abs 0xdd98
  {
    /* destination address is the source adddress of the received frame. */
    memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
    ddb8:	df 4b 05 00 	mov.b	5(r11),	3(r15)	;0x0005(r11), 0x0003(r15)
    ddbc:	03 00 
    ddbe:	df 4b 06 00 	mov.b	6(r11),	4(r15)	;0x0006(r11), 0x0004(r15)
    ddc2:	04 00 
    ddc4:	df 4b 07 00 	mov.b	7(r11),	5(r15)	;0x0007(r11), 0x0005(r15)
    ddc8:	05 00 
    ddca:	df 4b 08 00 	mov.b	8(r11),	6(r15)	;0x0008(r11), 0x0006(r15)
    ddce:	06 00 

    /* turn on the reply bit in the application payload */
    *(MRFI_P_PAYLOAD(&pOutFrame->mrfiPkt)+F_APP_PAYLOAD_OS+PB_REQ_OS) |= NWK_APP_REPLY_BIT;
    ddd0:	ff d0 80 ff 	bis.b	#-128,	14(r15)	;#0xff80, 0x000e(r15)
    ddd4:	0e 00 
#ifdef SMPL_SECURE
    nwk_setSecureFrame(&pOutFrame->mrfiPkt, MRFI_GET_PAYLOAD_LEN(frame)-F_APP_PAYLOAD_OS, 0);
#endif  /* SMPL_SECURE */
    nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_FORCED);
    ddd6:	4e 43       	clr.b	r14		
    ddd8:	b0 12 7c d6 	call	#0xd67c	
  else
  {
    /* No, we didn't send it. Send reply assuming it's a Ping intended for us. */
    handlePingRequest(frame);

    rc = FHS_RELEASE;
    dddc:	0f 43       	clr	r15		
  }

  return rc;
}
    ddde:	3b 41       	pop	r11		
    dde0:	30 41       	ret			
  if (SMPL_MY_REPLY == replyType)
  {
    /* It's a match and it's a reply. Validate the received packet by
     * returning a 1 so it can be received by the client app.
     */
    MRFI_PostKillSem();
    dde2:	b0 12 dc c3 	call	#0xc3dc	
    rc = FHS_KEEP;
    dde6:	1f 43       	mov	#1,	r15	;r3 As==01

    rc = FHS_RELEASE;
  }

  return rc;
}
    dde8:	3b 41       	pop	r11		
    ddea:	30 41       	ret			

0000ddec <nwk_mgmtInit>:
 * @return   void
 */

void nwk_mgmtInit(void)
{
  sTid = MRFI_RandomByte();
    ddec:	b0 12 2a c3 	call	#0xc32a	
    ddf0:	c2 4f 7c 02 	mov.b	r15,	&0x027c	
#ifdef ACCESS_POINT
  memset(&sSFMarker, 0x0, sizeof(sSFMarker));
#endif

  return;
}
    ddf4:	30 41       	ret			

0000ddf6 <nwk_processMgmt>:
 * output parameters
 *
 * @return   Keep frame for application, release frame, or replay frame.
 */
fhStatus_t nwk_processMgmt(mrfiPacket_t *frame)
{
    ddf6:	0b 12       	push	r11		
    ddf8:	0b 4f       	mov	r15,	r11	

  /* If we sent this then this is the reply. Validate the
   * packet for reception by client app. If we didn't send
   * it then we are the target. send the reply.
   */
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, MB_APP_INFO_OS, MB_TID_OS)))
    ddfa:	5e 42 7c 02 	mov.b	&0x027c,r14	
    ddfe:	5c 43       	mov.b	#1,	r12	;r3 As==01
    de00:	4d 43       	clr.b	r13		
    de02:	b0 12 f2 d1 	call	#0xd1f2	
    de06:	4f 93       	tst.b	r15		
    de08:	0d 24       	jz	$+28     	;abs 0xde24
  }
#endif  /* !END_DEVICE */
  else
  {
    /* no, we didn't send it. send reply if it's intended for us */
    if (!memcmp(MRFI_P_DST_ADDR(frame), nwk_getMyAddress(), NET_ADDR_SIZE))
    de0a:	b0 12 26 dc 	call	#0xdc26	
    de0e:	2d 42       	mov	#4,	r13	;r2 As==10
    de10:	0e 4f       	mov	r15,	r14	
    de12:	0f 4b       	mov	r11,	r15	
    de14:	1f 53       	inc	r15		
    de16:	b0 12 da e0 	call	#0xe0da	
    de1a:	0f 93       	tst	r15		
    de1c:	01 24       	jz	$+4      	;abs 0xde20
      /* we're done with the frame. */
      rc = FHS_RELEASE;
    }
    else
    {
      rc = FHS_REPLAY;
    de1e:	2f 43       	mov	#2,	r15	;r3 As==10
  }

  (void) replyType;  /* keep compiler happy */

  return rc;
}
    de20:	3b 41       	pop	r11		
    de22:	30 41       	ret			
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, MB_APP_INFO_OS, MB_TID_OS)))
  {
    /* It's a match and it's a reply. Validate the received packet by
     * returning a 1 so it can be received by the client app.
     */
    MRFI_PostKillSem();
    de24:	b0 12 dc c3 	call	#0xc3dc	
    rc = FHS_KEEP;
    de28:	1f 43       	mov	#1,	r15	;r3 As==01
  }

  (void) replyType;  /* keep compiler happy */

  return rc;
}
    de2a:	3b 41       	pop	r11		
    de2c:	30 41       	ret			

0000de2e <nwk_poll>:
 *           SMPL_NO_AP_ADDRESS - We don't know Access Point's address
 *           SMPL_NOMEM         - no room in output frame queue
 *           SMPL_TX_CCA_FAIL   - CCA failure
 */
smplStatus_t nwk_poll(uint8_t port, uint8_t *addr)
{
    de2e:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
  uint8_t        msg[MGMT_POLL_FRAME_SIZE];
  ioctlRawSend_t send;

  msg[MB_APP_INFO_OS] = MGMT_REQ_POLL;
    de32:	d1 43 06 00 	mov.b	#1,	6(r1)	;r3 As==01, 0x0006(r1)
  msg[MB_TID_OS]      = sTid;
    de36:	d1 42 7c 02 	mov.b	&0x027c,7(r1)	;0x0007(r1)
    de3a:	07 00 
  msg[M_POLL_PORT_OS] = port;
    de3c:	c1 4f 08 00 	mov.b	r15,	8(r1)	;0x0008(r1)
  memcpy(msg+M_POLL_ADDR_OS, addr, NET_ADDR_SIZE);
    de40:	f1 4e 09 00 	mov.b	@r14+,	9(r1)	;0x0009(r1)
    de44:	f1 4e 0a 00 	mov.b	@r14+,	10(r1)	;0x000a(r1)
    de48:	f1 4e 0b 00 	mov.b	@r14+,	11(r1)	;0x000b(r1)
    de4c:	e1 4e 0c 00 	mov.b	@r14,	12(r1)	;0x000c(r1)

  /* it's OK to increment the TID here because the reply will not be
   * matched based on this number. The reply to the poll comes back
   * to the client port, not the Management port.
   */
  sTid++;
    de50:	d2 53 7c 02 	inc.b	&0x027c	

  if (!sAPAddr)
    de54:	1f 42 7e 02 	mov	&0x027e,r15	
    de58:	0f 93       	tst	r15		
    de5a:	16 24       	jz	$+46     	;abs 0xde88
    if (!sAPAddr)
    {
      return SMPL_NO_AP_ADDRESS;
    }
  }
  send.addr = (addr_t *)sAPAddr;
    de5c:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
  send.msg  = msg;
    de60:	0f 41       	mov	r1,	r15	
    de62:	3f 50 06 00 	add	#6,	r15	;#0x0006
    de66:	81 4f 02 00 	mov	r15,	2(r1)	;0x0002(r1)
  send.len  = sizeof(msg);
    de6a:	f1 40 07 00 	mov.b	#7,	4(r1)	;#0x0007, 0x0004(r1)
    de6e:	04 00 
  send.port = SMPL_PORT_MGMT;
    de70:	f1 40 06 00 	mov.b	#6,	5(r1)	;#0x0006, 0x0005(r1)
    de74:	05 00 

  return SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_WRITE, &send);
    de76:	0d 41       	mov	r1,	r13	
    de78:	3e 40 03 00 	mov	#3,	r14	;#0x0003
    de7c:	2f 43       	mov	#2,	r15	;r3 As==10
    de7e:	b0 12 04 ce 	call	#0xce04	
}
    de82:	31 50 0e 00 	add	#14,	r1	;#0x000e
    de86:	30 41       	ret			
   */
  sTid++;

  if (!sAPAddr)
  {
    sAPAddr = nwk_getAPAddress();
    de88:	b0 12 7e dc 	call	#0xdc7e	
    de8c:	82 4f 7e 02 	mov	r15,	&0x027e	
    if (!sAPAddr)
    de90:	0f 93       	tst	r15		
    de92:	e4 23       	jnz	$-54     	;abs 0xde5c
    {
      return SMPL_NO_AP_ADDRESS;
    de94:	3f 40 0b 00 	mov	#11,	r15	;#0x000b
    de98:	f4 3f       	jmp	$-22     	;abs 0xde82

0000de9a <nwk_securityInit>:
    sKey.keyL[i] = ntohl(sKey.keyL[i]);
  }

#endif  /* SMPL_SECURE */
  return;
}
    de9a:	30 41       	ret			

0000de9c <nwk_processSecurity>:
 * @return    Keep frame for application, release frame, or replay frame.
 */
fhStatus_t nwk_processSecurity(mrfiPacket_t *frame)
{
  return FHS_RELEASE;
}
    de9c:	0f 43       	clr	r15		
    de9e:	30 41       	ret			

0000dea0 <nwk_QInit>:
* @return   void
*/
void nwk_QInit(void)
{
#if SIZE_INFRAME_Q > 0
  memset(sInFrameQ, 0, sizeof(sInFrameQ));
    dea0:	3d 40 34 00 	mov	#52,	r13	;#0x0034
    dea4:	0e 43       	clr	r14		
    dea6:	3f 40 80 02 	mov	#640,	r15	;#0x0280
    deaa:	b0 12 ee e2 	call	#0xe2ee	
#endif  // SIZE_INFRAME_Q > 0
  memset(sOutFrameQ, 0, sizeof(sOutFrameQ));
    deae:	3d 40 34 00 	mov	#52,	r13	;#0x0034
    deb2:	0e 43       	clr	r14		
    deb4:	3f 40 b4 02 	mov	#692,	r15	;#0x02b4
    deb8:	b0 12 ee e2 	call	#0xe2ee	
}
    debc:	30 41       	ret			

0000debe <nwk_QadjustOrder>:
{
  frameInfo_t *pFI;
  uint8_t      i, num;
  bspIState_t  intState;

  if (INQ == which)
    debe:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    dec0:	01 24       	jz	$+4      	;abs 0xdec4
    dec2:	30 41       	ret			
/*    pFI  = sOutFrameQ; */
/*    num  = SIZE_OUTFRAME_Q; */
    return;
  }

  BSP_ENTER_CRITICAL_SECTION(intState);
    dec4:	0d 42       	mov	r2,	r13	
    dec6:	32 c2       	dint			
    dec8:	03 43       	nop			

  for (i=0; i<num; ++i, ++pFI)
  {
    if ((pFI->fi_usage != FI_AVAILABLE) && (pFI->orderStamp > stamp))
    deca:	5f 42 80 02 	mov.b	&0x0280,r15	
    dece:	4f 93       	tst.b	r15		
    ded0:	04 24       	jz	$+10     	;abs 0xdeda
    ded2:	5f 42 81 02 	mov.b	&0x0281,r15	
    ded6:	4e 9f       	cmp.b	r15,	r14	
    ded8:	10 28       	jnc	$+34     	;abs 0xdefa
    deda:	5f 42 9a 02 	mov.b	&0x029a,r15	
    dede:	4f 93       	tst.b	r15		
    dee0:	04 24       	jz	$+10     	;abs 0xdeea
    dee2:	5f 42 9b 02 	mov.b	&0x029b,r15	
    dee6:	4e 9f       	cmp.b	r15,	r14	
    dee8:	04 28       	jnc	$+10     	;abs 0xdef2
    {
      pFI->orderStamp--;
    }
  }

  BSP_EXIT_CRITICAL_SECTION(intState);
    deea:	3d f2       	and	#8,	r13	;r2 As==11
    deec:	ea 27       	jz	$-42     	;abs 0xdec2
    deee:	32 d2       	eint			
    def0:	30 41       	ret			

  for (i=0; i<num; ++i, ++pFI)
  {
    if ((pFI->fi_usage != FI_AVAILABLE) && (pFI->orderStamp > stamp))
    {
      pFI->orderStamp--;
    def2:	7f 53       	add.b	#-1,	r15	;r3 As==11
    def4:	c2 4f 9b 02 	mov.b	r15,	&0x029b	
    def8:	f8 3f       	jmp	$-14     	;abs 0xdeea
    defa:	7f 53       	add.b	#-1,	r15	;r3 As==11
    defc:	c2 4f 81 02 	mov.b	r15,	&0x0281	
    df00:	ec 3f       	jmp	$-38     	;abs 0xdeda

0000df02 <nwk_QfindSlot>:
 * output parameters
 *
 * @return      Pointer to oldest available frame in the queue
 */
frameInfo_t *nwk_QfindSlot(uint8_t which)
{
    df02:	0b 12       	push	r11		
    df04:	0a 12       	push	r10		
    df06:	09 12       	push	r9		
    df08:	08 12       	push	r8		
  frameInfo_t *pFI, *oldest= 0, *newFI = 0;
  uint8_t        i, num, newOrder = 0, orderTest;

  if (INQ == which)
    df0a:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    df0c:	23 24       	jz	$+72     	;abs 0xdf54
    pFI  = sInFrameQ;
    num  = SIZE_INFRAME_Q;
  }
  else
  {
    pFI  = sOutFrameQ;
    df0e:	3e 40 b4 02 	mov	#692,	r14	;#0x02b4
 *
 * output parameters
 *
 * @return      Pointer to oldest available frame in the queue
 */
frameInfo_t *nwk_QfindSlot(uint8_t which)
    df12:	09 4e       	mov	r14,	r9	
    df14:	39 50 34 00 	add	#52,	r9	;#0x0034
    df18:	78 40 03 00 	mov.b	#3,	r8	;#0x0003
    df1c:	4b 43       	clr.b	r11		
    df1e:	0d 43       	clr	r13		
    df20:	0a 43       	clr	r10		
  orderTest = num + 1;

  for (i=0; i<num; ++i, ++pFI)
  {
    /* if frame is available it's a candidate. */
    if (pFI->fi_usage != FI_AVAILABLE)
    df22:	6c 4e       	mov.b	@r14,	r12	
    df24:	4c 93       	tst.b	r12		
    df26:	12 24       	jz	$+38     	;abs 0xdf4c
    {
      if (INQ == which)  /* TODO: do cast-out for Tx as well */
    df28:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    df2a:	17 24       	jz	$+48     	;abs 0xdf5a
    num  = SIZE_OUTFRAME_Q;
  }

  orderTest = num + 1;

  for (i=0; i<num; ++i, ++pFI)
    df2c:	3e 50 1a 00 	add	#26,	r14	;#0x001a
    df30:	0e 99       	cmp	r9,	r14	
    df32:	f7 23       	jnz	$-16     	;abs 0xdf22
      newFI = pFI;
    }
  }

  /* did we find anything? */
  if (!newFI)
    df34:	0d 93       	tst	r13		
    df36:	1c 24       	jz	$+58     	;abs 0xdf70
    newFI->orderStamp = i;
  }
  else
  {
    /* mark the available slot. */
    newFI->orderStamp = ++newOrder;
    df38:	5b 53       	inc.b	r11		
    df3a:	cd 4b 01 00 	mov.b	r11,	1(r13)	;0x0001(r13)
    df3e:	0e 4d       	mov	r13,	r14	
  }

  return newFI;
}
    df40:	0f 4e       	mov	r14,	r15	
    df42:	38 41       	pop	r8		
    df44:	39 41       	pop	r9		
    df46:	3a 41       	pop	r10		
    df48:	3b 41       	pop	r11		
    df4a:	30 41       	ret			
        }
      }
    }
    else
    {
      if (OUTQ == which)  /* TODO: do cast-out for Tx as well */
    df4c:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    df4e:	f8 27       	jz	$-14     	;abs 0xdf40
    df50:	0d 4e       	mov	r14,	r13	
    df52:	ec 3f       	jmp	$-38     	;abs 0xdf2c
  frameInfo_t *pFI, *oldest= 0, *newFI = 0;
  uint8_t        i, num, newOrder = 0, orderTest;

  if (INQ == which)
  {
    pFI  = sInFrameQ;
    df54:	3e 40 80 02 	mov	#640,	r14	;#0x0280
    df58:	dc 3f       	jmp	$-70     	;abs 0xdf12
      {

        /* need to know the number of occupied slots so we know the age value
         * for the unoccupied slot (if there is one).
         */
        newOrder++;
    df5a:	5b 53       	inc.b	r11		

        /* make sure nwk_retrieveFrame() is not processing this frame */
        if (FI_INUSE_TRANSITION == pFI->fi_usage)
    df5c:	6c 4e       	mov.b	@r14,	r12	
    df5e:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    df60:	e5 27       	jz	$-52     	;abs 0xdf2c
        {
          continue;
        }
        /* is this frame older than any we've seen? */
        if (orderTest > pFI->orderStamp)
    df62:	5c 4e 01 00 	mov.b	1(r14),	r12	;0x0001(r14)
    df66:	4c 98       	cmp.b	r8,	r12	
    df68:	e1 2f       	jc	$-60     	;abs 0xdf2c
    df6a:	48 4c       	mov.b	r12,	r8	
    df6c:	0a 4e       	mov	r14,	r10	
    df6e:	de 3f       	jmp	$-66     	;abs 0xdf2c

  /* did we find anything? */
  if (!newFI)
  {
    /* queue was full. cast-out happens here...unless... */
    if (!oldest)
    df70:	0a 93       	tst	r10		
    df72:	0d 24       	jz	$+28     	;abs 0xdf8e
       * the frames are in transition when the Rx interrupt occurs.
       */
      return (frameInfo_t *)0;
    }
    newFI = oldest;
    nwk_QadjustOrder(which, newFI->orderStamp);
    df74:	5e 4a 01 00 	mov.b	1(r10),	r14	;0x0001(r10)
    df78:	b0 12 be de 	call	#0xdebe	
    newFI->orderStamp = i;
    df7c:	ea 43 01 00 	mov.b	#2,	1(r10)	;r3 As==10, 0x0001(r10)
    df80:	0e 4a       	mov	r10,	r14	
    /* mark the available slot. */
    newFI->orderStamp = ++newOrder;
  }

  return newFI;
}
    df82:	0f 4e       	mov	r14,	r15	
    df84:	38 41       	pop	r8		
    df86:	39 41       	pop	r9		
    df88:	3a 41       	pop	r10		
    df8a:	3b 41       	pop	r11		
    df8c:	30 41       	ret			
    if (!oldest)
    {
      /* This can happen if the queue is only of size 1 or 2 and all
       * the frames are in transition when the Rx interrupt occurs.
       */
      return (frameInfo_t *)0;
    df8e:	0e 43       	clr	r14		
    df90:	d7 3f       	jmp	$-80     	;abs 0xdf40

0000df92 <nwk_QfindOldest>:
 *
 * @return      Pointer to frame that is the oldsest on the requested port, or
 *              0 if there are none.
 */
frameInfo_t *nwk_QfindOldest(uint8_t which, rcvContext_t *rcv, uint8_t fi_usage)
{
    df92:	0b 12       	push	r11		
    df94:	0a 12       	push	r10		
    df96:	09 12       	push	r9		
    df98:	08 12       	push	r8		
    df9a:	07 12       	push	r7		
    df9c:	06 12       	push	r6		
    df9e:	05 12       	push	r5		
    dfa0:	04 12       	push	r4		
    dfa2:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    dfa6:	09 4e       	mov	r14,	r9	
  bspIState_t  intState;
  frameInfo_t *fPtr = 0, *wPtr;
  connInfo_t  *pCInfo = 0;
  uint8_t     *pAddr1 = 0, *pAddr2 = 0, *pAddr3 = 0;

  if (INQ == which)
    dfa8:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    dfaa:	40 20       	jnz	$+130    	;abs 0xe02c
/*    pFI  = sOutFrameQ; */
/*    num  = SIZE_OUTFRAME_Q; */
    return 0;
  }

  if (RCV_APP_LID == rcv->type)
    dfac:	2f 4e       	mov	@r14,	r15	
    dfae:	1f 93       	cmp	#1,	r15	;r3 As==01
    dfb0:	63 24       	jz	$+200    	;abs 0xe078
      return (frameInfo_t *)0;
    }
    port   = pCInfo->portRx;
    pAddr2 = pCInfo->peerAddr;
  }
  else if (RCV_NWK_PORT == rcv->type)
    dfb2:	0f 93       	tst	r15		
    dfb4:	3b 20       	jnz	$+120    	;abs 0xe02c
  {
    port = rcv->t.port;
    dfb6:	56 4e 02 00 	mov.b	2(r14),	r6	;0x0002(r14)
  uint8_t      i, oldest, num, port;
  uint8_t      uType, addr12Compare;
  bspIState_t  intState;
  frameInfo_t *fPtr = 0, *wPtr;
  connInfo_t  *pCInfo = 0;
  uint8_t     *pAddr1 = 0, *pAddr2 = 0, *pAddr3 = 0;
    dfba:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00, 0x0002(r1)
{
  uint8_t      i, oldest, num, port;
  uint8_t      uType, addr12Compare;
  bspIState_t  intState;
  frameInfo_t *fPtr = 0, *wPtr;
  connInfo_t  *pCInfo = 0;
    dfbe:	0c 43       	clr	r12		
  else
  {
    return (frameInfo_t *)0;
  }

  uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;
    dfc0:	5d 93       	cmp.b	#1,	r13	;r3 As==01
    dfc2:	36 24       	jz	$+110    	;abs 0xe030
    dfc4:	77 40 03 00 	mov.b	#3,	r7	;#0x0003
  uint8_t      i, oldest, num, port;
  uint8_t      uType, addr12Compare;
  bspIState_t  intState;
  frameInfo_t *fPtr = 0, *wPtr;
  connInfo_t  *pCInfo = 0;
  uint8_t     *pAddr1 = 0, *pAddr2 = 0, *pAddr3 = 0;
    dfc8:	04 43       	clr	r4		

  if (INQ == which)
  {
    wPtr   = sInFrameQ;
    dfca:	3a 40 80 02 	mov	#640,	r10	;#0x0280
frameInfo_t *nwk_QfindOldest(uint8_t which, rcvContext_t *rcv, uint8_t fi_usage)
{
  uint8_t      i, oldest, num, port;
  uint8_t      uType, addr12Compare;
  bspIState_t  intState;
  frameInfo_t *fPtr = 0, *wPtr;
    dfce:	08 43       	clr	r8		

  if (INQ == which)
  {
    wPtr   = sInFrameQ;
    num    = SIZE_INFRAME_Q;
    oldest = SIZE_INFRAME_Q+1;
    dfd0:	f1 40 03 00 	mov.b	#3,	0(r1)	;#0x0003, 0x0000(r1)
    dfd4:	00 00 
    {
      wPtr->fi_usage = FI_INUSE_TRANSITION;

      BSP_EXIT_CRITICAL_SECTION(intState);  /* release hold */
      /* message sent to this device? */
      if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&wPtr->mrfiPkt), F_PORT_OS) == port)
    dfd6:	45 46       	mov.b	r6,	r5	
        if (RCV_APP_LID == rcv->type)
        {
          if (SMPL_PORT_USER_BCAST == port)
          {
            /* guarantee a match... */
            pAddr1 = pCInfo->peerAddr;
    dfd8:	2c 53       	incd	r12		
  uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;

  for (i=0; i<num; ++i, ++wPtr)
  {

    BSP_ENTER_CRITICAL_SECTION(intState);   /* protect the frame states */
    dfda:	0d 42       	mov	r2,	r13	
    dfdc:	3d f2       	and	#8,	r13	;r2 As==11
    dfde:	32 c2       	dint			
    dfe0:	03 43       	nop			

    /* only check entries in use and waiting for this port */
    if (uType == wPtr->fi_usage)
    dfe2:	6b 4a       	mov.b	@r10,	r11	
    dfe4:	47 9b       	cmp.b	r11,	r7	
    dfe6:	13 24       	jz	$+40     	;abs 0xe00e
        wPtr->fi_usage = uType;
      }
    }
    else
    {
      BSP_EXIT_CRITICAL_SECTION(intState);
    dfe8:	0d 93       	tst	r13		
    dfea:	1e 20       	jnz	$+62     	;abs 0xe028
    return (frameInfo_t *)0;
  }

  uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;

  for (i=0; i<num; ++i, ++wPtr)
    dfec:	3a 50 1a 00 	add	#26,	r10	;#0x001a
    dff0:	3a 90 b4 02 	cmp	#692,	r10	;#0x02b4
    dff4:	f2 23       	jnz	$-26     	;abs 0xdfda
      BSP_EXIT_CRITICAL_SECTION(intState);
    }
  }

  return fPtr;
}
    dff6:	0f 48       	mov	r8,	r15	
    dff8:	31 50 06 00 	add	#6,	r1	;#0x0006
    dffc:	34 41       	pop	r4		
    dffe:	35 41       	pop	r5		
    e000:	36 41       	pop	r6		
    e002:	37 41       	pop	r7		
    e004:	38 41       	pop	r8		
    e006:	39 41       	pop	r9		
    e008:	3a 41       	pop	r10		
    e00a:	3b 41       	pop	r11		
    e00c:	30 41       	ret			
    BSP_ENTER_CRITICAL_SECTION(intState);   /* protect the frame states */

    /* only check entries in use and waiting for this port */
    if (uType == wPtr->fi_usage)
    {
      wPtr->fi_usage = FI_INUSE_TRANSITION;
    e00e:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10, 0x0000(r10)

      BSP_EXIT_CRITICAL_SECTION(intState);  /* release hold */
    e012:	0d 93       	tst	r13		
    e014:	0f 20       	jnz	$+32     	;abs 0xe034
      /* message sent to this device? */
      if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&wPtr->mrfiPkt), F_PORT_OS) == port)
    e016:	5d 4a 0b 00 	mov.b	11(r10),r13	;0x000b(r10)
    e01a:	3d f0 3f 00 	and	#63,	r13	;#0x003f
    e01e:	0d 95       	cmp	r5,	r13	
    e020:	10 24       	jz	$+34     	;abs 0xe042
        }
      }
      else
      {
        /* wrong port. restore state */
        wPtr->fi_usage = uType;
    e022:	ca 47 00 00 	mov.b	r7,	0(r10)	;0x0000(r10)
    e026:	e2 3f       	jmp	$-58     	;abs 0xdfec
      }
    }
    else
    {
      BSP_EXIT_CRITICAL_SECTION(intState);
    e028:	32 d2       	eint			
    e02a:	e0 3f       	jmp	$-62     	;abs 0xdfec
    pAddr3 = MRFI_P_PAYLOAD(rcv->t.pkt)+F_APP_PAYLOAD_OS+M_POLL_ADDR_OS;
  }
#endif
  else
  {
    return (frameInfo_t *)0;
    e02c:	08 43       	clr	r8		
    e02e:	e3 3f       	jmp	$-56     	;abs 0xdff6
  }

  uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;
    e030:	57 43       	mov.b	#1,	r7	;r3 As==01
    e032:	ca 3f       	jmp	$-106    	;abs 0xdfc8
    /* only check entries in use and waiting for this port */
    if (uType == wPtr->fi_usage)
    {
      wPtr->fi_usage = FI_INUSE_TRANSITION;

      BSP_EXIT_CRITICAL_SECTION(intState);  /* release hold */
    e034:	32 d2       	eint			
      /* message sent to this device? */
      if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&wPtr->mrfiPkt), F_PORT_OS) == port)
    e036:	5d 4a 0b 00 	mov.b	11(r10),r13	;0x000b(r10)
    e03a:	3d f0 3f 00 	and	#63,	r13	;#0x003f
    e03e:	0d 95       	cmp	r5,	r13	
    e040:	f0 23       	jnz	$-30     	;abs 0xe022
        /* Port matches. If the port of interest is a NWK applicaiton we're a
         * match...the NWK applications are not connection-based. If it is a
         * NWK application we need to check the source address for disambiguation.
         * Also need to check source address if it's a raw frame lookup (S&F frame)
         */
        if (RCV_APP_LID == rcv->type)
    e042:	2b 49       	mov	@r9,	r11	
    e044:	1b 93       	cmp	#1,	r11	;r3 As==01
    e046:	29 24       	jz	$+84     	;abs 0xe09a
        {
          pAddr1 = MRFI_P_DST_ADDR(&wPtr->mrfiPkt);
        }
#endif

        addr12Compare = memcmp(pAddr1, pAddr2, NET_ADDR_SIZE);
    e048:	2d 42       	mov	#4,	r13	;r2 As==10
    e04a:	1e 41 02 00 	mov	2(r1),	r14	;0x0002(r1)
    e04e:	0f 44       	mov	r4,	r15	
    e050:	81 4c 04 00 	mov	r12,	4(r1)	;0x0004(r1)
    e054:	b0 12 da e0 	call	#0xe0da	
        if (  (RCV_NWK_PORT == rcv->type) ||
    e058:	1c 41 04 00 	mov	4(r1),	r12	;0x0004(r1)
    e05c:	0b 93       	tst	r11		
    e05e:	31 20       	jnz	$+100    	;abs 0xe0c2
              (!pAddr3 && !addr12Compare) ||
              (pAddr3 && !memcmp(pAddr3, MRFI_P_SRC_ADDR(&wPtr->mrfiPkt), NET_ADDR_SIZE))
           )
        {
          if (wPtr->orderStamp < oldest)
    e060:	5d 4a 01 00 	mov.b	1(r10),	r13	;0x0001(r10)
    e064:	6d 91       	cmp.b	@r1,	r13	
    e066:	dd 2f       	jc	$-68     	;abs 0xe022
          {
            if (fPtr)
    e068:	08 93       	tst	r8		
    e06a:	02 24       	jz	$+6      	;abs 0xe070
            {
              /* restore previous oldest one */
              fPtr->fi_usage = uType;
    e06c:	c8 47 00 00 	mov.b	r7,	0(r8)	;0x0000(r8)
            }
            oldest = wPtr->orderStamp;
            fPtr   = wPtr;
            continue;
    e070:	08 4a       	mov	r10,	r8	
    e072:	c1 4d 00 00 	mov.b	r13,	0(r1)	;0x0000(r1)
    e076:	ba 3f       	jmp	$-138    	;abs 0xdfec
    return 0;
  }

  if (RCV_APP_LID == rcv->type)
  {
    pCInfo = nwk_getConnInfo(rcv->t.lid);
    e078:	5f 4e 02 00 	mov.b	2(r14),	r15	;0x0002(r14)
    e07c:	81 4d 04 00 	mov	r13,	4(r1)	;0x0004(r1)
    e080:	b0 12 b8 cf 	call	#0xcfb8	
    e084:	0c 4f       	mov	r15,	r12	
    if (!pCInfo)
    e086:	1d 41 04 00 	mov	4(r1),	r13	;0x0004(r1)
    e08a:	0f 93       	tst	r15		
    e08c:	cf 27       	jz	$-96     	;abs 0xe02c
    {
      return (frameInfo_t *)0;
    }
    port   = pCInfo->portRx;
    e08e:	56 4f 08 00 	mov.b	8(r15),	r6	;0x0008(r15)
    pAddr2 = pCInfo->peerAddr;
    e092:	2f 53       	incd	r15		
    e094:	81 4f 02 00 	mov	r15,	2(r1)	;0x0002(r1)
    e098:	93 3f       	jmp	$-216    	;abs 0xdfc0
         * NWK application we need to check the source address for disambiguation.
         * Also need to check source address if it's a raw frame lookup (S&F frame)
         */
        if (RCV_APP_LID == rcv->type)
        {
          if (SMPL_PORT_USER_BCAST == port)
    e09a:	76 90 3f 00 	cmp.b	#63,	r6	;#0x003f
    e09e:	13 24       	jz	$+40     	;abs 0xe0c6
            /* guarantee a match... */
            pAddr1 = pCInfo->peerAddr;
          }
          else
          {
            pAddr1 = MRFI_P_SRC_ADDR(&wPtr->mrfiPkt);
    e0a0:	04 4a       	mov	r10,	r4	
    e0a2:	34 50 07 00 	add	#7,	r4	;#0x0007
        {
          pAddr1 = MRFI_P_DST_ADDR(&wPtr->mrfiPkt);
        }
#endif

        addr12Compare = memcmp(pAddr1, pAddr2, NET_ADDR_SIZE);
    e0a6:	2d 42       	mov	#4,	r13	;r2 As==10
    e0a8:	1e 41 02 00 	mov	2(r1),	r14	;0x0002(r1)
    e0ac:	0f 44       	mov	r4,	r15	
    e0ae:	81 4c 04 00 	mov	r12,	4(r1)	;0x0004(r1)
    e0b2:	b0 12 da e0 	call	#0xe0da	
    e0b6:	4d 4f       	mov.b	r15,	r13	
    e0b8:	1c 41 04 00 	mov	4(r1),	r12	;0x0004(r1)
        if (  (RCV_NWK_PORT == rcv->type) ||
              (!pAddr3 && !addr12Compare) ||
    e0bc:	4d 93       	tst.b	r13		
    e0be:	b1 23       	jnz	$-156    	;abs 0xe022
    e0c0:	cf 3f       	jmp	$-96     	;abs 0xe060
        {
          pAddr1 = MRFI_P_DST_ADDR(&wPtr->mrfiPkt);
        }
#endif

        addr12Compare = memcmp(pAddr1, pAddr2, NET_ADDR_SIZE);
    e0c2:	4d 4f       	mov.b	r15,	r13	
    e0c4:	fb 3f       	jmp	$-8      	;abs 0xe0bc
        if (RCV_APP_LID == rcv->type)
        {
          if (SMPL_PORT_USER_BCAST == port)
          {
            /* guarantee a match... */
            pAddr1 = pCInfo->peerAddr;
    e0c6:	04 4c       	mov	r12,	r4	
    e0c8:	ee 3f       	jmp	$-34     	;abs 0xe0a6

0000e0ca <nwk_getQ>:
 *
 * @return      Pointer to frame queue
 */
frameInfo_t *nwk_getQ(uint8_t which)
{
  return (INQ == which) ? sInFrameQ : sOutFrameQ;
    e0ca:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    e0cc:	03 24       	jz	$+8      	;abs 0xe0d4
    e0ce:	3f 40 b4 02 	mov	#692,	r15	;#0x02b4
}
    e0d2:	30 41       	ret			
 *
 * @return      Pointer to frame queue
 */
frameInfo_t *nwk_getQ(uint8_t which)
{
  return (INQ == which) ? sInFrameQ : sOutFrameQ;
    e0d4:	3f 40 80 02 	mov	#640,	r15	;#0x0280
    e0d8:	30 41       	ret			

0000e0da <memcmp>:

int
memcmp(s1, s2, n)
const void *s1, *s2;
size_t n;
{
    e0da:	0b 12       	push	r11		
    if (n != 0)
    e0dc:	0d 93       	tst	r13		
    e0de:	0a 24       	jz	$+22     	;abs 0xe0f4
    {
        register const unsigned char *p1 = s1, *p2 = s2;

        do
        {
            if (*p1++ != *p2++)
    e0e0:	7b 4f       	mov.b	@r15+,	r11	
    e0e2:	7c 4e       	mov.b	@r14+,	r12	
    e0e4:	4b 9c       	cmp.b	r12,	r11	
    e0e6:	04 24       	jz	$+10     	;abs 0xe0f0
                return (*--p1 - *--p2);
    e0e8:	4f 4b       	mov.b	r11,	r15	
    e0ea:	4e 4c       	mov.b	r12,	r14	
    e0ec:	0f 8e       	sub	r14,	r15	
    e0ee:	03 3c       	jmp	$+8      	;abs 0xe0f6
        }
        while (--n != 0);
    e0f0:	3d 53       	add	#-1,	r13	;r3 As==11
    e0f2:	f4 3f       	jmp	$-22     	;abs 0xe0dc
    }
    return (0);
    e0f4:	0f 43       	clr	r15		
}
    e0f6:	3b 41       	pop	r11		
    e0f8:	30 41       	ret			

0000e0fa <memcpy>:
#endif
#endif
void *dst0;
const void *src0;
register size_t length;
{
    e0fa:	0b 12       	push	r11		
    e0fc:	0a 12       	push	r10		
    e0fe:	09 12       	push	r9		
    e100:	08 12       	push	r8		
    e102:	07 12       	push	r7		
    register char *dst = dst0;
    register const char *src = src0;
    register size_t t;

    if (length == 0 || dst == src)		/* nothing to do */
    e104:	0d 93       	tst	r13		
    e106:	70 24       	jz	$+226    	;abs 0xe1e8
    e108:	0f 9e       	cmp	r14,	r15	
    e10a:	6e 24       	jz	$+222    	;abs 0xe1e8
     * Macros: loop-t-times; and loop-t-times, t>0
     */
#define	TLOOP(s) if (t) TLOOP1(s)
#define	TLOOP1(s) do { s; } while (--t)

    if ((unsigned int)dst < (unsigned int)src)
    e10c:	34 2c       	jc	$+106    	;abs 0xe176
    {
        /*
         * Copy forward.
         */
        t = (int)src;	/* only need low bits */
        if ((t | (int)dst) & wmask)
    e10e:	0c 4e       	mov	r14,	r12	
    e110:	0c df       	bis	r15,	r12	
    e112:	1c f3       	and	#1,	r12	;r3 As==01
    e114:	1b 24       	jz	$+56     	;abs 0xe14c
        {
            /*
             * Try to align operands.  This cannot be done
             * unless the low bits match.
             */
            if ((t ^ (int)dst) & wmask || length < wsize)
    e116:	0c 4e       	mov	r14,	r12	
    e118:	0c ef       	xor	r15,	r12	
    e11a:	1c f3       	and	#1,	r12	;r3 As==01
    e11c:	07 20       	jnz	$+16     	;abs 0xe12c
    e11e:	2d 93       	cmp	#2,	r13	;r3 As==10
    e120:	07 28       	jnc	$+16     	;abs 0xe130
                t = length;
            else
                t = wsize - (t & wmask);
    e122:	0b 4e       	mov	r14,	r11	
    e124:	1b f3       	and	#1,	r11	;r3 As==01
    e126:	2c 43       	mov	#2,	r12	;r3 As==10
    e128:	0c 8b       	sub	r11,	r12	
    e12a:	03 3c       	jmp	$+8      	;abs 0xe132
        {
            /*
             * Try to align operands.  This cannot be done
             * unless the low bits match.
             */
            if ((t ^ (int)dst) & wmask || length < wsize)
    e12c:	0c 4d       	mov	r13,	r12	
    e12e:	01 3c       	jmp	$+4      	;abs 0xe132
    e130:	1c 43       	mov	#1,	r12	;r3 As==01
                t = length;
            else
                t = wsize - (t & wmask);
            length -= t;
    e132:	0d 8c       	sub	r12,	r13	
    e134:	0a 4c       	mov	r12,	r10	
    e136:	09 4e       	mov	r14,	r9	
    e138:	0b 4f       	mov	r15,	r11	
            TLOOP1(*dst++ = *src++);
    e13a:	fb 49 00 00 	mov.b	@r9+,	0(r11)	;0x0000(r11)
    e13e:	1b 53       	inc	r11		
    e140:	3a 53       	add	#-1,	r10	;r3 As==11
    e142:	fb 23       	jnz	$-8      	;abs 0xe13a
    e144:	0a 4f       	mov	r15,	r10	
    e146:	0a 5c       	add	r12,	r10	
    e148:	0e 5c       	add	r12,	r14	
    e14a:	01 3c       	jmp	$+4      	;abs 0xe14e
    {
        /*
         * Copy forward.
         */
        t = (int)src;	/* only need low bits */
        if ((t | (int)dst) & wmask)
    e14c:	0a 4f       	mov	r15,	r10	
            TLOOP1(*dst++ = *src++);
        }
        /*
         * Copy whole words, then mop up any trailing bytes.
         */
        t = length / wsize;
    e14e:	0b 4d       	mov	r13,	r11	
    e150:	12 c3       	clrc			
    e152:	0b 10       	rrc	r11		
        TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
    e154:	0b 24       	jz	$+24     	;abs 0xe16c
    e156:	09 4b       	mov	r11,	r9	
    e158:	08 4e       	mov	r14,	r8	
    e15a:	0c 4a       	mov	r10,	r12	
    e15c:	bc 48 00 00 	mov	@r8+,	0(r12)	;0x0000(r12)
    e160:	2c 53       	incd	r12		
    e162:	39 53       	add	#-1,	r9	;r3 As==11
    e164:	fb 23       	jnz	$-8      	;abs 0xe15c
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 */
#ifdef MEMCOPY
void *
memcpy(dst0, src0, length)
    e166:	0b 5b       	rla	r11		
    e168:	0e 5b       	add	r11,	r14	
    e16a:	0a 5b       	add	r11,	r10	
        /*
         * Copy whole words, then mop up any trailing bytes.
         */
        t = length / wsize;
        TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
        t = length & wmask;
    e16c:	1d f3       	and	#1,	r13	;r3 As==01
        TLOOP(*dst++ = *src++);
    e16e:	3c 24       	jz	$+122    	;abs 0xe1e8
    e170:	ea 4e 00 00 	mov.b	@r14,	0(r10)	;0x0000(r10)
    e174:	39 3c       	jmp	$+116    	;abs 0xe1e8
        /*
         * Copy backwards.  Otherwise essentially the same.
         * Alignment works as before, except that it takes
         * (t&wmask) bytes to align, not wsize-(t&wmask).
         */
        src += length;
    e176:	0e 5d       	add	r13,	r14	
        dst += length;
    e178:	0c 4f       	mov	r15,	r12	
    e17a:	0c 5d       	add	r13,	r12	
        t = (int)src;
        if ((t | (int)dst) & wmask)
    e17c:	0b 4c       	mov	r12,	r11	
    e17e:	0b de       	bis	r14,	r11	
    e180:	1b f3       	and	#1,	r11	;r3 As==01
    e182:	1b 24       	jz	$+56     	;abs 0xe1ba
        {
            if ((t ^ (int)dst) & wmask || length <= wsize)
    e184:	0b 4c       	mov	r12,	r11	
    e186:	0b ee       	xor	r14,	r11	
    e188:	1b f3       	and	#1,	r11	;r3 As==01
    e18a:	06 20       	jnz	$+14     	;abs 0xe198
    e18c:	3d 90 03 00 	cmp	#3,	r13	;#0x0003
    e190:	03 28       	jnc	$+8      	;abs 0xe198
                t = length;
            else
                t &= wmask;
    e192:	0b 4e       	mov	r14,	r11	
    e194:	1b f3       	and	#1,	r11	;r3 As==01
    e196:	01 3c       	jmp	$+4      	;abs 0xe19a
        src += length;
        dst += length;
        t = (int)src;
        if ((t | (int)dst) & wmask)
        {
            if ((t ^ (int)dst) & wmask || length <= wsize)
    e198:	0b 4d       	mov	r13,	r11	
                t = length;
            else
                t &= wmask;
            length -= t;
    e19a:	0d 8b       	sub	r11,	r13	
        /*
         * Copy backwards.  Otherwise essentially the same.
         * Alignment works as before, except that it takes
         * (t&wmask) bytes to align, not wsize-(t&wmask).
         */
        src += length;
    e19c:	09 4e       	mov	r14,	r9	
        dst += length;
    e19e:	0a 4c       	mov	r12,	r10	
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 */
#ifdef MEMCOPY
void *
memcpy(dst0, src0, length)
    e1a0:	08 4b       	mov	r11,	r8	
    e1a2:	08 8c       	sub	r12,	r8	
            if ((t ^ (int)dst) & wmask || length <= wsize)
                t = length;
            else
                t &= wmask;
            length -= t;
            TLOOP1(*--dst = *--src);
    e1a4:	3a 53       	add	#-1,	r10	;r3 As==11
    e1a6:	39 53       	add	#-1,	r9	;r3 As==11
    e1a8:	ea 49 00 00 	mov.b	@r9,	0(r10)	;0x0000(r10)
    e1ac:	07 4a       	mov	r10,	r7	
    e1ae:	07 58       	add	r8,	r7	
    e1b0:	f9 23       	jnz	$-12     	;abs 0xe1a4
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 */
#ifdef MEMCOPY
void *
memcpy(dst0, src0, length)
    e1b2:	3b e3       	inv	r11		
    e1b4:	1b 53       	inc	r11		
    e1b6:	0c 5b       	add	r11,	r12	
    e1b8:	0e 5b       	add	r11,	r14	
            else
                t &= wmask;
            length -= t;
            TLOOP1(*--dst = *--src);
        }
        t = length / wsize;
    e1ba:	0b 4d       	mov	r13,	r11	
    e1bc:	12 c3       	clrc			
    e1be:	0b 10       	rrc	r11		
        TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
    e1c0:	0e 24       	jz	$+30     	;abs 0xe1de
    e1c2:	0a 4b       	mov	r11,	r10	
    e1c4:	08 4e       	mov	r14,	r8	
    e1c6:	09 4c       	mov	r12,	r9	
    e1c8:	28 83       	decd	r8		
    e1ca:	29 83       	decd	r9		
    e1cc:	a9 48 00 00 	mov	@r8,	0(r9)	;0x0000(r9)
    e1d0:	3a 53       	add	#-1,	r10	;r3 As==11
    e1d2:	fa 23       	jnz	$-10     	;abs 0xe1c8
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 */
#ifdef MEMCOPY
void *
memcpy(dst0, src0, length)
    e1d4:	0a 8b       	sub	r11,	r10	
    e1d6:	0b 4a       	mov	r10,	r11	
    e1d8:	0b 5b       	rla	r11		
    e1da:	0e 5b       	add	r11,	r14	
    e1dc:	0c 5b       	add	r11,	r12	
            length -= t;
            TLOOP1(*--dst = *--src);
        }
        t = length / wsize;
        TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
        t = length & wmask;
    e1de:	1d f3       	and	#1,	r13	;r3 As==01
        TLOOP(*--dst = *--src);
    e1e0:	03 24       	jz	$+8      	;abs 0xe1e8
    e1e2:	dc 4e ff ff 	mov.b	-1(r14),-1(r12)	;0xffff(r14), 0xffff(r12)
    e1e6:	ff ff 
#if defined(MEMCOPY) || defined(MEMMOVE)
    return (dst0);
#else
    return;
#endif
}
    e1e8:	37 41       	pop	r7		
    e1ea:	38 41       	pop	r8		
    e1ec:	39 41       	pop	r9		
    e1ee:	3a 41       	pop	r10		
    e1f0:	3b 41       	pop	r11		
    e1f2:	30 41       	ret			

0000e1f4 <memmove>:
#endif
#endif
void *dst0;
const void *src0;
register size_t length;
{
    e1f4:	0b 12       	push	r11		
    e1f6:	0a 12       	push	r10		
    e1f8:	09 12       	push	r9		
    e1fa:	08 12       	push	r8		
    e1fc:	07 12       	push	r7		
    register char *dst = dst0;
    register const char *src = src0;
    register size_t t;

    if (length == 0 || dst == src)		/* nothing to do */
    e1fe:	0d 93       	tst	r13		
    e200:	70 24       	jz	$+226    	;abs 0xe2e2
    e202:	0f 9e       	cmp	r14,	r15	
    e204:	6e 24       	jz	$+222    	;abs 0xe2e2
     * Macros: loop-t-times; and loop-t-times, t>0
     */
#define	TLOOP(s) if (t) TLOOP1(s)
#define	TLOOP1(s) do { s; } while (--t)

    if ((unsigned int)dst < (unsigned int)src)
    e206:	34 2c       	jc	$+106    	;abs 0xe270
    {
        /*
         * Copy forward.
         */
        t = (int)src;	/* only need low bits */
        if ((t | (int)dst) & wmask)
    e208:	0c 4e       	mov	r14,	r12	
    e20a:	0c df       	bis	r15,	r12	
    e20c:	1c f3       	and	#1,	r12	;r3 As==01
    e20e:	1b 24       	jz	$+56     	;abs 0xe246
        {
            /*
             * Try to align operands.  This cannot be done
             * unless the low bits match.
             */
            if ((t ^ (int)dst) & wmask || length < wsize)
    e210:	0c 4e       	mov	r14,	r12	
    e212:	0c ef       	xor	r15,	r12	
    e214:	1c f3       	and	#1,	r12	;r3 As==01
    e216:	07 20       	jnz	$+16     	;abs 0xe226
    e218:	2d 93       	cmp	#2,	r13	;r3 As==10
    e21a:	07 28       	jnc	$+16     	;abs 0xe22a
                t = length;
            else
                t = wsize - (t & wmask);
    e21c:	0b 4e       	mov	r14,	r11	
    e21e:	1b f3       	and	#1,	r11	;r3 As==01
    e220:	2c 43       	mov	#2,	r12	;r3 As==10
    e222:	0c 8b       	sub	r11,	r12	
    e224:	03 3c       	jmp	$+8      	;abs 0xe22c
        {
            /*
             * Try to align operands.  This cannot be done
             * unless the low bits match.
             */
            if ((t ^ (int)dst) & wmask || length < wsize)
    e226:	0c 4d       	mov	r13,	r12	
    e228:	01 3c       	jmp	$+4      	;abs 0xe22c
    e22a:	1c 43       	mov	#1,	r12	;r3 As==01
                t = length;
            else
                t = wsize - (t & wmask);
            length -= t;
    e22c:	0d 8c       	sub	r12,	r13	
    e22e:	0a 4c       	mov	r12,	r10	
    e230:	09 4e       	mov	r14,	r9	
    e232:	0b 4f       	mov	r15,	r11	
            TLOOP1(*dst++ = *src++);
    e234:	fb 49 00 00 	mov.b	@r9+,	0(r11)	;0x0000(r11)
    e238:	1b 53       	inc	r11		
    e23a:	3a 53       	add	#-1,	r10	;r3 As==11
    e23c:	fb 23       	jnz	$-8      	;abs 0xe234
    e23e:	0a 4f       	mov	r15,	r10	
    e240:	0a 5c       	add	r12,	r10	
    e242:	0e 5c       	add	r12,	r14	
    e244:	01 3c       	jmp	$+4      	;abs 0xe248
    {
        /*
         * Copy forward.
         */
        t = (int)src;	/* only need low bits */
        if ((t | (int)dst) & wmask)
    e246:	0a 4f       	mov	r15,	r10	
            TLOOP1(*dst++ = *src++);
        }
        /*
         * Copy whole words, then mop up any trailing bytes.
         */
        t = length / wsize;
    e248:	0b 4d       	mov	r13,	r11	
    e24a:	12 c3       	clrc			
    e24c:	0b 10       	rrc	r11		
        TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
    e24e:	0b 24       	jz	$+24     	;abs 0xe266
    e250:	09 4b       	mov	r11,	r9	
    e252:	08 4e       	mov	r14,	r8	
    e254:	0c 4a       	mov	r10,	r12	
    e256:	bc 48 00 00 	mov	@r8+,	0(r12)	;0x0000(r12)
    e25a:	2c 53       	incd	r12		
    e25c:	39 53       	add	#-1,	r9	;r3 As==11
    e25e:	fb 23       	jnz	$-8      	;abs 0xe256
void *
memcpy(dst0, src0, length)
#else
#ifdef MEMMOVE
void *
memmove(dst0, src0, length)
    e260:	0b 5b       	rla	r11		
    e262:	0e 5b       	add	r11,	r14	
    e264:	0a 5b       	add	r11,	r10	
        /*
         * Copy whole words, then mop up any trailing bytes.
         */
        t = length / wsize;
        TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
        t = length & wmask;
    e266:	1d f3       	and	#1,	r13	;r3 As==01
        TLOOP(*dst++ = *src++);
    e268:	3c 24       	jz	$+122    	;abs 0xe2e2
    e26a:	ea 4e 00 00 	mov.b	@r14,	0(r10)	;0x0000(r10)
    e26e:	39 3c       	jmp	$+116    	;abs 0xe2e2
        /*
         * Copy backwards.  Otherwise essentially the same.
         * Alignment works as before, except that it takes
         * (t&wmask) bytes to align, not wsize-(t&wmask).
         */
        src += length;
    e270:	0e 5d       	add	r13,	r14	
        dst += length;
    e272:	0c 4f       	mov	r15,	r12	
    e274:	0c 5d       	add	r13,	r12	
        t = (int)src;
        if ((t | (int)dst) & wmask)
    e276:	0b 4c       	mov	r12,	r11	
    e278:	0b de       	bis	r14,	r11	
    e27a:	1b f3       	and	#1,	r11	;r3 As==01
    e27c:	1b 24       	jz	$+56     	;abs 0xe2b4
        {
            if ((t ^ (int)dst) & wmask || length <= wsize)
    e27e:	0b 4c       	mov	r12,	r11	
    e280:	0b ee       	xor	r14,	r11	
    e282:	1b f3       	and	#1,	r11	;r3 As==01
    e284:	06 20       	jnz	$+14     	;abs 0xe292
    e286:	3d 90 03 00 	cmp	#3,	r13	;#0x0003
    e28a:	03 28       	jnc	$+8      	;abs 0xe292
                t = length;
            else
                t &= wmask;
    e28c:	0b 4e       	mov	r14,	r11	
    e28e:	1b f3       	and	#1,	r11	;r3 As==01
    e290:	01 3c       	jmp	$+4      	;abs 0xe294
        src += length;
        dst += length;
        t = (int)src;
        if ((t | (int)dst) & wmask)
        {
            if ((t ^ (int)dst) & wmask || length <= wsize)
    e292:	0b 4d       	mov	r13,	r11	
                t = length;
            else
                t &= wmask;
            length -= t;
    e294:	0d 8b       	sub	r11,	r13	
        /*
         * Copy backwards.  Otherwise essentially the same.
         * Alignment works as before, except that it takes
         * (t&wmask) bytes to align, not wsize-(t&wmask).
         */
        src += length;
    e296:	09 4e       	mov	r14,	r9	
        dst += length;
    e298:	0a 4c       	mov	r12,	r10	
void *
memcpy(dst0, src0, length)
#else
#ifdef MEMMOVE
void *
memmove(dst0, src0, length)
    e29a:	08 4b       	mov	r11,	r8	
    e29c:	08 8c       	sub	r12,	r8	
            if ((t ^ (int)dst) & wmask || length <= wsize)
                t = length;
            else
                t &= wmask;
            length -= t;
            TLOOP1(*--dst = *--src);
    e29e:	3a 53       	add	#-1,	r10	;r3 As==11
    e2a0:	39 53       	add	#-1,	r9	;r3 As==11
    e2a2:	ea 49 00 00 	mov.b	@r9,	0(r10)	;0x0000(r10)
    e2a6:	07 4a       	mov	r10,	r7	
    e2a8:	07 58       	add	r8,	r7	
    e2aa:	f9 23       	jnz	$-12     	;abs 0xe29e
void *
memcpy(dst0, src0, length)
#else
#ifdef MEMMOVE
void *
memmove(dst0, src0, length)
    e2ac:	3b e3       	inv	r11		
    e2ae:	1b 53       	inc	r11		
    e2b0:	0c 5b       	add	r11,	r12	
    e2b2:	0e 5b       	add	r11,	r14	
            else
                t &= wmask;
            length -= t;
            TLOOP1(*--dst = *--src);
        }
        t = length / wsize;
    e2b4:	0b 4d       	mov	r13,	r11	
    e2b6:	12 c3       	clrc			
    e2b8:	0b 10       	rrc	r11		
        TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
    e2ba:	0e 24       	jz	$+30     	;abs 0xe2d8
    e2bc:	0a 4b       	mov	r11,	r10	
    e2be:	08 4e       	mov	r14,	r8	
    e2c0:	09 4c       	mov	r12,	r9	
    e2c2:	28 83       	decd	r8		
    e2c4:	29 83       	decd	r9		
    e2c6:	a9 48 00 00 	mov	@r8,	0(r9)	;0x0000(r9)
    e2ca:	3a 53       	add	#-1,	r10	;r3 As==11
    e2cc:	fa 23       	jnz	$-10     	;abs 0xe2c2
void *
memcpy(dst0, src0, length)
#else
#ifdef MEMMOVE
void *
memmove(dst0, src0, length)
    e2ce:	0a 8b       	sub	r11,	r10	
    e2d0:	0b 4a       	mov	r10,	r11	
    e2d2:	0b 5b       	rla	r11		
    e2d4:	0e 5b       	add	r11,	r14	
    e2d6:	0c 5b       	add	r11,	r12	
            length -= t;
            TLOOP1(*--dst = *--src);
        }
        t = length / wsize;
        TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
        t = length & wmask;
    e2d8:	1d f3       	and	#1,	r13	;r3 As==01
        TLOOP(*--dst = *--src);
    e2da:	03 24       	jz	$+8      	;abs 0xe2e2
    e2dc:	dc 4e ff ff 	mov.b	-1(r14),-1(r12)	;0xffff(r14), 0xffff(r12)
    e2e0:	ff ff 
#if defined(MEMCOPY) || defined(MEMMOVE)
    return (dst0);
#else
    return;
#endif
}
    e2e2:	37 41       	pop	r7		
    e2e4:	38 41       	pop	r8		
    e2e6:	39 41       	pop	r9		
    e2e8:	3a 41       	pop	r10		
    e2ea:	3b 41       	pop	r11		
    e2ec:	30 41       	ret			

0000e2ee <memset>:
memset(dst0, c0, length)
void *dst0;
register int c0;
register size_t length;
#endif
{
    e2ee:	0b 12       	push	r11		
    e2f0:	0a 12       	push	r10		
    e2f2:	09 12       	push	r9		
    e2f4:	08 12       	push	r8		
     *		 dst		 dst+length-1
     *
     * but we use a minimum of 3 here since the overhead of the code
     * to do word writes is substantial.
     */
    if (length < 3 * wsize)
    e2f6:	3d 90 06 00 	cmp	#6,	r13	;#0x0006
    e2fa:	09 2c       	jc	$+20     	;abs 0xe30e
    e2fc:	0c 4f       	mov	r15,	r12	
    e2fe:	04 3c       	jmp	$+10     	;abs 0xe308
    {
        while (length != 0)
        {
            *dst++ = VAL;
    e300:	cc 4e 00 00 	mov.b	r14,	0(r12)	;0x0000(r12)
    e304:	1c 53       	inc	r12		
            --length;
    e306:	3d 53       	add	#-1,	r13	;r3 As==11
     * but we use a minimum of 3 here since the overhead of the code
     * to do word writes is substantial.
     */
    if (length < 3 * wsize)
    {
        while (length != 0)
    e308:	0d 93       	tst	r13		
    e30a:	fa 23       	jnz	$-10     	;abs 0xe300
    e30c:	20 3c       	jmp	$+66     	;abs 0xe34e
        }
        RETURN;
    }

#ifndef BZERO
    if ((c = (u_char)c0) != 0)
    e30e:	4e 4e       	mov.b	r14,	r14	
    e310:	4b 4e       	mov.b	r14,	r11	
    e312:	0b 93       	tst	r11		
    e314:	03 24       	jz	$+8      	;abs 0xe31c
    {	/* Fill the word. */
        c = (c << 8) | c;	/* u_int is 16 bits. */
    e316:	0c 4b       	mov	r11,	r12	
    e318:	8c 10       	swpb	r12		
    e31a:	0b dc       	bis	r12,	r11	
        c = (c << 32) | c;	/* u_int is 64 bits. */
#endif
    }
#endif
    /* Align destination by filling in bytes. */
    if ((t = (long)((int)dst) & wmask) != 0)
    e31c:	1f b3       	bit	#1,	r15	;r3 As==01
    e31e:	06 24       	jz	$+14     	;abs 0xe32c
    {
        t = wsize - t;
        length -= t;
    e320:	3d 53       	add	#-1,	r13	;r3 As==11
        do
        {
            *dst++ = VAL;
    e322:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    e326:	09 4f       	mov	r15,	r9	
    e328:	19 53       	inc	r9		
    e32a:	01 3c       	jmp	$+4      	;abs 0xe32e
        c = (c << 32) | c;	/* u_int is 64 bits. */
#endif
    }
#endif
    /* Align destination by filling in bytes. */
    if ((t = (long)((int)dst) & wmask) != 0)
    e32c:	09 4f       	mov	r15,	r9	
        }
        while (--t != 0);
    }

    /* Fill words.  Length was >= 2*words so we know t >= 1 here. */
    t = length / wsize;
    e32e:	0c 4d       	mov	r13,	r12	
    e330:	12 c3       	clrc			
    e332:	0c 10       	rrc	r12		
    e334:	0a 49       	mov	r9,	r10	
    e336:	08 4c       	mov	r12,	r8	
    do
    {
        *(u_int *)dst = WIDEVAL;
    e338:	8a 4b 00 00 	mov	r11,	0(r10)	;0x0000(r10)
        dst += wsize;
    e33c:	2a 53       	incd	r10		
    }
    while (--t != 0);
    e33e:	38 53       	add	#-1,	r8	;r3 As==11
    e340:	fb 23       	jnz	$-8      	;abs 0xe338
#define	RETURN	return (dst0)
#define	VAL	c0
#define	WIDEVAL	c

void *
memset(dst0, c0, length)
    e342:	0c 5c       	rla	r12		
    do
    {
        *(u_int *)dst = WIDEVAL;
        dst += wsize;
    }
    while (--t != 0);
    e344:	0c 59       	add	r9,	r12	

    /* Mop up trailing bytes, if any. */
    t = length & wmask;
    e346:	1d f3       	and	#1,	r13	;r3 As==01
    if (t != 0)
    e348:	02 24       	jz	$+6      	;abs 0xe34e
        do
        {
            *dst++ = VAL;
    e34a:	cc 4e 00 00 	mov.b	r14,	0(r12)	;0x0000(r12)
        }
        while (--t != 0);
    RETURN;
}
    e34e:	38 41       	pop	r8		
    e350:	39 41       	pop	r9		
    e352:	3a 41       	pop	r10		
    e354:	3b 41       	pop	r11		
    e356:	30 41       	ret			

0000e358 <_unexpected_>:
    e358:	00 13       	reti			

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	10 c1 10 c1 10 c1 a8 cb 10 c1 10 c1 10 c1 10 c1     ................
    fff0:	10 c1 10 c1 10 c1 10 c1 10 c1 10 c1 10 c1 00 c0     ................
