
listener.elf:     file format elf32-msp430

SYMBOL TABLE:
0000c000 l    d  .text	00000000 .text
0000e488 l    d  .rodata	00000000 .rodata
00000200 l    d  .data	00000000 .data
0000022e l    d  .bss	00000000 .bss
000002e8 l    d  .noinit	00000000 .noinit
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 main_LinkListen.c
0000c106 l     F .text	0000005e sRxCallback
0000022f l     O .bss	00000001 sLinkID2
0000022e l     O .bss	00000001 sSemaphore
00000230 l     O .bss	00000001 sRxTid
0000c0ea l       .text	00000000 __br_unexpected_
00000000 l    df *ABS*	00000000 mrfi.c
0000c164 l     F .text	00000008 mrfi_TxCCADone
0000c16c l     F .text	00000008 mrfi_TxImmediateDone
0000c174 l     F .text	0000005c spiRegAccess
0000c1d0 l     F .text	0000004c Mrfi_DelayUsec
0000c21c l     F .text	000000ca spiBurstFifoAccess
00000234 l     O .bss	00000018 mrfiIncomingPacket
0000024d l     O .bss	00000001 mrfiRndSeed
0000024e l     O .bss	00000002 sReplyDelayScalar
00000232 l     O .bss	00000001 sReplyDelayContext
00000233 l     O .bss	00000001 sKillSem
0000024c l     O .bss	00000001 mrfiRadioState
0000c542 l     F .text	00000038 Mrfi_RxModeOff
00000252 l     O .bss	00000001 rx_isr_context
0000c59a l     F .text	00000020 Mrfi_RxModeOn
0000c70e l     F .text	0000001a MRFI_PrepareToTx
00000250 l     O .bss	00000002 sBackoffHelper
0000e4c8 l     O .rodata	00000004 mrfiLogicalChanTable
0000e4cc l     O .rodata	00000003 mrfiRFPowerTable
0000e48c l     O .rodata	0000003c mrfiRadioCfg
00000200 l     O .data	00000004 mrfiRxFilterAddr
00000253 l     O .bss	00000001 mrfiRxFilterEnabled
00000000 l    df *ABS*	00000000 bsp.c
00000000 l    df *ABS*	00000000 nwk_api.c
00000254 l     O .bss	00000001 sInit_done
0000e4e2 l     O .rodata	00000006 CSWTCH.3
00000000 l    df *ABS*	00000000 nwk.c
00000204 l     O .data	0000002a sPersistInfo
00000000 l    df *ABS*	00000000 nwk_join.c
00000258 l     O .bss	00000004 sJoinToken
0000025c l     O .bss	00000002 spCallback
00000256 l     O .bss	00000001 sTid
00000000 l    df *ABS*	00000000 nwk_frame.c
0000025e l     O .bss	00000001 sMyTxType
00000260 l     O .bss	00000002 spCallback
00000262 l     O .bss	00000002 sMyAddr
00000264 l     O .bss	00000001 sTRACTID
0000e4e8 l     O .rodata	0000000c func
00000000 l    df *ABS*	00000000 nwk_link.c
0000026c l     O .bss	00000004 sLinkToken
00000266 l     O .bss	00000001 sTid
00000268 l     O .bss	00000002 sServiceLinkID
0000026a l     O .bss	00000001 sListenActive
00000267 l     O .bss	00000001 sNumLinkers
00000000 l    df *ABS*	00000000 nwk_ioctl.c
0000e4f4 l     O .rodata	00000004 CSWTCH.1
00000000 l    df *ABS*	00000000 nwk_globals.c
00000270 l     O .bss	00000004 sAPAddress
00000274 l     O .bss	00000001 sRAMAddressIsSet
0000e4f8 l     O .rodata	00000004 sMyROMAddress
00000276 l     O .bss	00000004 sMyRAMAddress
0000e4fc l     O .rodata	00000006 sVersionInfo
00000000 l    df *ABS*	00000000 nwk_freq.c
00000000 l    df *ABS*	00000000 nwk_ping.c
0000027a l     O .bss	00000001 sTid
00000000 l    df *ABS*	00000000 nwk_mgmt.c
0000027c l     O .bss	00000001 sTid
0000027e l     O .bss	00000002 sAPAddr
00000000 l    df *ABS*	00000000 nwk_security.c
00000000 l    df *ABS*	00000000 nwk_QMgmt.c
00000280 l     O .bss	00000034 sInFrameQ
000002b4 l     O .bss	00000034 sOutFrameQ
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
0000d6be g     F .text	000000e6 nwk_retrieveFrame
00000057 g       *ABS*	00000000 __BCSCTL1
0000005a g       *ABS*	00000000 __CACTL2
0000c410 g     F .text	0000007e MRFI_ReplyDelay
0000002e g       *ABS*	00000000 __data_size
00000166 g       *ABS*	00000000 __TA0CCTL2
0000c0ea  w      .text	00000000 __isr_14
0000c4a2 g     F .text	00000044 mrfiSpiInit
00000128 g       *ABS*	00000000 __FCTL1
00000192 g       *ABS*	00000000 __TA1CCR0
00000042 g       *ABS*	00000000 __P2SEL2
00000024 g       *ABS*	00000000 __P1IES
0000d810 g     F .text	00000014 nwk_setLinkToken
00000069 g       *ABS*	00000000 __UCB0CTL1
0000dd36 g     F .text	00000020 nwk_globalsInit
0000c0ea  w      .text	00000000 __isr_4
00000002 g       *ABS*	00000000 __IFG1
0000c728 g     F .text	0000015e MRFI_Transmit
00000060 g       *ABS*	00000000 __UCA0CTL0
0000d468 g     F .text	000000f2 nwk_join
0000e322 g     F .text	000000fa memmove
0000d3dc g     F .text	0000003c nwk_putNumObjectIntoMsg
00000000 g       .vectors	00000000 _efartext
0000cfd2 g     F .text	0000008c nwk_nwkInit
0000df5e g     F .text	0000006c nwk_poll
00000176 g       *ABS*	00000000 __TA0CCR2
0000c604 g     F .text	0000001a mrfiSpiReadReg
00000001 g       *ABS*	00000000 __IE2
0000dbcc g     F .text	00000052 nwk_rawSend
0000ddec g     F .text	000000c2 nwk_ping
0000d628 g     F .text	00000096 MRFI_RxCompleteISR
0000002b g       *ABS*	00000000 __P2IFG
0000001a g       *ABS*	00000000 __P3DIR
0000cb1a g     F .text	00000042 MRFI_RxAddrIsFiltered
0000e502 g       *ABS*	00000000 _etext
0000d12c g     F .text	00000042 nwk_isLinkDuplicate
000010f8 g       *ABS*	00000000 __CALDCO_16MHZ
0000c330 g     F .text	00000024 MRFI_RandomByte
000000ba g       *ABS*	00000000 __bss_size
0000d3ce g     F .text	0000000e nwk_getNumObjectFromMsg
0000d836 g     F .text	0000017e nwk_link
000010fd g       *ABS*	00000000 __CALBC1_8MHZ
0000c000  w      .text	00000000 __watchdog_support
0000c0e4  w      .text	00000000 __stop_progExec__
00000172 g       *ABS*	00000000 __TA0CCR0
0000e228 g     F .text	000000fa memcpy
0000002d g       *ABS*	00000000 __P2IE
0000c48e g     F .text	0000000e MRFI_PostKillSem
0000d0da g     F .text	00000006 nwk_freeConnection
0000cf2c g     F .text	000000a6 SMPL_Ioctl
0000d41c g     F .text	00000026 nwk_joinInit
0000cf26 g     F .text	00000006 SMPL_Link
0000c0ea  w      .text	00000000 __isr_11
00000160 g       *ABS*	00000000 __TA0CTL
00000025 g       *ABS*	00000000 __P1IE
0000006b g       *ABS*	00000000 __UCB0BR1
00000164 g       *ABS*	00000000 __TA0CCTL1
00000049 g       *ABS*	00000000 __ADC10DTC1
00000190 g       *ABS*	00000000 __TA1R
0000dddc g     F .text	00000002 nwk_freqInit
0000cd3a g     F .text	00000018 BSP_InitLeds
00000066 g       *ABS*	00000000 __UCA0RXBUF
00000061 g       *ABS*	00000000 __UCA0CTL1
00000170 g       *ABS*	00000000 __TA0R
0000cdc8 g     F .text	00000080 SMPL_LinkListen
0000c2e6 g     F .text	0000004a MRFI_Receive
0000d456 g     F .text	00000012 nwk_getJoinToken
0000d594 g     F .text	00000094 nwk_buildFrame
0000c5ba g     F .text	00000020 MRFI_RxOn
0000cd8e g     F .text	0000003a SMPL_Init
0000cec4 g     F .text	00000008 SMPL_Send
00000180 g       *ABS*	00000000 __TA1CTL
0000c892 g     F .text	00000038 MRFI_SetLogicalChannel
0000c68a g     F .text	00000018 mrfiSpiWriteReg
0000006d g       *ABS*	00000000 __UCB0STAT
0000c0ea  w      .text	00000000 __isr_5
00000063 g       *ABS*	00000000 __UCA0BR1
0000e502 g       *ABS*	00000000 __data_load_start
0000c0ea g       .text	00000000 __dtors_end
00000053 g       *ABS*	00000000 __BCSCTL3
0000e1f8 g     F .text	00000010 nwk_getQ
0000d16e g     F .text	0000004a nwk_findAddressMatch
000001bc g       *ABS*	00000000 __ADC10SA
0000d39e g     F .text	00000030 nwk_checkAppMsgTID
00000065 g       *ABS*	00000000 __UCA0STAT
0000c0ea  w      .text	00000000 __isr_2
0000012c g       *ABS*	00000000 __FCTL3
0000c0ea  w      .text	00000000 __isr_10
0000002e g       *ABS*	00000000 __P2SEL
000010f9 g       *ABS*	00000000 __CALBC1_16MHZ
0000012e g       *ABS*	00000000 __TA0IV
00000023 g       *ABS*	00000000 __P1IFG
000010fb g       *ABS*	00000000 __CALBC1_12MHZ
00000182 g       *ABS*	00000000 __TA1CCTL0
0000004a g       *ABS*	00000000 __ADC10AE0
0000011a g       *ABS*	00000000 __UCB0I2CSA
0000ccd0 g     F .text	00000016 BSP_GpioPort1Isr
0000c0ee g     F .text	00000018 toggleLED
00000056 g       *ABS*	00000000 __DCOCTL
0000c8ca g     F .text	0000003a MRFI_SetRFPwr
00000003 g       *ABS*	00000000 __IFG2
000002e8 g     O .noinit	00000002 __wdt_clear_value
0000dc4a g     F .text	00000086 nwk_radioControl
0000caec g     F .text	0000001e MRFI_EnableRxAddrFilter
0000001b g       *ABS*	00000000 __P3SEL
0000c0ea  w      .text	00000000 __isr_7
0000ffe0 g     O .vectors	00000020 __ivtbl_16
0000006c g       *ABS*	00000000 __UCB0I2CIE
0000006a g       *ABS*	00000000 __UCB0BR0
00000028 g       *ABS*	00000000 __P2IN
00000118 g       *ABS*	00000000 __UCB0I2COA
000001b4 g       *ABS*	00000000 __ADC10MEM
0000005b g       *ABS*	00000000 __CAPD
0000e0c6 g     F .text	00000132 nwk_QfindOldest
0000c61e g     F .text	0000006c MRFI_Rssi
0000c0ea  w      .text	00000000 __isr_0
0000dc1e g     F .text	0000002c nwk_rawReceive
0000df26 g     F .text	00000038 nwk_processMgmt
0000c354 g     F .text	000000a4 Mrfi_DelayUsecLong
00000029 g       *ABS*	00000000 __P2OUT
0000012a g       *ABS*	00000000 __FCTL2
00000064 g       *ABS*	00000000 __UCA0MCTL
00000043 g       *ABS*	00000000 __P3SEL2
0000c028  w      .text	00000000 __do_clear_bss
0000c904 g     F .text	000001ba MRFI_Init
00000021 g       *ABS*	00000000 __P1OUT
0000002c g       *ABS*	00000000 __P2IES
00000026 g       *ABS*	00000000 __P1SEL
0000d1e0 g     F .text	00000062 nwk_isConnectionValid
0000d442 g     F .text	00000014 nwk_setJoinToken
00000027 g       *ABS*	00000000 __P1REN
0000e486  w      .text	00000000 _unexpected_
0000c0ea  w      .text	00000000 __isr_8
0000dd68 g     F .text	00000006 nwk_getFWVersion
0000011e g       *ABS*	00000000 __TA1IV
0000ccd0 g       .text	00000000 __isr_3
0000e208 g     F .text	00000020 memcmp
000010fc g       *ABS*	00000000 __CALDCO_8MHZ
0000dd94 g     F .text	0000001a nwk_setAPAddress
0000ddd6 g     F .text	00000006 nwk_getBCastAddress
0000c000  w      .text	00000000 _reset_vector__
0000c0ea g       .text	00000000 __ctors_start
0000c49c g     F .text	00000006 MRFI_GetRadioState
0000ccf0 g     F .text	0000001c BSP_InitBoard
0000c0ea  w      .text	00000000 __isr_12
000010fa g       *ABS*	00000000 __CALDCO_12MHZ
0000c6a2 g     F .text	0000005e MRFI_WakeUp
00000018 g       *ABS*	00000000 __P3IN
0000c010  w      .text	00000000 __do_copy_data
0000d31a g     F .text	00000042 nwk_isValidReply
0000d576 g     F .text	0000001e nwk_frameInit
00000162 g       *ABS*	00000000 __TA0CCTL0
0000ddde g     F .text	00000004 nwk_processFreq
0000022e g       .bss	00000000 __bss_start
0000dde2 g     F .text	0000000a nwk_pingInit
0000e036 g     F .text	00000090 nwk_QfindSlot
0000d0e0 g     F .text	0000004c nwk_getConnInfo
0000e41c g     F .text	0000006a memset
0000c03e g     F .text	000000a6 main
0000cd52 g     F .text	0000000e BSP_InitDrivers
0000c0ea  w      .text	00000000 __isr_13
0000c4e6 g     F .text	0000005c mrfiSpiCmdStrobe
0000c5da g     F .text	0000002a MRFI_Sleep
0000d7da g     F .text	00000004 nwk_getMyRxType
0000d824 g     F .text	00000012 nwk_getLinkToken
0000dd6e g     F .text	00000004 nwk_getProtocolVersion
0000dd72 g     F .text	00000022 nwk_setMyAddress
00010000 g       .vectors	00000000 _vectors_end
0000ddae g     F .text	00000028 nwk_getAPAddress
0000002a g       *ABS*	00000000 __P2DIR
00000174 g       *ABS*	00000000 __TA0CCR1
00000186 g       *ABS*	00000000 __TA1CCTL2
00000068 g       *ABS*	00000000 __UCB0CTL0
0000002f g       *ABS*	00000000 __P2REN
0000df1c g     F .text	0000000a nwk_mgmtInit
0000d7a4 g     F .text	00000036 nwk_sendFrame
0000db62 g     F .text	0000005c nwk_getLocalLinkID
0000006e g       *ABS*	00000000 __UCB0RXBUF
000001b0 g       *ABS*	00000000 __ADC10CTL0
0000c0ea  w      .text	00000000 __isr_9
0000005e g       *ABS*	00000000 __UCA0IRTCTL
000010fe g       *ABS*	00000000 __CALDCO_1MHZ
00000067 g       *ABS*	00000000 __UCA0TXBUF
00000184 g       *ABS*	00000000 __TA1CCTL1
0000d242 g     F .text	000000d8 nwk_allocateLocalRxPort
0000cb0a g     F .text	00000010 MRFI_DisableRxAddrFilter
0000c00c  w      .text	00000000 __init_stack
0000005d g       *ABS*	00000000 __UCA0ABCTL
0000cecc g     F .text	0000005a SMPL_Receive
00000019 g       *ABS*	00000000 __P3OUT
0000deae g     F .text	0000006e nwk_processPing
00000196 g       *ABS*	00000000 __TA1CCR2
0000c0ea g       .text	00000000 __dtors_start
0000c0ea  w      .text	00000000 __isr_6
0000c0ea g       .text	00000000 __ctors_end
0000d7de g     F .text	00000032 nwk_linkInit
00000194 g       *ABS*	00000000 __TA1CCR1
00000062 g       *ABS*	00000000 __UCA0BR0
00000400 g       *ABS*	00000000 __stack
0000d55a g     F .text	0000001c nwk_processJoin
0000c0ea  w      .text	00000000 __isr_1
0000022e g       .data	00000000 _edata
0000d05e g     F .text	0000007c nwk_getNextConnection
000002ea g       *ABS*	00000000 _end
0000cd0c g     F .text	0000002e BSP_Delay
0000e488 g     O .rodata	00000004 mrfiBroadcastAddr
0000d35c g     F .text	00000042 nwk_findPeer
00000048 g       *ABS*	00000000 __ADC10DTC0
0000d9b4 g     F .text	000001ae nwk_processLink
0000c57a g     F .text	00000020 MRFI_RxIdle
0000dd10 g     F .text	00000026 nwk_connectionControl
000001b2 g       *ABS*	00000000 __ADC10CTL1
0000cabe g     F .text	0000002e MRFI_SetRxAddrFilter
0000dfd0 g     F .text	0000001e nwk_QInit
00000058 g       *ABS*	00000000 __BCSCTL2
0000c0e4  w      .text	00000000 _endless_loop__
0000dcd0 g     F .text	00000040 nwk_deviceAddress
00000041 g       *ABS*	00000000 __P1SEL2
0000cce6 g     F .text	0000000a BSP_EARLY_INIT
00000022 g       *ABS*	00000000 __P1DIR
0000cd60 g     F .text	00000024 BSP_Init
0000dfcc g     F .text	00000004 nwk_processSecurity
0000005f g       *ABS*	00000000 __UCA0IRRCTL
00000010 g       *ABS*	00000000 __P3REN
0000d418 g     F .text	00000004 nwk_NVObj
0000006f g       *ABS*	00000000 __UCB0TXBUF
000010ff g       *ABS*	00000000 __CALBC1_1MHZ
0000dbbe g     F .text	0000000e nwk_setListenContext
0000c010  w      .text	00000000 __low_level_init
0000ce48 g     F .text	0000007c SMPL_SendOpt
00000200 g       .data	00000000 __data_start
00000120 g       *ABS*	00000000 __WDTCTL
0000dfee g     F .text	00000048 nwk_QadjustOrder
00000000 g       *ABS*	00000000 __IE1
0000d1b8 g     F .text	00000028 nwk_checkConnInfo
0000dd56 g     F .text	00000012 nwk_getMyAddress
0000cd84 g     F .text	0000000a BSP_InitButtons
0000c886 g     F .text	0000000c mrfiSpiReadRxFifo
0000c3f8 g     F .text	00000018 MRFI_DelayMs
00000059 g       *ABS*	00000000 __CACTL1
0000c700 g     F .text	0000000e mrfiSpiWriteTxFifo
00000020 g       *ABS*	00000000 __P1IN
0000dfca g     F .text	00000002 nwk_securityInit
0000cb5c g     F .text	00000174 MRFI_GpioIsr



Disassembly of section .text:

0000c000 <__watchdog_support>:
    c000:	55 42 20 01 	mov.b	&0x0120,r5	
    c004:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08
    c008:	82 45 e8 02 	mov	r5,	&0x02e8	

0000c00c <__init_stack>:
    c00c:	31 40 00 04 	mov	#1024,	r1	;#0x0400

0000c010 <__do_copy_data>:
    c010:	3f 40 2e 00 	mov	#46,	r15	;#0x002e
    c014:	0f 93       	tst	r15		
    c016:	08 24       	jz	$+18     	;abs 0xc028
    c018:	92 42 e8 02 	mov	&0x02e8,&0x0120	
    c01c:	20 01 
    c01e:	2f 83       	decd	r15		
    c020:	9f 4f 02 e5 	mov	-6910(r15),512(r15);0xe502(r15), 0x0200(r15)
    c024:	00 02 
    c026:	f8 23       	jnz	$-14     	;abs 0xc018

0000c028 <__do_clear_bss>:
    c028:	3f 40 ba 00 	mov	#186,	r15	;#0x00ba
    c02c:	0f 93       	tst	r15		
    c02e:	07 24       	jz	$+16     	;abs 0xc03e
    c030:	92 42 e8 02 	mov	&0x02e8,&0x0120	
    c034:	20 01 
    c036:	1f 83       	dec	r15		
    c038:	cf 43 2e 02 	mov.b	#0,	558(r15);r3 As==00, 0x022e(r15)
    c03c:	f9 23       	jnz	$-12     	;abs 0xc030

0000c03e <main>:

/* Rx callback handler */
static uint8_t sRxCallback(linkID_t);

int main (void)
{
    c03e:	21 83       	decd	r1		
  WDTCTL = WDTPW + WDTHOLD;
    c040:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    c044:	20 01 
  BSP_Init();
    c046:	b0 12 60 cd 	call	#0xcd60	
  /* This call will fail because the join will fail since there is no Access Point
   * in this scenario. But we don't care -- just use the default link token later.
   * We supply a callback pointer to handle the message returned by the peer.
   */

  toggleLED(1);
    c04a:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c04c:	b0 12 ee c0 	call	#0xc0ee	

  SMPL_Init(sRxCallback);
    c050:	3f 40 06 c1 	mov	#-16122,r15	;#0xc106
    c054:	b0 12 8e cd 	call	#0xcd8e	

  /* turn on LEDs. */
  toggleLED(2);
    c058:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c05a:	b0 12 ee c0 	call	#0xc0ee	
  NWK_DELAY(500);
    c05e:	3f 40 f4 01 	mov	#500,	r15	;#0x01f4
    c062:	b0 12 f8 c3 	call	#0xc3f8	
    c066:	3b 40 0a 00 	mov	#10,	r11	;#0x000a
  int i;
  for (i = 10; --i >= 0; ) {
    toggleLED(1);
    c06a:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c06c:	b0 12 ee c0 	call	#0xc0ee	
    toggleLED(2);
    c070:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c072:	b0 12 ee c0 	call	#0xc0ee	
    NWK_DELAY(100);
    c076:	3f 40 64 00 	mov	#100,	r15	;#0x0064
    c07a:	b0 12 f8 c3 	call	#0xc3f8	
    c07e:	3b 53       	add	#-1,	r11	;r3 As==11

  /* turn on LEDs. */
  toggleLED(2);
  NWK_DELAY(500);
  int i;
  for (i = 10; --i >= 0; ) {
    c080:	f4 23       	jnz	$-22     	;abs 0xc06a
    toggleLED(1);
    toggleLED(2);
    NWK_DELAY(100);
  }
  toggleLED(2);
    c082:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c084:	b0 12 ee c0 	call	#0xc0ee	
  //toggleLED(1);
  
  /* listen for link forever... */
  while (1)
    {
      if (SMPL_SUCCESS == SMPL_LinkListen(&sLinkID2))
    c088:	3f 40 2f 02 	mov	#559,	r15	;#0x022f
    c08c:	b0 12 c8 cd 	call	#0xcdc8	
    c090:	0f 93       	tst	r15		
    c092:	fa 23       	jnz	$-10     	;abs 0xc088
	  break;
	}
      /* Implement fail-to-link policy here. otherwise, listen again. */
    }
  /* we're linked. turn off red LED. Received messages will toggle the green LED. */
  if (BSP_LED2_IS_ON())
    c094:	5f 42 29 00 	mov.b	&0x0029,r15	
    c098:	3f f0 20 00 	and	#32,	r15	;#0x0020
    c09c:	03 24       	jz	$+8      	;abs 0xc0a4
    {
      toggleLED(2);
    c09e:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c0a0:	b0 12 ee c0 	call	#0xc0ee	
    }
  
  if (BSP_LED1_IS_ON())
    c0a4:	5f 42 21 00 	mov.b	&0x0021,r15	
    c0a8:	1f f3       	and	#1,	r15	;r3 As==01
    c0aa:	03 24       	jz	$+8      	;abs 0xc0b2
    {
      toggleLED(1);
    c0ac:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c0ae:	b0 12 ee c0 	call	#0xc0ee	
    }
  
  /* turn on LED1 on the peer in response to receiving a frame. */
  *msg = 0x01;  /* toggle red led */
    c0b2:	d1 43 00 00 	mov.b	#1,	0(r1)	;r3 As==01, 0x0000(r1)
  
  /* turn on RX. default is RX off. */
  SMPL_Ioctl( IOCTL_OBJ_RADIO, IOCTL_ACT_RADIO_RXON, 0);
    c0b6:	0d 43       	clr	r13		
    c0b8:	3e 42       	mov	#8,	r14	;r2 As==11
    c0ba:	3f 40 03 00 	mov	#3,	r15	;#0x0003
    c0be:	b0 12 2c cf 	call	#0xcf2c	
  while (1) ;
}

static void linkFrom()
{
  uint8_t     msg[2], tid = 0;
    c0c2:	4b 43       	clr.b	r11		
   {
     /* Wait for a frame to be received. The Rx handler, which is running in
      * ISR thread, will post to this semaphore allowing the application to
      * send the reply message in the user thread.
      */
     if (sSemaphore)
    c0c4:	5f 42 2e 02 	mov.b	&0x022e,r15	
    c0c8:	4f 93       	tst.b	r15		
    c0ca:	fc 27       	jz	$-6      	;abs 0xc0c4
     {
       *(msg+1) = ++tid;
    c0cc:	5b 53       	inc.b	r11		
    c0ce:	c1 4b 01 00 	mov.b	r11,	1(r1)	;0x0001(r1)
       SMPL_Send(sLinkID2, msg, 2);
    c0d2:	6d 43       	mov.b	#2,	r13	;r3 As==10
    c0d4:	0e 41       	mov	r1,	r14	
    c0d6:	5f 42 2f 02 	mov.b	&0x022f,r15	
    c0da:	b0 12 c4 ce 	call	#0xcec4	

       /* Reset semaphore. This is not properly protected and there is a race
        * here. In theory we could miss a message. Good enough for a demo, though.
        */
       sSemaphore = 0;
    c0de:	c2 43 2e 02 	mov.b	#0,	&0x022e	;r3 As==00
    c0e2:	f0 3f       	jmp	$-30     	;abs 0xc0c4

0000c0e4 <__stop_progExec__>:
    c0e4:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    c0e8:	fd 3f       	jmp	$-4      	;abs 0xc0e4

0000c0ea <__ctors_end>:
    c0ea:	30 40 86 e4 	br	#0xe486	

0000c0ee <toggleLED>:
}


void toggleLED(uint8_t which)
{
  switch(which)
    c0ee:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    c0f0:	07 24       	jz	$+16     	;abs 0xc100
    c0f2:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    c0f4:	01 24       	jz	$+4      	;abs 0xc0f8
    c0f6:	30 41       	ret			
   {
    case 1 :
      BSP_TOGGLE_LED1();
      break;
    case 2 :
      BSP_TOGGLE_LED2();
    c0f8:	f2 e0 20 00 	xor.b	#32,	&0x0029	;#0x0020
    c0fc:	29 00 
    c0fe:	30 41       	ret			
void toggleLED(uint8_t which)
{
  switch(which)
   {
    case 1 :
      BSP_TOGGLE_LED1();
    c100:	d2 e3 21 00 	xor.b	#1,	&0x0021	;r3 As==01
    c104:	30 41       	ret			

0000c106 <sRxCallback>:
}


/* handle received messages */
static uint8_t sRxCallback(linkID_t port)
{
    c106:	0b 12       	push	r11		
    c108:	21 82       	sub	#4,	r1	;r2 As==10
  uint8_t msg[2], len, tid;

  /* is the callback for the link ID we want to handle? */
  if (port == sLinkID2)
    c10a:	5f 92 2f 02 	cmp.b	&0x022f,r15	
    c10e:	04 24       	jz	$+10     	;abs 0xc118
       /* drop frame. we're done with it. */
       return 1;
     }
  }
  /* keep frame for later handling */
  return 0;
    c110:	4f 43       	clr.b	r15		
}
    c112:	21 52       	add	#4,	r1	;r2 As==10
    c114:	3b 41       	pop	r11		
    c116:	30 41       	ret			

  /* is the callback for the link ID we want to handle? */
  if (port == sLinkID2)
  {
    /* yes. go get the frame. we know this call will succeed. */
     if ((SMPL_SUCCESS == SMPL_Receive(sLinkID2, msg, &len)) && len)
    c118:	0d 41       	mov	r1,	r13	
    c11a:	0e 41       	mov	r1,	r14	
    c11c:	1e 53       	inc	r14		
    c11e:	b0 12 cc ce 	call	#0xcecc	
    c122:	0f 93       	tst	r15		
    c124:	f5 23       	jnz	$-20     	;abs 0xc110
    c126:	c1 93 00 00 	tst.b	0(r1)		;0x0000(r1)
    c12a:	f2 27       	jz	$-26     	;abs 0xc110
     {
       /* Check the application sequence number to detect
        * late or missing frames...
        */
       tid = *(msg+1);
    c12c:	5b 41 02 00 	mov.b	2(r1),	r11	;0x0002(r1)
       if (tid)
    c130:	4b 93       	tst.b	r11		
    c132:	0a 24       	jz	$+22     	;abs 0xc148
       {
         if (tid > sRxTid)
    c134:	c2 9b 30 02 	cmp.b	r11,	&0x0230	
    c138:	0a 2c       	jc	$+22     	;abs 0xc14e
         {
           /* we're good. toggle LED */
           toggleLED(*msg);
    c13a:	5f 41 01 00 	mov.b	1(r1),	r15	;0x0001(r1)
    c13e:	b0 12 ee c0 	call	#0xc0ee	
           sRxTid = tid;
    c142:	c2 4b 30 02 	mov.b	r11,	&0x0230	
    c146:	03 3c       	jmp	$+8      	;abs 0xc14e
         }
       }
       else
       {
         /* wrap case... */
         if (sRxTid)
    c148:	c2 93 30 02 	tst.b	&0x0230	
    c14c:	04 20       	jnz	$+10     	;abs 0xc156
         }
       }
       /* Post to the semaphore to let application know so it sends
        * the reply
        */
       sSemaphore = 1;
    c14e:	d2 43 2e 02 	mov.b	#1,	&0x022e	;r3 As==01
       /* drop frame. we're done with it. */
       return 1;
    c152:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c154:	de 3f       	jmp	$-66     	;abs 0xc112
       {
         /* wrap case... */
         if (sRxTid)
         {
           /* we're good. toggle LED */
           toggleLED(*msg);
    c156:	5f 41 01 00 	mov.b	1(r1),	r15	;0x0001(r1)
    c15a:	b0 12 ee c0 	call	#0xc0ee	
           sRxTid = tid;
    c15e:	c2 43 30 02 	mov.b	#0,	&0x0230	;r3 As==00
    c162:	f5 3f       	jmp	$-20     	;abs 0xc14e

0000c164 <mrfi_TxCCADone>:
 * @return      true if transmission is complete, false otherwise
 **************************************************************************************************
 */
bool mrfi_TxCCADone( void )
{
  return MRFI_PAPD_PIN_IS_HIGH(); // || marc_state == RF_SM_RX || marc_state == RF_SM_IDLE;
    c164:	5f 42 28 00 	mov.b	&0x0028,r15	
}
    c168:	5f f3       	and.b	#1,	r15	;r3 As==01
    c16a:	30 41       	ret			

0000c16c <mrfi_TxImmediateDone>:
 * @return      true if transmission is complete, false otherwise
 **************************************************************************************************
 */
bool mrfi_TxImmediateDone( void )
{
  return MRFI_SYNC_PIN_INT_FLAG_IS_SET(); // || marc_state == RF_SM_RX || marc_state == RF_SM_IDLE;
    c16c:	5f 42 2b 00 	mov.b	&0x002b,r15	
}
    c170:	5f f3       	and.b	#1,	r15	;r3 As==01
    c172:	30 41       	ret			

0000c174 <spiRegAccess>:

#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  bool comm_state = sActiveSPI; // save comm state
#endif

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );   /* SPI is not initialized */
    c174:	5d 42 68 00 	mov.b	&0x0068,r13	
    c178:	3d f2       	and	#8,	r13	;r2 As==11
    c17a:	03 20       	jnz	$+8      	;abs 0xc182
    c17c:	32 c2       	dint			
    c17e:	03 43       	nop			
    c180:	ff 3f       	jmp	$+0      	;abs 0xc180

  /* disable interrupts that use SPI */
  MRFI_SPI_ENTER_CRITICAL_SECTION(s);
    c182:	0c 42       	mov	r2,	r12	
    c184:	32 c2       	dint			
    c186:	03 43       	nop			
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  sActiveSPI = true;            // indicate active comm state
#endif

  /* turn chip select "off" and then "on" to clear any current SPI access */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c188:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c18c:	21 00 
  MRFI_SPI_TURN_CHIP_SELECT_ON();
    c18e:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c192:	21 00 

  /* send register address byte, the read/write bit is already configured */
  MRFI_SPI_WRITE_BYTE(addrByte);
    c194:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c198:	03 00 
    c19a:	c2 4f 6f 00 	mov.b	r15,	&0x006f	
  MRFI_SPI_WAIT_DONE();
    c19e:	5f 42 03 00 	mov.b	&0x0003,r15	
    c1a2:	2f f2       	and	#4,	r15	;r2 As==10
    c1a4:	fc 27       	jz	$-6      	;abs 0xc19e

  /*
   *  Send the byte value to write.  If this operation is a read, this value
   *  is not used and is just dummy data.  Wait for SPI access to complete.
   */
  MRFI_SPI_WRITE_BYTE(writeValue);
    c1a6:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c1aa:	03 00 
    c1ac:	c2 4e 6f 00 	mov.b	r14,	&0x006f	
  MRFI_SPI_WAIT_DONE();
    c1b0:	5f 42 03 00 	mov.b	&0x0003,r15	
    c1b4:	2f f2       	and	#4,	r15	;r2 As==10
    c1b6:	fc 27       	jz	$-6      	;abs 0xc1b0
  /*
   *  If this is a read operation, SPI data register now contains the register
   *  value which will be returned.  For a read operation, it contains junk info
   *  that is not used.
   */
  readValue = MRFI_SPI_READ_BYTE();
    c1b8:	5f 42 6e 00 	mov.b	&0x006e,r15	
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  sActiveSPI = comm_state; // restore comm state
#endif

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c1bc:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c1c0:	21 00 
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c1c2:	3c b2       	bit	#8,	r12	;r2 As==11
    c1c4:	02 20       	jnz	$+6      	;abs 0xc1ca
    c1c6:	0e 42       	mov	r2,	r14	

  /* return the register value */
  return(readValue);
}
    c1c8:	30 41       	ret			
  sActiveSPI = comm_state; // restore comm state
#endif

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c1ca:	32 d2       	eint			
    c1cc:	0e 42       	mov	r2,	r14	

  /* return the register value */
  return(readValue);
}
    c1ce:	30 41       	ret			

0000c1d0 <Mrfi_DelayUsec>:
 *
 * @return      none
 ****************************************************************************************************
 */
static void Mrfi_DelayUsec(uint16_t howLong)
{
    c1d0:	0b 12       	push	r11		
    c1d2:	0a 12       	push	r10		
  bspIState_t s;
  uint16_t count = howLong/MRFI_MAX_DELAY_US;

  if (howLong)
    c1d4:	0f 93       	tst	r15		
    c1d6:	1f 24       	jz	$+64     	;abs 0xc216
 ****************************************************************************************************
 */
static void Mrfi_DelayUsec(uint16_t howLong)
{
  bspIState_t s;
  uint16_t count = howLong/MRFI_MAX_DELAY_US;
    c1d8:	0b 4f       	mov	r15,	r11	
    c1da:	12 c3       	clrc			
    c1dc:	0b 10       	rrc	r11		
    c1de:	12 c3       	clrc			
    c1e0:	0b 10       	rrc	r11		
    c1e2:	12 c3       	clrc			
    c1e4:	0b 10       	rrc	r11		
    c1e6:	12 c3       	clrc			
    c1e8:	0b 10       	rrc	r11		
    c1ea:	06 3c       	jmp	$+14     	;abs 0xc1f8
  {
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
      BSP_EXIT_CRITICAL_SECTION(s);
    c1ec:	0f 42       	mov	r2,	r15	
    } while (count--);
    c1ee:	0f 4b       	mov	r11,	r15	
    c1f0:	3f 53       	add	#-1,	r15	;r3 As==11
    c1f2:	0b 93       	tst	r11		
    c1f4:	10 24       	jz	$+34     	;abs 0xc216
    c1f6:	0b 4f       	mov	r15,	r11	

  if (howLong)
  {
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
    c1f8:	0a 42       	mov	r2,	r10	
    c1fa:	32 c2       	dint			
    c1fc:	03 43       	nop			
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
    c1fe:	3f 40 10 00 	mov	#16,	r15	;#0x0010
    c202:	b0 12 0c cd 	call	#0xcd0c	
      BSP_EXIT_CRITICAL_SECTION(s);
    c206:	3a b2       	bit	#8,	r10	;r2 As==11
    c208:	f1 27       	jz	$-28     	;abs 0xc1ec
    c20a:	32 d2       	eint			
    c20c:	0f 42       	mov	r2,	r15	
    } while (count--);
    c20e:	0f 4b       	mov	r11,	r15	
    c210:	3f 53       	add	#-1,	r15	;r3 As==11
    c212:	0b 93       	tst	r11		
    c214:	f0 23       	jnz	$-30     	;abs 0xc1f6
  }

  return;
}
    c216:	3a 41       	pop	r10		
    c218:	3b 41       	pop	r11		
    c21a:	30 41       	ret			

0000c21c <spiBurstFifoAccess>:
 *
 * @return      true if an interrupt was detected during the transfer, false otherwise
 *=================================================================================================
 */
static bool spiBurstFifoAccess(uint8_t addrByte, uint8_t * pData, uint8_t len)
{
    c21c:	0b 12       	push	r11		
    c21e:	0a 12       	push	r10		
    c220:	4b 4d       	mov.b	r13,	r11	

#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  bool comm_state = sActiveSPI; // save comm state
#endif

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );   /* SPI is not initialized */
    c222:	5d 42 68 00 	mov.b	&0x0068,r13	
    c226:	3d f2       	and	#8,	r13	;r2 As==11
    c228:	5b 24       	jz	$+184    	;abs 0xc2e0
  MRFI_SPI_ASSERT(len != 0);                      /* zero length is not allowed */
    c22a:	4b 93       	tst.b	r11		
    c22c:	56 24       	jz	$+174    	;abs 0xc2da
  MRFI_SPI_ASSERT(addrByte & BURST_BIT);          /* only burst mode supported */
    c22e:	3f b0 40 00 	bit	#64,	r15	;#0x0040
    c232:	03 20       	jnz	$+8      	;abs 0xc23a
    c234:	32 c2       	dint			
    c236:	03 43       	nop			
    c238:	ff 3f       	jmp	$+0      	;abs 0xc238

  /* disable interrupts that use SPI */
  MRFI_SPI_ENTER_CRITICAL_SECTION(s);
    c23a:	0d 42       	mov	r2,	r13	
    c23c:	3d f2       	and	#8,	r13	;r2 As==11
    c23e:	32 c2       	dint			
    c240:	03 43       	nop			
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  sActiveSPI = true;            // indicate active comm state
#endif

  /* turn chip select "off" and then "on" to clear any current SPI access */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c242:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c246:	21 00 
  MRFI_SPI_TURN_CHIP_SELECT_ON();
    c248:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c24c:	21 00 
 * @return      true if an interrupt was detected during the transfer, false otherwise
 *=================================================================================================
 */
static bool spiBurstFifoAccess(uint8_t addrByte, uint8_t * pData, uint8_t len)
{
  bool result = false; // initialize to successful status
    c24e:	4a 43       	clr.b	r10		
   *  the start of this loop.  Loop exits when nothing left to transfer.
   */
  do
  {
    /* send FIFO access command byte, wait for SPI access to complete */
    MRFI_SPI_WRITE_BYTE(addrByte);
    c250:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c254:	03 00 
    c256:	c2 4f 6f 00 	mov.b	r15,	&0x006f	
    MRFI_SPI_WAIT_DONE();
    c25a:	5c 42 03 00 	mov.b	&0x0003,r12	
    c25e:	2c f2       	and	#4,	r12	;r2 As==10
    c260:	fc 27       	jz	$-6      	;abs 0xc25a
     *  Inner loop.  This loop executes as long as the SPI access is not interrupted.
     *  Loop completes when nothing left to transfer.
     */
    do
    {
      MRFI_SPI_WRITE_BYTE(*pData);
    c262:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c266:	03 00 
    c268:	e2 4e 6f 00 	mov.b	@r14,	&0x006f	
       *  Use idle time.  Perform increment/decrement operations before pending on
       *  completion of SPI access.
       *
       *  Decrement the length counter.  Wait for SPI access to complete.
       */
      len--;
    c26c:	7b 53       	add.b	#-1,	r11	;r3 As==11
      MRFI_SPI_WAIT_DONE();
    c26e:	5c 42 03 00 	mov.b	&0x0003,r12	
    c272:	2c f2       	and	#4,	r12	;r2 As==10
    c274:	fc 27       	jz	$-6      	;abs 0xc26e

      /*-------------------------------------------------------------------------------
       *  SPI data register holds data just read.  If this is a read operation,
       *  store the value into memory.
       */
      if (addrByte & READ_BIT)
    c276:	4f 93       	tst.b	r15		
    c278:	1b 38       	jl	$+56     	;abs 0xc2b0
       *  critical interrupts that might be pending.
       *
       *  To improve latency, take care of pointer increment within the interrupt
       *  enabled window.
       */
      MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c27a:	0d 93       	tst	r13		
    c27c:	17 20       	jnz	$+48     	;abs 0xc2ac
    c27e:	0d 42       	mov	r2,	r13	
      pData++;
    c280:	1e 53       	inc	r14		
      MRFI_SPI_ENTER_CRITICAL_SECTION(s);
    c282:	0d 42       	mov	r2,	r13	
    c284:	3d f2       	and	#8,	r13	;r2 As==11
    c286:	32 c2       	dint			
    c288:	03 43       	nop			
       *  If chip select is "off" the SPI access was interrupted (all SPI access
       *  functions leave chip select in the "off" state).  In this case, turn
       *  back on chip select and break to the main loop.  The main loop will
       *  pick up where the access was interrupted.
       */
      if (MRFI_SPI_CHIP_SELECT_IS_OFF())
    c28a:	5c 42 21 00 	mov.b	&0x0021,r12	
    c28e:	3c f0 10 00 	and	#16,	r12	;#0x0010
    c292:	12 20       	jnz	$+38     	;abs 0xc2b8
        break;
      }

    /*-------------------------------------------------------------------------------
     */
    } while (len); /* inner loop */
    c294:	4b 93       	tst.b	r11		
    c296:	e5 23       	jnz	$-52     	;abs 0xc262
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  sActiveSPI = comm_state; // restore comm state
#endif

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c298:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c29c:	21 00 
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c29e:	0d 93       	tst	r13		
    c2a0:	16 20       	jnz	$+46     	;abs 0xc2ce
    c2a2:	0f 42       	mov	r2,	r15	
  
  return result;
}
    c2a4:	4f 4a       	mov.b	r10,	r15	
    c2a6:	3a 41       	pop	r10		
    c2a8:	3b 41       	pop	r11		
    c2aa:	30 41       	ret			
       *  critical interrupts that might be pending.
       *
       *  To improve latency, take care of pointer increment within the interrupt
       *  enabled window.
       */
      MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c2ac:	32 d2       	eint			
    c2ae:	e7 3f       	jmp	$-48     	;abs 0xc27e
       *  SPI data register holds data just read.  If this is a read operation,
       *  store the value into memory.
       */
      if (addrByte & READ_BIT)
      {
        *pData = MRFI_SPI_READ_BYTE();
    c2b0:	de 42 6e 00 	mov.b	&0x006e,0(r14)	;0x0000(r14)
    c2b4:	00 00 
    c2b6:	e1 3f       	jmp	$-60     	;abs 0xc27a
       *  back on chip select and break to the main loop.  The main loop will
       *  pick up where the access was interrupted.
       */
      if (MRFI_SPI_CHIP_SELECT_IS_OFF())
      {
        MRFI_SPI_TURN_CHIP_SELECT_ON();
    c2b8:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c2bc:	21 00 
        result = true;   // indicate interruption detected
    c2be:	5a 43       	mov.b	#1,	r10	;r3 As==01
      }

    /*-------------------------------------------------------------------------------
     */
    } while (len); /* inner loop */
  } while (len);   /* main loop */
    c2c0:	4b 93       	tst.b	r11		
    c2c2:	c6 23       	jnz	$-114    	;abs 0xc250
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  sActiveSPI = comm_state; // restore comm state
#endif

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c2c4:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c2c8:	21 00 
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c2ca:	0d 93       	tst	r13		
    c2cc:	ea 27       	jz	$-42     	;abs 0xc2a2
    c2ce:	32 d2       	eint			
    c2d0:	0f 42       	mov	r2,	r15	
  
  return result;
}
    c2d2:	4f 4a       	mov.b	r10,	r15	
    c2d4:	3a 41       	pop	r10		
    c2d6:	3b 41       	pop	r11		
    c2d8:	30 41       	ret			
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  bool comm_state = sActiveSPI; // save comm state
#endif

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );   /* SPI is not initialized */
  MRFI_SPI_ASSERT(len != 0);                      /* zero length is not allowed */
    c2da:	32 c2       	dint			
    c2dc:	03 43       	nop			
    c2de:	ff 3f       	jmp	$+0      	;abs 0xc2de

#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  bool comm_state = sActiveSPI; // save comm state
#endif

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );   /* SPI is not initialized */
    c2e0:	32 c2       	dint			
    c2e2:	03 43       	nop			
    c2e4:	ff 3f       	jmp	$+0      	;abs 0xc2e4

0000c2e6 <MRFI_Receive>:
 * @return      none
 **************************************************************************************************
 */
void MRFI_Receive(mrfiPacket_t * pPacket)
{
  *pPacket = mrfiIncomingPacket;
    c2e6:	3e 40 34 02 	mov	#564,	r14	;#0x0234
    c2ea:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c2ee:	2f 53       	incd	r15		
    c2f0:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c2f4:	2f 53       	incd	r15		
    c2f6:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c2fa:	2f 53       	incd	r15		
    c2fc:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c300:	2f 53       	incd	r15		
    c302:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c306:	2f 53       	incd	r15		
    c308:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c30c:	2f 53       	incd	r15		
    c30e:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c312:	2f 53       	incd	r15		
    c314:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c318:	2f 53       	incd	r15		
    c31a:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c31e:	2f 53       	incd	r15		
    c320:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c324:	2f 53       	incd	r15		
    c326:	bf 4e 00 00 	mov	@r14+,	0(r15)	;0x0000(r15)
    c32a:	af 4e 02 00 	mov	@r14,	2(r15)	;0x0002(r15)
}
    c32e:	30 41       	ret			

0000c330 <MRFI_RandomByte>:
 * @return      a random byte
 **************************************************************************************************
 */
uint8_t MRFI_RandomByte(void)
{
  mrfiRndSeed = (mrfiRndSeed*MRFI_RANDOM_MULTIPLIER) + MRFI_RANDOM_OFFSET;
    c330:	5d 42 4d 02 	mov.b	&0x024d,r13	
    c334:	4e 4d       	mov.b	r13,	r14	
    c336:	4e 5e       	rla.b	r14		
    c338:	4e 5d       	add.b	r13,	r14	
    c33a:	4e 5e       	rla.b	r14		
    c33c:	4e 5e       	rla.b	r14		
    c33e:	4f 4e       	mov.b	r14,	r15	
    c340:	4f 5f       	rla.b	r15		
    c342:	4f 5f       	rla.b	r15		
    c344:	4f 5f       	rla.b	r15		
    c346:	4f 5e       	add.b	r14,	r15	
    c348:	4f 5d       	add.b	r13,	r15	
    c34a:	7f 50 43 00 	add.b	#67,	r15	;#0x0043
    c34e:	c2 4f 4d 02 	mov.b	r15,	&0x024d	

  return mrfiRndSeed;
}
    c352:	30 41       	ret			

0000c354 <Mrfi_DelayUsecLong>:
 *
 * @return      status; true if timeout truncated due to semaphore test, false otherwise
 ****************************************************************************************************
 */
bool Mrfi_DelayUsecLong(uint32_t ms, uint16_t us, TimeoutTerminator_t term)
{
    c354:	0b 12       	push	r11		
    c356:	0a 12       	push	r10		
    c358:	09 12       	push	r9		
    c35a:	08 12       	push	r8		
    c35c:	07 12       	push	r7		
    c35e:	06 12       	push	r6		
    c360:	06 4e       	mov	r14,	r6	
    c362:	07 4f       	mov	r15,	r7	
    c364:	08 4d       	mov	r13,	r8	
    c366:	0a 4c       	mov	r12,	r10	
  bool timeout = false;
  bspIState_t s;
  uint16_t count;

  while (!timeout && ms)
    c368:	0e 93       	tst	r14		
    c36a:	28 20       	jnz	$+82     	;abs 0xc3bc
    c36c:	07 93       	tst	r7		
    c36e:	26 20       	jnz	$+78     	;abs 0xc3bc
        timeout = term( );
    } while (!timeout && count--);
    ms--;
  }
  count = us/MRFI_MAX_DELAY_US;
  if (!timeout && us)
    c370:	08 93       	tst	r8		
    c372:	3a 24       	jz	$+118    	;abs 0xc3e8
      if (term != NULL)
        timeout = term( );
    } while (!timeout && count--);
    ms--;
  }
  count = us/MRFI_MAX_DELAY_US;
    c374:	0b 48       	mov	r8,	r11	
    c376:	12 c3       	clrc			
    c378:	0b 10       	rrc	r11		
    c37a:	12 c3       	clrc			
    c37c:	0b 10       	rrc	r11		
    c37e:	12 c3       	clrc			
    c380:	0b 10       	rrc	r11		
    c382:	12 c3       	clrc			
    c384:	0b 10       	rrc	r11		
    c386:	0b 3c       	jmp	$+24     	;abs 0xc39e
  {
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
      BSP_EXIT_CRITICAL_SECTION(s);
    c388:	0f 42       	mov	r2,	r15	
      if (term != NULL)
    c38a:	0a 93       	tst	r10		
    c38c:	03 24       	jz	$+8      	;abs 0xc394
        timeout = term( );
    c38e:	8a 12       	call	r10		
    } while (!timeout && count--);
    c390:	4f 93       	tst.b	r15		
    c392:	2b 20       	jnz	$+88     	;abs 0xc3ea
    c394:	0f 4b       	mov	r11,	r15	
    c396:	3f 53       	add	#-1,	r15	;r3 As==11
    c398:	0b 93       	tst	r11		
    c39a:	26 24       	jz	$+78     	;abs 0xc3e8
    c39c:	0b 4f       	mov	r15,	r11	
  count = us/MRFI_MAX_DELAY_US;
  if (!timeout && us)
  {
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
    c39e:	09 42       	mov	r2,	r9	
    c3a0:	32 c2       	dint			
    c3a2:	03 43       	nop			
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
    c3a4:	3f 40 10 00 	mov	#16,	r15	;#0x0010
    c3a8:	b0 12 0c cd 	call	#0xcd0c	
      BSP_EXIT_CRITICAL_SECTION(s);
    c3ac:	39 b2       	bit	#8,	r9	;r2 As==11
    c3ae:	ec 27       	jz	$-38     	;abs 0xc388
    c3b0:	32 d2       	eint			
    c3b2:	ea 3f       	jmp	$-42     	;abs 0xc388
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
      BSP_EXIT_CRITICAL_SECTION(s);
      if (term != NULL)
        timeout = term( );
    } while (!timeout && count--);
    ms--;
    c3b4:	36 53       	add	#-1,	r6	;r3 As==11
    c3b6:	37 63       	addc	#-1,	r7	;r3 As==11
{
  bool timeout = false;
  bspIState_t s;
  uint16_t count;

  while (!timeout && ms)
    c3b8:	06 93       	tst	r6		
    c3ba:	d8 27       	jz	$-78     	;abs 0xc36c
 *
 * @return      status; true if timeout truncated due to semaphore test, false otherwise
 ****************************************************************************************************
 */
bool Mrfi_DelayUsecLong(uint32_t ms, uint16_t us, TimeoutTerminator_t term)
{
    c3bc:	3b 40 3f 00 	mov	#63,	r11	;#0x003f
    c3c0:	08 3c       	jmp	$+18     	;abs 0xc3d2
    count = APP_USEC_VALUE / MRFI_MAX_DELAY_US;
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
      BSP_EXIT_CRITICAL_SECTION(s);
    c3c2:	0f 42       	mov	r2,	r15	
      if (term != NULL)
    c3c4:	0a 93       	tst	r10		
    c3c6:	03 24       	jz	$+8      	;abs 0xc3ce
        timeout = term( );
    c3c8:	8a 12       	call	r10		
    } while (!timeout && count--);
    c3ca:	4f 93       	tst.b	r15		
    c3cc:	0e 20       	jnz	$+30     	;abs 0xc3ea
    c3ce:	3b 53       	add	#-1,	r11	;r3 As==11
    c3d0:	f1 27       	jz	$-28     	;abs 0xc3b4
  while (!timeout && ms)
  {
    count = APP_USEC_VALUE / MRFI_MAX_DELAY_US;
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
    c3d2:	09 42       	mov	r2,	r9	
    c3d4:	32 c2       	dint			
    c3d6:	03 43       	nop			
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
    c3d8:	3f 40 10 00 	mov	#16,	r15	;#0x0010
    c3dc:	b0 12 0c cd 	call	#0xcd0c	
      BSP_EXIT_CRITICAL_SECTION(s);
    c3e0:	39 b2       	bit	#8,	r9	;r2 As==11
    c3e2:	ef 27       	jz	$-32     	;abs 0xc3c2
    c3e4:	32 d2       	eint			
    c3e6:	ed 3f       	jmp	$-36     	;abs 0xc3c2
        timeout = term( );
    } while (!timeout && count--);
    ms--;
  }
  count = us/MRFI_MAX_DELAY_US;
  if (!timeout && us)
    c3e8:	4f 43       	clr.b	r15		
      if (term != NULL)
        timeout = term( );
    } while (!timeout && count--);
  }
  return timeout;
}
    c3ea:	36 41       	pop	r6		
    c3ec:	37 41       	pop	r7		
    c3ee:	38 41       	pop	r8		
    c3f0:	39 41       	pop	r9		
    c3f2:	3a 41       	pop	r10		
    c3f4:	3b 41       	pop	r11		
    c3f6:	30 41       	ret			

0000c3f8 <MRFI_DelayMs>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_DelayMs(uint16_t milliseconds)
{
    c3f8:	0b 12       	push	r11		
    c3fa:	0b 4f       	mov	r15,	r11	
  while (milliseconds)
    c3fc:	0f 93       	tst	r15		
    c3fe:	06 24       	jz	$+14     	;abs 0xc40c
  {
    Mrfi_DelayUsec( APP_USEC_VALUE );
    c400:	3f 40 e8 03 	mov	#1000,	r15	;#0x03e8
    c404:	b0 12 d0 c1 	call	#0xc1d0	
    milliseconds--;
    c408:	3b 53       	add	#-1,	r11	;r3 As==11
 * @return      none
 **************************************************************************************************
 */
void MRFI_DelayMs(uint16_t milliseconds)
{
  while (milliseconds)
    c40a:	fa 23       	jnz	$-10     	;abs 0xc400
  {
    Mrfi_DelayUsec( APP_USEC_VALUE );
    milliseconds--;
  }
}
    c40c:	3b 41       	pop	r11		
    c40e:	30 41       	ret			

0000c410 <MRFI_ReplyDelay>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_ReplyDelay()
{
    c410:	0b 12       	push	r11		
    c412:	0a 12       	push	r10		
    c414:	09 12       	push	r9		
  bspIState_t s;
  uint16_t    milliseconds = sReplyDelayScalar;
    c416:	19 42 4e 02 	mov	&0x024e,r9	

  BSP_ENTER_CRITICAL_SECTION(s);
    c41a:	0f 42       	mov	r2,	r15	
    c41c:	32 c2       	dint			
    c41e:	03 43       	nop			
  sReplyDelayContext = 1;
    c420:	d2 43 32 02 	mov.b	#1,	&0x0232	;r3 As==01
  BSP_EXIT_CRITICAL_SECTION(s);
    c424:	3f f2       	and	#8,	r15	;r2 As==11
    c426:	31 20       	jnz	$+100    	;abs 0xc48a
    c428:	0f 42       	mov	r2,	r15	

  while (milliseconds)
    c42a:	09 93       	tst	r9		
    c42c:	1f 24       	jz	$+64     	;abs 0xc46c
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_ReplyDelay()
{
    c42e:	3b 40 3f 00 	mov	#63,	r11	;#0x003f
    c432:	07 3c       	jmp	$+16     	;abs 0xc442
  {
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
      BSP_EXIT_CRITICAL_SECTION(s);
    c434:	0f 42       	mov	r2,	r15	
      if (sKillSem)
    c436:	5f 42 33 02 	mov.b	&0x0233,r15	
    c43a:	4f 93       	tst.b	r15		
    c43c:	11 20       	jnz	$+36     	;abs 0xc460
    c43e:	3b 53       	add	#-1,	r11	;r3 As==11
      {
        break;
      }
    } while (count--);
    c440:	0f 24       	jz	$+32     	;abs 0xc460

  if (howLong)
  {
    do
    {
      BSP_ENTER_CRITICAL_SECTION(s);
    c442:	0a 42       	mov	r2,	r10	
    c444:	32 c2       	dint			
    c446:	03 43       	nop			
      BSP_DELAY_USECS(MRFI_MAX_DELAY_US);
    c448:	3f 40 10 00 	mov	#16,	r15	;#0x0010
    c44c:	b0 12 0c cd 	call	#0xcd0c	
      BSP_EXIT_CRITICAL_SECTION(s);
    c450:	3a b2       	bit	#8,	r10	;r2 As==11
    c452:	f0 27       	jz	$-30     	;abs 0xc434
    c454:	32 d2       	eint			
    c456:	0f 42       	mov	r2,	r15	
      if (sKillSem)
    c458:	5f 42 33 02 	mov.b	&0x0233,r15	
    c45c:	4f 93       	tst.b	r15		
    c45e:	ef 27       	jz	$-32     	;abs 0xc43e
  BSP_EXIT_CRITICAL_SECTION(s);

  while (milliseconds)
  {
    Mrfi_DelayUsecSem( APP_USEC_VALUE );
    if (sKillSem)
    c460:	5f 42 33 02 	mov.b	&0x0233,r15	
    c464:	4f 93       	tst.b	r15		
    c466:	02 20       	jnz	$+6      	;abs 0xc46c
    {
      break;
    }
    milliseconds--;
    c468:	39 53       	add	#-1,	r9	;r3 As==11

  BSP_ENTER_CRITICAL_SECTION(s);
  sReplyDelayContext = 1;
  BSP_EXIT_CRITICAL_SECTION(s);

  while (milliseconds)
    c46a:	e1 23       	jnz	$-60     	;abs 0xc42e
      break;
    }
    milliseconds--;
  }

  BSP_ENTER_CRITICAL_SECTION(s);
    c46c:	0f 42       	mov	r2,	r15	
    c46e:	32 c2       	dint			
    c470:	03 43       	nop			
  sKillSem           = 0;
    c472:	c2 43 33 02 	mov.b	#0,	&0x0233	;r3 As==00
  sReplyDelayContext = 0;
    c476:	c2 43 32 02 	mov.b	#0,	&0x0232	;r3 As==00
  BSP_EXIT_CRITICAL_SECTION(s);
    c47a:	3f f2       	and	#8,	r15	;r2 As==11
    c47c:	01 24       	jz	$+4      	;abs 0xc480
    c47e:	32 d2       	eint			
    c480:	0f 42       	mov	r2,	r15	
}
    c482:	39 41       	pop	r9		
    c484:	3a 41       	pop	r10		
    c486:	3b 41       	pop	r11		
    c488:	30 41       	ret			
  bspIState_t s;
  uint16_t    milliseconds = sReplyDelayScalar;

  BSP_ENTER_CRITICAL_SECTION(s);
  sReplyDelayContext = 1;
  BSP_EXIT_CRITICAL_SECTION(s);
    c48a:	32 d2       	eint			
    c48c:	cd 3f       	jmp	$-100    	;abs 0xc428

0000c48e <MRFI_PostKillSem>:
 **************************************************************************************************
 */
void MRFI_PostKillSem(void)
{

  if (sReplyDelayContext)
    c48e:	5f 42 32 02 	mov.b	&0x0232,r15	
    c492:	4f 93       	tst.b	r15		
    c494:	02 24       	jz	$+6      	;abs 0xc49a
  {
    sKillSem = 1;
    c496:	d2 43 33 02 	mov.b	#1,	&0x0233	;r3 As==01
    c49a:	30 41       	ret			

0000c49c <MRFI_GetRadioState>:
 **************************************************************************************************
 */
uint8_t MRFI_GetRadioState(void)
{
  return mrfiRadioState;
}
    c49c:	5f 42 4c 02 	mov.b	&0x024c,r15	
    c4a0:	30 41       	ret			

0000c4a2 <mrfiSpiInit>:
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  sActiveSPI = false; // initialize interface status
#endif

  /* configure all SPI related pins */
  MRFI_SPI_CONFIG_CSN_PIN_AS_OUTPUT();
    c4a2:	f2 d0 10 00 	bis.b	#16,	&0x0022	;#0x0010
    c4a6:	22 00 
  MRFI_SPI_CONFIG_SCLK_PIN_AS_OUTPUT();
    c4a8:	f2 d0 20 00 	bis.b	#32,	&0x0022	;#0x0020
    c4ac:	22 00 
  MRFI_SPI_CONFIG_SI_PIN_AS_OUTPUT();
    c4ae:	f2 d0 80 ff 	bis.b	#-128,	&0x0022	;#0xff80
    c4b2:	22 00 
  MRFI_SPI_CONFIG_SO_PIN_AS_INPUT();

  /* set CSn to default high level */
  MRFI_SPI_DRIVE_CSN_HIGH();
    c4b4:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c4b8:	21 00 
  
  /* initialize the SPI registers */
  MRFI_SPI_INIT();
    c4ba:	d2 43 69 00 	mov.b	#1,	&0x0069	;r3 As==01
    c4be:	f2 40 81 ff 	mov.b	#-127,	&0x0069	;#0xff81
    c4c2:	69 00 
    c4c4:	f2 40 a9 ff 	mov.b	#-87,	&0x0068	;#0xffa9
    c4c8:	68 00 
    c4ca:	e2 43 6a 00 	mov.b	#2,	&0x006a	;r3 As==10
    c4ce:	c2 43 6b 00 	mov.b	#0,	&0x006b	;r3 As==00
    c4d2:	f2 d0 e0 ff 	bis.b	#-32,	&0x0026	;#0xffe0
    c4d6:	26 00 
    c4d8:	f2 d0 e0 ff 	bis.b	#-32,	&0x0041	;#0xffe0
    c4dc:	41 00 
    c4de:	f2 f0 fe ff 	and.b	#-2,	&0x0069	;#0xfffe
    c4e2:	69 00 
} 
    c4e4:	30 41       	ret			

0000c4e6 <mrfiSpiCmdStrobe>:

#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  bool comm_state = sActiveSPI; // save comm state
#endif

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );       /* SPI is not initialized */
    c4e6:	5e 42 68 00 	mov.b	&0x0068,r14	
    c4ea:	3e f2       	and	#8,	r14	;r2 As==11
    c4ec:	24 24       	jz	$+74     	;abs 0xc536
  MRFI_SPI_ASSERT((addr >= 0x30) && (addr <= 0x3D));  /* invalid address */
    c4ee:	4e 4f       	mov.b	r15,	r14	
    c4f0:	7e 50 d0 ff 	add.b	#-48,	r14	;#0xffd0
    c4f4:	7e 90 0e 00 	cmp.b	#14,	r14	;#0x000e
    c4f8:	03 28       	jnc	$+8      	;abs 0xc500
    c4fa:	32 c2       	dint			
    c4fc:	03 43       	nop			
    c4fe:	ff 3f       	jmp	$+0      	;abs 0xc4fe

  /* disable interrupts that use SPI */
  MRFI_SPI_ENTER_CRITICAL_SECTION(s);
    c500:	0d 42       	mov	r2,	r13	
    c502:	32 c2       	dint			
    c504:	03 43       	nop			
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  sActiveSPI = true;            // indicate active comm state
#endif

  /* turn chip select "off" and then "on" to clear any current SPI access */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c506:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c50a:	21 00 
  MRFI_SPI_TURN_CHIP_SELECT_ON();
    c50c:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c510:	21 00 

  /* send the command strobe, wait for SPI access to complete */
  MRFI_SPI_WRITE_BYTE(addr);
    c512:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c516:	03 00 
    c518:	c2 4f 6f 00 	mov.b	r15,	&0x006f	
  MRFI_SPI_WAIT_DONE();
    c51c:	5f 42 03 00 	mov.b	&0x0003,r15	
    c520:	2f f2       	and	#4,	r15	;r2 As==10
    c522:	fc 27       	jz	$-6      	;abs 0xc51c

  /* read the readio status byte returned by the command strobe */
  statusByte = MRFI_SPI_READ_BYTE();
    c524:	5f 42 6e 00 	mov.b	&0x006e,r15	
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  sActiveSPI = comm_state; // restore comm state
#endif

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
    c528:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c52c:	21 00 
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c52e:	3d b2       	bit	#8,	r13	;r2 As==11
    c530:	05 20       	jnz	$+12     	;abs 0xc53c
    c532:	0e 42       	mov	r2,	r14	

  /* return the status byte */
  return(statusByte);
}
    c534:	30 41       	ret			

#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  bool comm_state = sActiveSPI; // save comm state
#endif

  MRFI_SPI_ASSERT( MRFI_SPI_IS_INITIALIZED() );       /* SPI is not initialized */
    c536:	32 c2       	dint			
    c538:	03 43       	nop			
    c53a:	ff 3f       	jmp	$+0      	;abs 0xc53a
  sActiveSPI = comm_state; // restore comm state
#endif

  /* turn off chip select; enable interrupts that call SPI functions */
  MRFI_SPI_TURN_CHIP_SELECT_OFF();
  MRFI_SPI_EXIT_CRITICAL_SECTION(s);
    c53c:	32 d2       	eint			
    c53e:	0e 42       	mov	r2,	r14	

  /* return the status byte */
  return(statusByte);
}
    c540:	30 41       	ret			

0000c542 <Mrfi_RxModeOff>:
 **************************************************************************************************
 */
static void Mrfi_RxModeOff(void)
{
  /*disable receive interrupts */
  MRFI_DISABLE_SYNC_PIN_INT();
    c542:	c2 93 52 02 	tst.b	&0x0252	
    c546:	16 24       	jz	$+46     	;abs 0xc574
    c548:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    c54a:	c2 fe 2d 00 	and.b	r14,	&0x002d	

  /* turn off radio */
  MRFI_STROBE_IDLE_AND_WAIT();
    c54e:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    c552:	b0 12 e6 c4 	call	#0xc4e6	
    c556:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    c55a:	b0 12 e6 c4 	call	#0xc4e6	
    c55e:	3f b0 f0 00 	bit	#240,	r15	;#0x00f0
    c562:	f9 23       	jnz	$-12     	;abs 0xc556

  /* flush the receive FIFO of any residual data */
  mrfiSpiCmdStrobe( SFRX );
    c564:	7f 40 3a 00 	mov.b	#58,	r15	;#0x003a
    c568:	b0 12 e6 c4 	call	#0xc4e6	

  /* clear receive interrupt */
  MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    c56c:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    c570:	2b 00 

#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  stx_active = false; // indicate we're not in transmit
#endif // MRFI_TIMER_ALWAYS_ACTIVE
}
    c572:	30 41       	ret			
 **************************************************************************************************
 */
static void Mrfi_RxModeOff(void)
{
  /*disable receive interrupts */
  MRFI_DISABLE_SYNC_PIN_INT();
    c574:	7e 40 fe ff 	mov.b	#-2,	r14	;#0xfffe
    c578:	e8 3f       	jmp	$-46     	;abs 0xc54a

0000c57a <MRFI_RxIdle>:
 **************************************************************************************************
 */
void MRFI_RxIdle(void)
{
  /* radio must be awake to move it to idle mode */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c57a:	5f 42 4c 02 	mov.b	&0x024c,r15	
    c57e:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    c580:	09 24       	jz	$+20     	;abs 0xc594

  /* if radio is on, turn it off */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
    c582:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    c586:	01 24       	jz	$+4      	;abs 0xc58a
    c588:	30 41       	ret			
  {
    Mrfi_RxModeOff();
    c58a:	b0 12 42 c5 	call	#0xc542	
    mrfiRadioState = MRFI_RADIO_STATE_IDLE;
    c58e:	e2 43 4c 02 	mov.b	#2,	&0x024c	;r3 As==10
    c592:	30 41       	ret			
 **************************************************************************************************
 */
void MRFI_RxIdle(void)
{
  /* radio must be awake to move it to idle mode */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c594:	32 c2       	dint			
    c596:	03 43       	nop			
    c598:	ff 3f       	jmp	$+0      	;abs 0xc598

0000c59a <Mrfi_RxModeOn>:
 **************************************************************************************************
 */
static void Mrfi_RxModeOn(void)
{
  /* clear any residual receive interrupt */
  MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    c59a:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    c59e:	2b 00 

  /* send strobe to enter receive mode */
  mrfiSpiCmdStrobe( SRX );
    c5a0:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    c5a4:	b0 12 e6 c4 	call	#0xc4e6	

  /* enable receive interrupts */
  MRFI_ENABLE_SYNC_PIN_INT();
    c5a8:	5e 42 2d 00 	mov.b	&0x002d,r14	
 * @param       none
 *
 * @return      none
 **************************************************************************************************
 */
static void Mrfi_RxModeOn(void)
    c5ac:	5f 42 52 02 	mov.b	&0x0252,r15	
    c5b0:	5f e3       	xor.b	#1,	r15	;r3 As==01

  /* send strobe to enter receive mode */
  mrfiSpiCmdStrobe( SRX );

  /* enable receive interrupts */
  MRFI_ENABLE_SYNC_PIN_INT();
    c5b2:	4f de       	bis.b	r14,	r15	
    c5b4:	c2 4f 2d 00 	mov.b	r15,	&0x002d	

#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  stx_active = false; // indicate we're not in transmit
#endif // MRFI_TIMER_ALWAYS_ACTIVE
}
    c5b8:	30 41       	ret			

0000c5ba <MRFI_RxOn>:
 **************************************************************************************************
 */
void MRFI_RxOn(void)
{
  /* radio must be awake before we can move it to RX state */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c5ba:	5f 42 4c 02 	mov.b	&0x024c,r15	
    c5be:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    c5c0:	09 24       	jz	$+20     	;abs 0xc5d4

  /* if radio is off, turn it on */
  if(mrfiRadioState != MRFI_RADIO_STATE_RX)
    c5c2:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    c5c6:	05 24       	jz	$+12     	;abs 0xc5d2
  {
    mrfiRadioState = MRFI_RADIO_STATE_RX;
    c5c8:	f2 40 03 00 	mov.b	#3,	&0x024c	;#0x0003
    c5cc:	4c 02 
    Mrfi_RxModeOn();
    c5ce:	b0 12 9a c5 	call	#0xc59a	
    c5d2:	30 41       	ret			
 **************************************************************************************************
 */
void MRFI_RxOn(void)
{
  /* radio must be awake before we can move it to RX state */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c5d4:	32 c2       	dint			
    c5d6:	03 43       	nop			
    c5d8:	ff 3f       	jmp	$+0      	;abs 0xc5d8

0000c5da <MRFI_Sleep>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_Sleep(void)
{
    c5da:	0b 12       	push	r11		
  bspIState_t s;

  /* Critical section necessary for watertight testing and
   * setting of state variables.
   */
  BSP_ENTER_CRITICAL_SECTION(s);
    c5dc:	0b 42       	mov	r2,	r11	
    c5de:	32 c2       	dint			
    c5e0:	03 43       	nop			

  /* If radio is not asleep, put it to sleep */
  if(mrfiRadioState != MRFI_RADIO_STATE_OFF)
    c5e2:	d2 93 4c 02 	cmp.b	#1,	&0x024c	;r3 As==01
    c5e6:	08 24       	jz	$+18     	;abs 0xc5f8
  {
    /* go to idle so radio is in a known state before sleeping */
    MRFI_RxIdle();
    c5e8:	b0 12 7a c5 	call	#0xc57a	

    mrfiSpiCmdStrobe( SPWD );
    c5ec:	7f 40 39 00 	mov.b	#57,	r15	;#0x0039
    c5f0:	b0 12 e6 c4 	call	#0xc4e6	

    /* Our new state is OFF */
    mrfiRadioState = MRFI_RADIO_STATE_OFF;
    c5f4:	d2 43 4c 02 	mov.b	#1,	&0x024c	;r3 As==01
  }

  BSP_EXIT_CRITICAL_SECTION(s);
    c5f8:	3b b2       	bit	#8,	r11	;r2 As==11
    c5fa:	01 24       	jz	$+4      	;abs 0xc5fe
    c5fc:	32 d2       	eint			
    c5fe:	0f 42       	mov	r2,	r15	
}
    c600:	3b 41       	pop	r11		
    c602:	30 41       	ret			

0000c604 <mrfiSpiReadReg>:
 * @return      register value
 **************************************************************************************************
 */
uint8_t mrfiSpiReadReg(uint8_t addr)
{
  MRFI_SPI_ASSERT(addr <= 0x3B);    /* invalid address */
    c604:	7f 90 3c 00 	cmp.b	#60,	r15	;#0x003c
    c608:	03 28       	jnc	$+8      	;abs 0xc610
    c60a:	32 c2       	dint			
    c60c:	03 43       	nop			
    c60e:	ff 3f       	jmp	$+0      	;abs 0xc60e
  
  /*
   *  The burst bit is set to allow access to read-only status registers.
   *  This does not affect normal register reads.
   */
  return( spiRegAccess(addr | BURST_BIT | READ_BIT, DUMMY_BYTE) );
    c610:	7e 40 db ff 	mov.b	#-37,	r14	;#0xffdb
    c614:	7f d0 c0 ff 	bis.b	#-64,	r15	;#0xffc0
    c618:	b0 12 74 c1 	call	#0xc174	
}
    c61c:	30 41       	ret			

0000c61e <MRFI_Rssi>:
 *
 * @return      RSSI value in units of dBm.
 **************************************************************************************************
 */
int8_t MRFI_Rssi(void)
{
    c61e:	0b 12       	push	r11		
  uint8_t regValue;

  /* Radio must be in RX state to measure rssi. */
  MRFI_ASSERT( mrfiRadioState == MRFI_RADIO_STATE_RX );
    c620:	f2 90 03 00 	cmp.b	#3,	&0x024c	;#0x0003
    c624:	4c 02 
    c626:	03 24       	jz	$+8      	;abs 0xc62e
    c628:	32 c2       	dint			
    c62a:	03 43       	nop			
    c62c:	ff 3f       	jmp	$+0      	;abs 0xc62c
    c62e:	3b 40 10 00 	mov	#16,	r11	;#0x0010
   * the baud rate and the received signal strength itself.
   */
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  MRFI_WaitTimeoutUsec(MRFI_RSSI_VALID_DELAY_US, Mrfi_ValidateRSSI);
#else // MRFI_TIMER_ALWAYS_ACTIVE
  MRFI_RSSI_VALID_WAIT();
    c632:	7f 40 38 00 	mov.b	#56,	r15	;#0x0038
    c636:	b0 12 04 c6 	call	#0xc604	
    c63a:	3f b0 50 00 	bit	#80,	r15	;#0x0050
    c63e:	06 20       	jnz	$+14     	;abs 0xc64c
    c640:	3f 40 40 00 	mov	#64,	r15	;#0x0040
    c644:	b0 12 d0 c1 	call	#0xc1d0	
    c648:	3b 53       	add	#-1,	r11	;r3 As==11
    c64a:	f3 23       	jnz	$-24     	;abs 0xc632
#endif // MRFI_TIMER_ALWAYS_ACTIVE

  /* Read the RSSI value */
  regValue = mrfiSpiReadReg( RSSI );
    c64c:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    c650:	b0 12 04 c6 	call	#0xc604	
  int16_t rssi;

  /* The raw value is in 2's complement and in half db steps. Convert it to
   * decimal taking into account the offset value.
   */
  if(rawValue >= 128)
    c654:	4f 93       	tst.b	r15		
    c656:	08 38       	jl	$+18     	;abs 0xc668
  {
    rssi = (int16_t)(rawValue - 256)/2 - MRFI_RSSI_OFFSET;
  }
  else
  {
    rssi = (rawValue/2) - MRFI_RSSI_OFFSET;
    c658:	12 c3       	clrc			
    c65a:	4f 10       	rrc.b	r15		
    c65c:	4f 4f       	mov.b	r15,	r15	
    c65e:	3f 50 b8 ff 	add	#-72,	r15	;#0xffb8
    c662:	4f 4f       	mov.b	r15,	r15	
  /* Read the RSSI value */
  regValue = mrfiSpiReadReg( RSSI );

  /* convert and do offset compensation */
  return( Mrfi_CalculateRssi(regValue) );
}
    c664:	3b 41       	pop	r11		
    c666:	30 41       	ret			
  /* The raw value is in 2's complement and in half db steps. Convert it to
   * decimal taking into account the offset value.
   */
  if(rawValue >= 128)
  {
    rssi = (int16_t)(rawValue - 256)/2 - MRFI_RSSI_OFFSET;
    c668:	4e 4f       	mov.b	r15,	r14	
    c66a:	0f 4e       	mov	r14,	r15	
    c66c:	3f 50 00 ff 	add	#-256,	r15	;#0xff00
    c670:	0f 93       	tst	r15		
    c672:	01 34       	jge	$+4      	;abs 0xc676
    c674:	1f 53       	inc	r15		
    c676:	0f 11       	rra	r15		
    c678:	3f 50 b8 ff 	add	#-72,	r15	;#0xffb8
  {
    rssi = (rawValue/2) - MRFI_RSSI_OFFSET;
  }

  /* Restrict this value to least value can be held in an 8 bit signed int */
  if(rssi < -128)
    c67c:	3f 90 80 ff 	cmp	#-128,	r15	;#0xff80
    c680:	f0 37       	jge	$-30     	;abs 0xc662
    c682:	7f 40 80 ff 	mov.b	#-128,	r15	;#0xff80
  /* Read the RSSI value */
  regValue = mrfiSpiReadReg( RSSI );

  /* convert and do offset compensation */
  return( Mrfi_CalculateRssi(regValue) );
}
    c686:	3b 41       	pop	r11		
    c688:	30 41       	ret			

0000c68a <mrfiSpiWriteReg>:
 * @return      none
 **************************************************************************************************
 */
void mrfiSpiWriteReg(uint8_t addr, uint8_t value)
{
  MRFI_SPI_ASSERT((addr <= 0x2E) || (addr == 0x3E));    /* invalid address */
    c68a:	7f 90 2f 00 	cmp.b	#47,	r15	;#0x002f
    c68e:	06 28       	jnc	$+14     	;abs 0xc69c
    c690:	7f 90 3e 00 	cmp.b	#62,	r15	;#0x003e
    c694:	03 24       	jz	$+8      	;abs 0xc69c
    c696:	32 c2       	dint			
    c698:	03 43       	nop			
    c69a:	ff 3f       	jmp	$+0      	;abs 0xc69a
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
  spiRegAccess(addr, value);
    c69c:	b0 12 74 c1 	call	#0xc174	
}
    c6a0:	30 41       	ret			

0000c6a2 <MRFI_WakeUp>:
 **************************************************************************************************
 */
void MRFI_WakeUp(void)
{
  /* if radio is already awake, just ignore wakeup request */
  if(mrfiRadioState != MRFI_RADIO_STATE_OFF)
    c6a2:	d2 93 4c 02 	cmp.b	#1,	&0x024c	;r3 As==01
    c6a6:	01 24       	jz	$+4      	;abs 0xc6aa
    c6a8:	30 41       	ret			
  {
    return;
  }

  /* drive CSn low to initiate wakeup */
  MRFI_SPI_DRIVE_CSN_LOW();
    c6aa:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c6ae:	21 00 

  /* wait for MISO to go high indicating the oscillator is stable */
  while (MRFI_SPI_SO_IS_HIGH());
    c6b0:	5f 42 20 00 	mov.b	&0x0020,r15	
    c6b4:	3f f0 40 00 	and	#64,	r15	;#0x0040
    c6b8:	fb 23       	jnz	$-8      	;abs 0xc6b0

  /* wakeup is complete, drive CSn high and continue */
  MRFI_SPI_DRIVE_CSN_HIGH();
    c6ba:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c6be:	21 00 
/*
 *  The test registers must be restored after sleep for the CC1100 and CC2500 radios.
 *  This is not required for the CC1101 radio.
 */
#ifndef MRFI_CC1101
  mrfiSpiWriteReg( TEST2, SMARTRF_SETTING_TEST2 );
    c6c0:	7e 40 88 ff 	mov.b	#-120,	r14	;#0xff88
    c6c4:	7f 40 2c 00 	mov.b	#44,	r15	;#0x002c
    c6c8:	b0 12 8a c6 	call	#0xc68a	
  mrfiSpiWriteReg( TEST1, SMARTRF_SETTING_TEST1 );
    c6cc:	7e 40 31 00 	mov.b	#49,	r14	;#0x0031
    c6d0:	7f 40 2d 00 	mov.b	#45,	r15	;#0x002d
    c6d4:	b0 12 8a c6 	call	#0xc68a	
  mrfiSpiWriteReg( TEST0, SMARTRF_SETTING_TEST0 );
    c6d8:	7e 40 0b 00 	mov.b	#11,	r14	;#0x000b
    c6dc:	7f 40 2e 00 	mov.b	#46,	r15	;#0x002e
    c6e0:	b0 12 8a c6 	call	#0xc68a	
#endif

  /* enter idle mode */
  mrfiRadioState = MRFI_RADIO_STATE_IDLE;
    c6e4:	e2 43 4c 02 	mov.b	#2,	&0x024c	;r3 As==10
  MRFI_STROBE_IDLE_AND_WAIT();
    c6e8:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    c6ec:	b0 12 e6 c4 	call	#0xc4e6	
    c6f0:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    c6f4:	b0 12 e6 c4 	call	#0xc4e6	
    c6f8:	3f b0 f0 00 	bit	#240,	r15	;#0x00f0
    c6fc:	f9 23       	jnz	$-12     	;abs 0xc6f0
    c6fe:	30 41       	ret			

0000c700 <mrfiSpiWriteTxFifo>:
 * @return      true if an interrupt was detected during the transfer, false otherwise
 **************************************************************************************************
 */
bool mrfiSpiWriteTxFifo(uint8_t * pData, uint8_t len)
{
  return spiBurstFifoAccess(TXFIFO | BURST_BIT, pData, len);
    c700:	4d 4e       	mov.b	r14,	r13	
    c702:	0e 4f       	mov	r15,	r14	
    c704:	7f 40 7f 00 	mov.b	#127,	r15	;#0x007f
    c708:	b0 12 1c c2 	call	#0xc21c	
}
    c70c:	30 41       	ret			

0000c70e <MRFI_PrepareToTx>:
 *
 * @return      None
 **************************************************************************************************
 */
static void MRFI_PrepareToTx( mrfiPacket_t * pPacket )
{
    c70e:	0b 12       	push	r11		
    c710:	0b 4f       	mov	r15,	r11	
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  stx_active = true; // indicate we are in the act of transmitting
#endif // MRFI_TIMER_ALWAYS_ACTIVE

   mrfiSpiCmdStrobe( SFTX ); // flush the tx fifo
    c712:	7f 40 3b 00 	mov.b	#59,	r15	;#0x003b
    c716:	b0 12 e6 c4 	call	#0xc4e6	
#ifndef NWK_PLL
  {
    /* compute number of bytes to write to transmit FIFO */
    uint8_t txBufLen = pPacket->frame[MRFI_LENGTH_FIELD_OFS]
                                                   + MRFI_LENGTH_FIELD_SIZE;
    mrfiSpiWriteTxFifo(pPacket->frame, txBufLen);
    c71a:	6e 4b       	mov.b	@r11,	r14	
    c71c:	5e 53       	inc.b	r14		
    c71e:	0f 4b       	mov	r11,	r15	
    c720:	b0 12 00 c7 	call	#0xc700	
  }
#else // defined NWK_PLL
  mrfiSpiWriteTxFifo(pPacket->frame, MRFI_PAYLOAD_OFFSET);
#endif
  return;
}
    c724:	3b 41       	pop	r11		
    c726:	30 41       	ret			

0000c728 <MRFI_Transmit>:
 *                  MRFI_TX_RESULT_SUCCESS - transmit succeeded
 *                  MRFI_TX_RESULT_FAILED  - transmit failed because CCA failed
 **************************************************************************************************
 */
uint8_t MRFI_Transmit(mrfiPacket_t * pPacket, uint8_t txType)
{
    c728:	0b 12       	push	r11		
    c72a:	0a 12       	push	r10		
    c72c:	09 12       	push	r9		
    c72e:	21 83       	decd	r1		
    c730:	09 4f       	mov	r15,	r9	
    c732:	4b 4e       	mov.b	r14,	r11	
#endif
  uint8_t ccaRetries;
  uint8_t returnValue = MRFI_TX_RESULT_SUCCESS;

  /* radio must be awake to transmit */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c734:	d2 93 4c 02 	cmp.b	#1,	&0x024c	;r3 As==01
    c738:	2e 24       	jz	$+94     	;abs 0xc796

  /* Turn off reciever. We can ignore/drop incoming packets during transmit. */
  Mrfi_RxModeOff();
    c73a:	b0 12 42 c5 	call	#0xc542	

  MRFI_PrepareToTx( pPacket );
    c73e:	0f 49       	mov	r9,	r15	
    c740:	b0 12 0e c7 	call	#0xc70e	

  /* ------------------------------------------------------------------
   *    Immediate transmit
   *   ---------------------
   */
  if (txType == MRFI_TX_TYPE_FORCED)
    c744:	4b 93       	tst.b	r11		
    c746:	05 24       	jz	$+12     	;abs 0xc752
    /* ------------------------------------------------------------------
     *    CCA transmit
     *   ---------------
     */

    MRFI_ASSERT( txType == MRFI_TX_TYPE_CCA );
    c748:	5b 93       	cmp.b	#1,	r11	;r3 As==01
    c74a:	28 24       	jz	$+82     	;abs 0xc79c
    c74c:	32 c2       	dint			
    c74e:	03 43       	nop			
    c750:	ff 3f       	jmp	$+0      	;abs 0xc750
    MRFI_CompleteTxPrep( pPacket );
    } while( 0 );
#endif

    /* Issue the TX strobe. */
    mrfiSpiCmdStrobe( STX );
    c752:	7f 40 35 00 	mov.b	#53,	r15	;#0x0035
    c756:	b0 12 e6 c4 	call	#0xc4e6	
#ifdef NWK_PLL
    BSP_EXIT_CRITICAL_SECTION(s);
#endif

    /* Wait for transmit to complete */
    Mrfi_DelayUsecLong( MRFI_MAX_TRANSMIT_TIME_us / 1000,
    c75a:	3c 40 6c c1 	mov	#-16020,r12	;#0xc16c
    c75e:	3d 40 cc 01 	mov	#460,	r13	;#0x01cc
    c762:	1e 43       	mov	#1,	r14	;r3 As==01
    c764:	0f 43       	clr	r15		
    c766:	b0 12 54 c3 	call	#0xc354	
                        MRFI_MAX_TRANSMIT_TIME_us % 1000,
                        mrfi_TxImmediateDone );

    /* Clear the interrupt flag */
    MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    c76a:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    c76e:	2b 00 
#endif
  /*
   * Flush the transmit FIFO.  It must be flushed so that
   * the next transmit can start with a clean slate.
   */
  mrfiSpiCmdStrobe( SFTX );
    c770:	7f 40 3b 00 	mov.b	#59,	r15	;#0x003b
    c774:	b0 12 e6 c4 	call	#0xc4e6	

  /* Restore GDO_0 to be SYNC signal */
  MRFI_CONFIG_GDO0_AS_SYNC_SIGNAL();
    c778:	7e 40 06 00 	mov.b	#6,	r14	;#0x0006
    c77c:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c77e:	b0 12 8a c6 	call	#0xc68a	

  /* If the radio was in RX state when transmit was attempted,
   * put it back to Rx On state.
   */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
    c782:	f2 90 03 00 	cmp.b	#3,	&0x024c	;#0x0003
    c786:	4c 02 
    c788:	76 24       	jz	$+238    	;abs 0xc876
  {
    Mrfi_RxModeOn();
  }

  return( returnValue );
}
    c78a:	4f 4b       	mov.b	r11,	r15	
    c78c:	21 53       	incd	r1		
    c78e:	39 41       	pop	r9		
    c790:	3a 41       	pop	r10		
    c792:	3b 41       	pop	r11		
    c794:	30 41       	ret			
#endif
  uint8_t ccaRetries;
  uint8_t returnValue = MRFI_TX_RESULT_SUCCESS;

  /* radio must be awake to transmit */
  MRFI_ASSERT( mrfiRadioState != MRFI_RADIO_STATE_OFF );
    c796:	32 c2       	dint			
    c798:	03 43       	nop			
    c79a:	ff 3f       	jmp	$+0      	;abs 0xc79a
     * can re-configure the GDO_0 output from the radio to be PA_PD signal
     * instead of the SYNC signal.
     * Since both SYNC and PA_PD are used as falling edge interrupts, we
     * don't need to reconfigure the MCU input.
     */
    MRFI_CONFIG_GDO0_AS_PAPD_SIGNAL();
    c79c:	7e 40 1b 00 	mov.b	#27,	r14	;#0x001b
    c7a0:	6f 43       	mov.b	#2,	r15	;r3 As==10
    c7a2:	b0 12 8a c6 	call	#0xc68a	
    c7a6:	7b 40 05 00 	mov.b	#5,	r11	;#0x0005
       */

      /* Can not use the Mrfi_RxModeOn() function here since it turns on the
       * Rx interrupt, which we don't want in this case.
       */
      mrfiSpiCmdStrobe( SRX );
    c7aa:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    c7ae:	b0 12 e6 c4 	call	#0xc4e6	
    c7b2:	3a 40 10 00 	mov	#16,	r10	;#0x0010
    c7b6:	06 3c       	jmp	$+14     	;abs 0xc7c4

      /* wait for the rssi to be valid. */
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
      MRFI_WaitTimeoutUsec(MRFI_RSSI_VALID_DELAY_US, Mrfi_ValidateRSSI);
#else // MRFI_TIMER_ALWAYS_ACTIVE
      MRFI_RSSI_VALID_WAIT();
    c7b8:	3f 40 40 00 	mov	#64,	r15	;#0x0040
    c7bc:	b0 12 d0 c1 	call	#0xc1d0	
    c7c0:	3a 53       	add	#-1,	r10	;r3 As==11
    c7c2:	07 24       	jz	$+16     	;abs 0xc7d2
    c7c4:	7f 40 38 00 	mov.b	#56,	r15	;#0x0038
    c7c8:	b0 12 04 c6 	call	#0xc604	
    c7cc:	3f b0 50 00 	bit	#80,	r15	;#0x0050
    c7d0:	f3 27       	jz	$-24     	;abs 0xc7b8
       *  is used to capture the transition that indicates a transmit was started.
       *  The pin level cannot be used to indicate transmit success as timing may
       *  prevent the transition from being detected.  The interrupt latch captures
       *  the event regardless of timing.
       */
      MRFI_CLEAR_PAPD_PIN_INT_FLAG();
    c7d2:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    c7d6:	2b 00 

      /* Issue the TX strobe. */
      mrfiSpiCmdStrobe( STX );
    c7d8:	7f 40 35 00 	mov.b	#53,	r15	;#0x0035
    c7dc:	b0 12 e6 c4 	call	#0xc4e6	
       * successful transmit. This is the 250 XOSC periods
       * (9.6 us for a 26 MHz crystal) See section 19.6 of 2500 datasheet.
       * Found out that we need a delay of atleast 20 us on CC2500 and
       * 25 us on CC1100 to see the PA_PD signal change.
       */
      Mrfi_DelayUsec(25);
    c7e0:	3f 40 19 00 	mov	#25,	r15	;#0x0019
    c7e4:	b0 12 d0 c1 	call	#0xc1d0	

      /* PA_PD signal goes from HIGH to LOW when going from RX state.
       * This transition is trapped as a falling edge interrupt flag
       * to indicate that CCA passed and the transmit has started.
       */
      if (MRFI_PAPD_INT_FLAG_IS_SET())
    c7e8:	5f 42 2b 00 	mov.b	&0x002b,r15	
    c7ec:	1f f3       	and	#1,	r15	;r3 As==01
    c7ee:	36 20       	jnz	$+110    	;abs 0xc85c
        /* Turn off radio and save some power during backoff */

        /* NOTE: Can't use Mrfi_RxModeOff() - since it tries to update the
         * sync signal status which we are not using during the TX operation.
         */
        MRFI_STROBE_IDLE_AND_WAIT();
    c7f0:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    c7f4:	b0 12 e6 c4 	call	#0xc4e6	
    c7f8:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    c7fc:	b0 12 e6 c4 	call	#0xc4e6	
    c800:	3f b0 f0 00 	bit	#240,	r15	;#0x00f0
    c804:	f9 23       	jnz	$-12     	;abs 0xc7f8

        /* flush the receive FIFO of any residual data */
        mrfiSpiCmdStrobe( SFRX );
    c806:	7f 40 3a 00 	mov.b	#58,	r15	;#0x003a
    c80a:	b0 12 e6 c4 	call	#0xc4e6	
    c80e:	7b 53       	add.b	#-1,	r11	;r3 As==11

        /* Retry ? */
        if (ccaRetries != 0)
    c810:	23 24       	jz	$+72     	;abs 0xc858
 * @return      a random byte
 **************************************************************************************************
 */
uint8_t MRFI_RandomByte(void)
{
  mrfiRndSeed = (mrfiRndSeed*MRFI_RANDOM_MULTIPLIER) + MRFI_RANDOM_OFFSET;
    c812:	5f 42 4d 02 	mov.b	&0x024d,r15	
    c816:	4d 4f       	mov.b	r15,	r13	
    c818:	4d 5d       	rla.b	r13		
    c81a:	4d 5f       	add.b	r15,	r13	
    c81c:	4d 5d       	rla.b	r13		
    c81e:	4d 5d       	rla.b	r13		
    c820:	4e 4d       	mov.b	r13,	r14	
    c822:	4e 5e       	rla.b	r14		
    c824:	4e 5e       	rla.b	r14		
    c826:	4e 5e       	rla.b	r14		
    c828:	4e 5d       	add.b	r13,	r14	
    c82a:	4e 5f       	add.b	r15,	r14	
    c82c:	7e 50 43 00 	add.b	#67,	r14	;#0x0043
    c830:	c2 4e 4d 02 	mov.b	r14,	&0x024d	
{
  uint8_t backoffs;
  uint8_t i;

  /* calculate random value for backoffs - 1 to 16 */
  backoffs = (MRFI_RandomByte() & 0x0F) + 1;
    c834:	7e f0 0f 00 	and.b	#15,	r14	;#0x000f
    c838:	5e 53       	inc.b	r14		

  /* delay for randomly computed number of backoff periods */
  for (i=0; i<backoffs; i++)
    c83a:	4a 43       	clr.b	r10		
  {
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
    MRFI_DelayUsec( sBackoffHelper );
#else
    Mrfi_DelayUsec( sBackoffHelper );
    c83c:	1f 42 50 02 	mov	&0x0250,r15	
    c840:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    c844:	b0 12 d0 c1 	call	#0xc1d0	

  /* calculate random value for backoffs - 1 to 16 */
  backoffs = (MRFI_RandomByte() & 0x0F) + 1;

  /* delay for randomly computed number of backoff periods */
  for (i=0; i<backoffs; i++)
    c848:	5a 53       	inc.b	r10		
    c84a:	2e 41       	mov	@r1,	r14	
    c84c:	4a 9e       	cmp.b	r14,	r10	
    c84e:	f6 2b       	jnc	$-18     	;abs 0xc83c
          stx_active = false;
#endif
          /* delay for a random number of backoffs */
          Mrfi_RandomBackoffDelay();

          MRFI_PrepareToTx( pPacket ); // setup transmission again
    c850:	0f 49       	mov	r9,	r15	
    c852:	b0 12 0e c7 	call	#0xc70e	
          /* set return value for failed transmit and break */
          returnValue = MRFI_TX_RESULT_FAILED;
          break;
        }
      } /* CCA Failed */
    } /* CCA loop */
    c856:	a9 3f       	jmp	$-172    	;abs 0xc7aa
          ccaRetries--;
        }
        else /* No CCA retries are left, abort */
        {
          /* set return value for failed transmit and break */
          returnValue = MRFI_TX_RESULT_FAILED;
    c858:	5b 43       	mov.b	#1,	r11	;r3 As==01
    c85a:	8a 3f       	jmp	$-234    	;abs 0xc770
        *    Clear Channel Assessment passed.
        *   ----------------------------------
        */

        /* Clear the PA_PD int flag */
        MRFI_CLEAR_PAPD_PIN_INT_FLAG();
    c85c:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    c860:	2b 00 

        Mrfi_DelayUsecLong( MRFI_MAX_TRANSMIT_TIME_us / 1000,
    c862:	3c 40 64 c1 	mov	#-16028,r12	;#0xc164
    c866:	3d 40 cc 01 	mov	#460,	r13	;#0x01cc
    c86a:	1e 43       	mov	#1,	r14	;r3 As==01
    c86c:	0f 43       	clr	r15		
    c86e:	b0 12 54 c3 	call	#0xc354	
{
#ifdef NWK_PLL
    bspIState_t s;
#endif
  uint8_t ccaRetries;
  uint8_t returnValue = MRFI_TX_RESULT_SUCCESS;
    c872:	4b 43       	clr.b	r11		
        Mrfi_DelayUsecLong( MRFI_MAX_TRANSMIT_TIME_us / 1000,
                            MRFI_MAX_TRANSMIT_TIME_us % 1000,
                            mrfi_TxCCADone );

        /* transmit done, break */
        break;
    c874:	7d 3f       	jmp	$-260    	;abs 0xc770
  /* If the radio was in RX state when transmit was attempted,
   * put it back to Rx On state.
   */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
  {
    Mrfi_RxModeOn();
    c876:	b0 12 9a c5 	call	#0xc59a	
  }

  return( returnValue );
}
    c87a:	4f 4b       	mov.b	r11,	r15	
    c87c:	21 53       	incd	r1		
    c87e:	39 41       	pop	r9		
    c880:	3a 41       	pop	r10		
    c882:	3b 41       	pop	r11		
    c884:	30 41       	ret			

0000c886 <mrfiSpiReadRxFifo>:
 * @return      true if an interrupt was detected during the transfer, false otherwise
 **************************************************************************************************
 */
bool mrfiSpiReadRxFifo(uint8_t * pData, uint8_t len)
{
  return spiBurstFifoAccess(RXFIFO | BURST_BIT | READ_BIT, pData, len);
    c886:	4d 4e       	mov.b	r14,	r13	
    c888:	0e 4f       	mov	r15,	r14	
    c88a:	7f 43       	mov.b	#-1,	r15	;r3 As==11
    c88c:	b0 12 1c c2 	call	#0xc21c	
}
    c890:	30 41       	ret			

0000c892 <MRFI_SetLogicalChannel>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_SetLogicalChannel(uint8_t chan)
{
    c892:	21 83       	decd	r1		
  /* logical channel is not valid? */
  MRFI_ASSERT( chan < MRFI_NUM_LOGICAL_CHANS );
    c894:	6f 92       	cmp.b	#4,	r15	;r2 As==10
    c896:	03 28       	jnc	$+8      	;abs 0xc89e
    c898:	32 c2       	dint			
    c89a:	03 43       	nop			
    c89c:	ff 3f       	jmp	$+0      	;abs 0xc89c

  /* make sure radio is off before changing channels */
  Mrfi_RxModeOff();
    c89e:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    c8a2:	b0 12 42 c5 	call	#0xc542	

  MRFI_WRITE_REGISTER( CHANNR, mrfiLogicalChanTable[chan] );
    c8a6:	2f 41       	mov	@r1,	r15	
    c8a8:	4f 4f       	mov.b	r15,	r15	
    c8aa:	5e 4f c8 e4 	mov.b	-6968(r15),r14	;0xe4c8(r15)
    c8ae:	7f 40 0a 00 	mov.b	#10,	r15	;#0x000a
    c8b2:	b0 12 8a c6 	call	#0xc68a	

  /* turn radio back on if it was on before channel change */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
    c8b6:	f2 90 03 00 	cmp.b	#3,	&0x024c	;#0x0003
    c8ba:	4c 02 
    c8bc:	02 24       	jz	$+6      	;abs 0xc8c2
  {
    Mrfi_RxModeOn();
  }
}
    c8be:	21 53       	incd	r1		
    c8c0:	30 41       	ret			
  MRFI_WRITE_REGISTER( CHANNR, mrfiLogicalChanTable[chan] );

  /* turn radio back on if it was on before channel change */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
  {
    Mrfi_RxModeOn();
    c8c2:	b0 12 9a c5 	call	#0xc59a	
  }
}
    c8c6:	21 53       	incd	r1		
    c8c8:	30 41       	ret			

0000c8ca <MRFI_SetRFPwr>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_SetRFPwr(uint8_t idx)
{
    c8ca:	21 83       	decd	r1		
  /* is power level specified valid? */
  MRFI_ASSERT( idx < MRFI_NUM_POWER_SETTINGS );
    c8cc:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    c8d0:	03 28       	jnc	$+8      	;abs 0xc8d8
    c8d2:	32 c2       	dint			
    c8d4:	03 43       	nop			
    c8d6:	ff 3f       	jmp	$+0      	;abs 0xc8d6

  /* make sure radio is off before changing power levels */
  Mrfi_RxModeOff();
    c8d8:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    c8dc:	b0 12 42 c5 	call	#0xc542	

  MRFI_WRITE_REGISTER( PA_TABLE0, mrfiRFPowerTable[idx] );
    c8e0:	2f 41       	mov	@r1,	r15	
    c8e2:	4f 4f       	mov.b	r15,	r15	
    c8e4:	5e 4f cc e4 	mov.b	-6964(r15),r14	;0xe4cc(r15)
    c8e8:	7f 40 3e 00 	mov.b	#62,	r15	;#0x003e
    c8ec:	b0 12 8a c6 	call	#0xc68a	

  /* turn radio back on if it was on before power level change */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
    c8f0:	f2 90 03 00 	cmp.b	#3,	&0x024c	;#0x0003
    c8f4:	4c 02 
    c8f6:	02 24       	jz	$+6      	;abs 0xc8fc
  {
    Mrfi_RxModeOn();
  }
}
    c8f8:	21 53       	incd	r1		
    c8fa:	30 41       	ret			
  MRFI_WRITE_REGISTER( PA_TABLE0, mrfiRFPowerTable[idx] );

  /* turn radio back on if it was on before power level change */
  if(mrfiRadioState == MRFI_RADIO_STATE_RX)
  {
    Mrfi_RxModeOn();
    c8fc:	b0 12 9a c5 	call	#0xc59a	
  }
}
    c900:	21 53       	incd	r1		
    c902:	30 41       	ret			

0000c904 <MRFI_Init>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_Init(void)
{
    c904:	0b 12       	push	r11		
    c906:	0a 12       	push	r10		
  /* ------------------------------------------------------------------
   *    Initialization
   *   -----------------
   */

  memset(&mrfiIncomingPacket, 0x0, sizeof(mrfiIncomingPacket));
    c908:	82 43 34 02 	mov	#0,	&0x0234	;r3 As==00
    c90c:	82 43 36 02 	mov	#0,	&0x0236	;r3 As==00
    c910:	82 43 38 02 	mov	#0,	&0x0238	;r3 As==00
    c914:	82 43 3a 02 	mov	#0,	&0x023a	;r3 As==00
    c918:	82 43 3c 02 	mov	#0,	&0x023c	;r3 As==00
    c91c:	82 43 3e 02 	mov	#0,	&0x023e	;r3 As==00
    c920:	82 43 40 02 	mov	#0,	&0x0240	;r3 As==00
    c924:	82 43 42 02 	mov	#0,	&0x0242	;r3 As==00
    c928:	82 43 44 02 	mov	#0,	&0x0244	;r3 As==00
    c92c:	82 43 46 02 	mov	#0,	&0x0246	;r3 As==00
    c930:	82 43 48 02 	mov	#0,	&0x0248	;r3 As==00
    c934:	82 43 4a 02 	mov	#0,	&0x024a	;r3 As==00
  FHSS_ACTIVE( sLogicalChannel = MRFI_RandomByte( ) % MRFI_NUM_LOGICAL_CHANS );
  FHSS_ACTIVE( sHopNowSem = 0 );
  FHSS_ACTIVE( sHopRate = MRFI_HOP_TIME_ms - 1 );

  /* initialize GPIO pins */
  MRFI_CONFIG_GDO0_PIN_AS_INPUT();
    c938:	f2 f0 fe ff 	and.b	#-2,	&0x002e	;#0xfffe
    c93c:	2e 00 

  /* initialize SPI */
  mrfiSpiInit();
    c93e:	b0 12 a2 c4 	call	#0xc4a2	

  /* ------------------------------------------------------------------
   *    Radio power-up reset
   *   ----------------------
   */
  MRFI_ASSERT(MRFI_SPI_CSN_IS_HIGH());
    c942:	5f 42 21 00 	mov.b	&0x0021,r15	
    c946:	3f f0 10 00 	and	#16,	r15	;#0x0010
    c94a:	03 20       	jnz	$+8      	;abs 0xc952
    c94c:	32 c2       	dint			
    c94e:	03 43       	nop			
    c950:	ff 3f       	jmp	$+0      	;abs 0xc950

  /* pulse CSn low then high */
  MRFI_SPI_DRIVE_CSN_LOW();
    c952:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c956:	21 00 
  Mrfi_DelayUsec(10);
    c958:	3f 40 0a 00 	mov	#10,	r15	;#0x000a
    c95c:	b0 12 d0 c1 	call	#0xc1d0	
  MRFI_SPI_DRIVE_CSN_HIGH();
    c960:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c964:	21 00 

  /* hold CSn high for at least 40 microseconds */
  Mrfi_DelayUsec(40);
    c966:	3f 40 28 00 	mov	#40,	r15	;#0x0028
    c96a:	b0 12 d0 c1 	call	#0xc1d0	

  /* pull CSn low and wait for SO to go low */
  MRFI_SPI_DRIVE_CSN_LOW();
    c96e:	f2 f0 ef ff 	and.b	#-17,	&0x0021	;#0xffef
    c972:	21 00 
  while (MRFI_SPI_SO_IS_HIGH());
    c974:	5f 42 20 00 	mov.b	&0x0020,r15	
    c978:	3f f0 40 00 	and	#64,	r15	;#0x0040
    c97c:	fb 23       	jnz	$-8      	;abs 0xc974

  /* directly send strobe command - cannot use function as it affects CSn pin */
  MRFI_SPI_WRITE_BYTE(SRES);
    c97e:	f2 f0 fb ff 	and.b	#-5,	&0x0003	;#0xfffb
    c982:	03 00 
    c984:	f2 40 30 00 	mov.b	#48,	&0x006f	;#0x0030
    c988:	6f 00 
  MRFI_SPI_WAIT_DONE();
    c98a:	5f 42 03 00 	mov.b	&0x0003,r15	
    c98e:	2f f2       	and	#4,	r15	;r2 As==10
    c990:	fc 27       	jz	$-6      	;abs 0xc98a

  /* wait for SO to go low again, reset is complete at that point */
  while (MRFI_SPI_SO_IS_HIGH());
    c992:	5f 42 20 00 	mov.b	&0x0020,r15	
    c996:	3f f0 40 00 	and	#64,	r15	;#0x0040
    c99a:	fb 23       	jnz	$-8      	;abs 0xc992

  /* return CSn pin to its default high level */
  MRFI_SPI_DRIVE_CSN_HIGH();
    c99c:	f2 d0 10 00 	bis.b	#16,	&0x0021	;#0x0010
    c9a0:	21 00 
   */

  /* verify that SPI is working, PKTLEN is an arbitrary read/write register used for testing */
#ifdef MRFI_ASSERTS_ARE_ON
#define TEST_VALUE 0xA5
  mrfiSpiWriteReg( PKTLEN, TEST_VALUE );
    c9a2:	7e 40 a5 ff 	mov.b	#-91,	r14	;#0xffa5
    c9a6:	7f 40 06 00 	mov.b	#6,	r15	;#0x0006
    c9aa:	b0 12 8a c6 	call	#0xc68a	
  MRFI_ASSERT( mrfiSpiReadReg( PKTLEN ) == TEST_VALUE ); /* SPI is not responding */
    c9ae:	7f 40 06 00 	mov.b	#6,	r15	;#0x0006
    c9b2:	b0 12 04 c6 	call	#0xc604	
    c9b6:	7f 90 a5 ff 	cmp.b	#-91,	r15	;#0xffa5
    c9ba:	03 24       	jz	$+8      	;abs 0xc9c2
    c9bc:	32 c2       	dint			
    c9be:	03 43       	nop			
    c9c0:	ff 3f       	jmp	$+0      	;abs 0xc9c0
#endif

  /* verify the correct radio is installed */
  MRFI_ASSERT( mrfiSpiReadReg( PARTNUM ) == MRFI_RADIO_PARTNUM );      /* incorrect radio specified */
    c9c2:	7f 40 30 00 	mov.b	#48,	r15	;#0x0030
    c9c6:	b0 12 04 c6 	call	#0xc604	
    c9ca:	7f 90 80 ff 	cmp.b	#-128,	r15	;#0xff80
    c9ce:	03 24       	jz	$+8      	;abs 0xc9d6
    c9d0:	32 c2       	dint			
    c9d2:	03 43       	nop			
    c9d4:	ff 3f       	jmp	$+0      	;abs 0xc9d4
  MRFI_ASSERT( mrfiSpiReadReg( VERSION ) >= MRFI_RADIO_MIN_VERSION );  /* obsolete radio specified  */
    c9d6:	7f 40 31 00 	mov.b	#49,	r15	;#0x0031
    c9da:	b0 12 04 c6 	call	#0xc604	
    c9de:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    c9e0:	6b 24       	jz	$+216    	;abs 0xcab8
    c9e2:	6a 28       	jnc	$+214    	;abs 0xcab8
    c9e4:	3b 40 8d e4 	mov	#-7027,	r11	;#0xe48d
  {
    uint8_t i;

    for (i=0; i<(sizeof(mrfiRadioCfg)/sizeof(mrfiRadioCfg[0])); i++)
    {
      mrfiSpiWriteReg(mrfiRadioCfg[i][0], mrfiRadioCfg[i][1]);
    c9e8:	6e 4b       	mov.b	@r11,	r14	
    c9ea:	5f 4b ff ff 	mov.b	-1(r11),r15	;0xffff(r11)
    c9ee:	b0 12 8a c6 	call	#0xc68a	
    c9f2:	2b 53       	incd	r11		

  /* initialize radio registers */
  {
    uint8_t i;

    for (i=0; i<(sizeof(mrfiRadioCfg)/sizeof(mrfiRadioCfg[0])); i++)
    c9f4:	3b 90 c9 e4 	cmp	#-6967,	r11	;#0xe4c9
    c9f8:	f7 23       	jnz	$-16     	;abs 0xc9e8
      mrfiSpiWriteReg(mrfiRadioCfg[i][0], mrfiRadioCfg[i][1]);
    }
  }

  /* Initial radio state is IDLE state */
  mrfiRadioState = MRFI_RADIO_STATE_IDLE;
    c9fa:	e2 43 4c 02 	mov.b	#2,	&0x024c	;r3 As==10

  /* set default channel */
  MRFI_SetLogicalChannel( 0 );
    c9fe:	4f 43       	clr.b	r15		
    ca00:	b0 12 92 c8 	call	#0xc892	

  /* set default power */
  MRFI_SetRFPwr(MRFI_NUM_POWER_SETTINGS - 1);
    ca04:	6f 43       	mov.b	#2,	r15	;r3 As==10
    ca06:	b0 12 ca c8 	call	#0xc8ca	
  /* Generate Random seed:
   * We will use the RSSI value to generate our random seed.
   */

  /* Put the radio in RX state */
  mrfiSpiCmdStrobe( SRX );
    ca0a:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    ca0e:	b0 12 e6 c4 	call	#0xc4e6	
    ca12:	3b 40 10 00 	mov	#16,	r11	;#0x0010
    ca16:	06 3c       	jmp	$+14     	;abs 0xca24

  /* delay for the rssi to be valid */
#ifdef MRFI_TIMER_ALWAYS_ACTIVE
  MRFI_WaitTimeoutUsec(MRFI_RSSI_VALID_DELAY_US, Mrfi_ValidateRSSI);
#else // MRFI_TIMER_ALWAYS_ACTIVE
  MRFI_RSSI_VALID_WAIT();
    ca18:	3f 40 40 00 	mov	#64,	r15	;#0x0040
    ca1c:	b0 12 d0 c1 	call	#0xc1d0	
    ca20:	3b 53       	add	#-1,	r11	;r3 As==11
    ca22:	07 24       	jz	$+16     	;abs 0xca32
    ca24:	7f 40 38 00 	mov.b	#56,	r15	;#0x0038
    ca28:	b0 12 04 c6 	call	#0xc604	
    ca2c:	3f b0 50 00 	bit	#80,	r15	;#0x0050
    ca30:	f3 27       	jz	$-24     	;abs 0xca18
    ca32:	5b 42 4d 02 	mov.b	&0x024d,r11	
  /* Generate Random seed:
   * We will use the RSSI value to generate our random seed.
   */

  /* Put the radio in RX state */
  mrfiSpiCmdStrobe( SRX );
    ca36:	7a 40 10 00 	mov.b	#16,	r10	;#0x0010
  /* use most random bit of rssi to populate the random seed */
  {
    uint8_t i;
    for(i=0; i<16; i++)
    {
      mrfiRndSeed = (mrfiRndSeed << 1) | (mrfiSpiReadReg(RSSI) & 0x01);
    ca3a:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    ca3e:	b0 12 04 c6 	call	#0xc604	
    ca42:	4e 4b       	mov.b	r11,	r14	
    ca44:	0e 5e       	rla	r14		
    ca46:	4b 4f       	mov.b	r15,	r11	
    ca48:	5b f3       	and.b	#1,	r11	;r3 As==01
    ca4a:	4b de       	bis.b	r14,	r11	
    ca4c:	c2 4b 4d 02 	mov.b	r11,	&0x024d	
    ca50:	7a 53       	add.b	#-1,	r10	;r3 As==11
#endif // MRFI_TIMER_ALWAYS_ACTIVE

  /* use most random bit of rssi to populate the random seed */
  {
    uint8_t i;
    for(i=0; i<16; i++)
    ca52:	f3 23       	jnz	$-24     	;abs 0xca3a
      mrfiRndSeed = (mrfiRndSeed << 1) | (mrfiSpiReadReg(RSSI) & 0x01);
    }
  }

  /* Force the seed to be non-zero by setting one bit, just in case... */
  mrfiRndSeed |= 0x0080;
    ca54:	7b d0 80 ff 	bis.b	#-128,	r11	;#0xff80
    ca58:	c2 4b 4d 02 	mov.b	r11,	&0x024d	

  /* Turn off RF. */
  Mrfi_RxModeOff();
    ca5c:	b0 12 42 c5 	call	#0xc542	
    dataRate = mantissa * (MRFI_RADIO_OSC_FREQ>>exponent);

    bits = ((uint32_t)((PHY_PREAMBLE_SYNC_BYTES + MRFI_MAX_FRAME_SIZE)*8))*10000;

    /* processing on the peer + the Tx/Rx time plus more */
    sReplyDelayScalar = PLATFORM_FACTOR_CONSTANT + (((bits/dataRate)+5)/10);
    ca60:	b2 40 33 00 	mov	#51,	&0x024e	;#0x0033
    ca64:	4e 02 
     * we just calculated divided by 32. With the backoff algorithm backing
     * off up to 16 periods this will result in waiting up to about 1/2 the total
     * scalar value. For high data rates this does not contribute at all. Value
     * is in microseconds.
     */
    sBackoffHelper = MRFI_BACKOFF_PERIOD_USECS + (sReplyDelayScalar>>5)*1000;
    ca66:	b2 40 e2 04 	mov	#1250,	&0x0250	;#0x04e2
    ca6a:	50 02 
  }

  /* Clean out buffer to protect against spurious frames */
  memset(mrfiIncomingPacket.frame, 0x00, sizeof(mrfiIncomingPacket.frame));
    ca6c:	82 43 34 02 	mov	#0,	&0x0234	;r3 As==00
    ca70:	82 43 36 02 	mov	#0,	&0x0236	;r3 As==00
    ca74:	82 43 38 02 	mov	#0,	&0x0238	;r3 As==00
    ca78:	82 43 3a 02 	mov	#0,	&0x023a	;r3 As==00
    ca7c:	82 43 3c 02 	mov	#0,	&0x023c	;r3 As==00
    ca80:	82 43 3e 02 	mov	#0,	&0x023e	;r3 As==00
    ca84:	82 43 40 02 	mov	#0,	&0x0240	;r3 As==00
    ca88:	82 43 42 02 	mov	#0,	&0x0242	;r3 As==00
    ca8c:	82 43 44 02 	mov	#0,	&0x0244	;r3 As==00
    ca90:	82 43 46 02 	mov	#0,	&0x0246	;r3 As==00
    ca94:	82 43 48 02 	mov	#0,	&0x0248	;r3 As==00
  memset(mrfiIncomingPacket.rxMetrics, 0x00, sizeof(mrfiIncomingPacket.rxMetrics));
    ca98:	82 43 4a 02 	mov	#0,	&0x024a	;r3 As==00
   *  This interrupt is used to indicate receive.  The SYNC signal goes
   *  high when a receive OR a transmit begins.  It goes high once the
   *  sync word is received or transmitted and then goes low again once
   *  the packet completes.
   */
  MRFI_CONFIG_GDO0_AS_SYNC_SIGNAL();
    ca9c:	7e 40 06 00 	mov.b	#6,	r14	;#0x0006
    caa0:	6f 43       	mov.b	#2,	r15	;r3 As==10
    caa2:	b0 12 8a c6 	call	#0xc68a	
  MRFI_CONFIG_SYNC_PIN_FALLING_EDGE_INT();
    caa6:	d2 d3 2c 00 	bis.b	#1,	&0x002c	;r3 As==01
  MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    caaa:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    caae:	2b 00 

  /* enable global interrupts */
  BSP_ENABLE_INTERRUPTS();
    cab0:	32 d2       	eint			
}
    cab2:	3a 41       	pop	r10		
    cab4:	3b 41       	pop	r11		
    cab6:	30 41       	ret			
  MRFI_ASSERT( mrfiSpiReadReg( PKTLEN ) == TEST_VALUE ); /* SPI is not responding */
#endif

  /* verify the correct radio is installed */
  MRFI_ASSERT( mrfiSpiReadReg( PARTNUM ) == MRFI_RADIO_PARTNUM );      /* incorrect radio specified */
  MRFI_ASSERT( mrfiSpiReadReg( VERSION ) >= MRFI_RADIO_MIN_VERSION );  /* obsolete radio specified  */
    cab8:	32 c2       	dint			
    caba:	03 43       	nop			
    cabc:	ff 3f       	jmp	$+0      	;abs 0xcabc

0000cabe <MRFI_SetRxAddrFilter>:
 * @return      zero     : successfully set filter address
 *              non-zero : illegal address
 **************************************************************************************************
 */
uint8_t MRFI_SetRxAddrFilter(uint8_t * pAddr)
{
    cabe:	0b 12       	push	r11		
    cac0:	0b 4f       	mov	r15,	r11	
  /*
   *  If first byte of filter address match fir byte of broadcast address,
   *  there is a conflict with hardware filtering.
   */
  if (pAddr[0] == mrfiBroadcastAddr[0])
    cac2:	6e 4f       	mov.b	@r15,	r14	
    cac4:	7e 93       	cmp.b	#-1,	r14	;r3 As==11
    cac6:	0f 24       	jz	$+32     	;abs 0xcae6

  /*
   *  Set the hardware address register.  The hardware address filtering only recognizes
   *  a single byte but this does provide at least some automatic hardware filtering.
   */
  MRFI_WRITE_REGISTER( ADDR, pAddr[0] );
    cac8:	7f 40 09 00 	mov.b	#9,	r15	;#0x0009
    cacc:	b0 12 8a c6 	call	#0xc68a	
    cad0:	0e 43       	clr	r14		
 *
 * @return      zero     : successfully set filter address
 *              non-zero : illegal address
 **************************************************************************************************
 */
uint8_t MRFI_SetRxAddrFilter(uint8_t * pAddr)
    cad2:	0d 4b       	mov	r11,	r13	
    cad4:	0d 5e       	add	r14,	r13	
  {
    uint8_t i;

    for (i=0; i<MRFI_ADDR_SIZE; i++)
    {
      mrfiRxFilterAddr[i] = pAddr[i];
    cad6:	ee 4d 00 02 	mov.b	@r13,	512(r14);0x0200(r14)
    cada:	1e 53       	inc	r14		

  /* save a copy of the filter address */
  {
    uint8_t i;

    for (i=0; i<MRFI_ADDR_SIZE; i++)
    cadc:	2e 92       	cmp	#4,	r14	;r2 As==10
    cade:	f9 23       	jnz	$-12     	;abs 0xcad2
      mrfiRxFilterAddr[i] = pAddr[i];
    }
  }

  /* successfully set filter address */
  return( 0 );
    cae0:	4f 43       	clr.b	r15		
}
    cae2:	3b 41       	pop	r11		
    cae4:	30 41       	ret			
   *  there is a conflict with hardware filtering.
   */
  if (pAddr[0] == mrfiBroadcastAddr[0])
  {
    /* unable to set filter address */
    return( 1 );
    cae6:	5f 43       	mov.b	#1,	r15	;r3 As==01
    }
  }

  /* successfully set filter address */
  return( 0 );
}
    cae8:	3b 41       	pop	r11		
    caea:	30 41       	ret			

0000caec <MRFI_EnableRxAddrFilter>:
 * @return      none
 **************************************************************************************************
 */
void MRFI_EnableRxAddrFilter(void)
{
  MRFI_ASSERT(mrfiRxFilterAddr[0] != mrfiBroadcastAddr[0]); /* filter address must be set before enabling filter */
    caec:	f2 93 00 02 	cmp.b	#-1,	&0x0200	;r3 As==11
    caf0:	09 24       	jz	$+20     	;abs 0xcb04

  /* set flag to indicate filtering is enabled */
  mrfiRxFilterEnabled = 1;
    caf2:	d2 43 53 02 	mov.b	#1,	&0x0253	;r3 As==01

  /* enable hardware filtering on the radio */
  MRFI_WRITE_REGISTER( PKTCTRL1, PKTCTRL1_ADDR_FILTER_ON );
    caf6:	7e 40 07 00 	mov.b	#7,	r14	;#0x0007
    cafa:	7f 40 07 00 	mov.b	#7,	r15	;#0x0007
    cafe:	b0 12 8a c6 	call	#0xc68a	
}
    cb02:	30 41       	ret			
 * @return      none
 **************************************************************************************************
 */
void MRFI_EnableRxAddrFilter(void)
{
  MRFI_ASSERT(mrfiRxFilterAddr[0] != mrfiBroadcastAddr[0]); /* filter address must be set before enabling filter */
    cb04:	32 c2       	dint			
    cb06:	03 43       	nop			
    cb08:	ff 3f       	jmp	$+0      	;abs 0xcb08

0000cb0a <MRFI_DisableRxAddrFilter>:
 **************************************************************************************************
 */
void MRFI_DisableRxAddrFilter(void)
{
  /* clear flag that indicates filtering is enabled */
  mrfiRxFilterEnabled = 0;
    cb0a:	c2 43 53 02 	mov.b	#0,	&0x0253	;r3 As==00

  /* disable hardware filtering on the radio */
  MRFI_WRITE_REGISTER( PKTCTRL1, PKTCTRL1_ADDR_FILTER_OFF );
    cb0e:	6e 42       	mov.b	#4,	r14	;r2 As==10
    cb10:	7f 40 07 00 	mov.b	#7,	r15	;#0x0007
    cb14:	b0 12 8a c6 	call	#0xc68a	
}
    cb18:	30 41       	ret			

0000cb1a <MRFI_RxAddrIsFiltered>:
 * @return      zero     : address is not filtered
 *              non-zero : address is filtered
 **************************************************************************************************
 */
uint8_t MRFI_RxAddrIsFiltered(uint8_t * pAddr)
{
    cb1a:	0b 12       	push	r11		
  uint8_t addrByte;
  uint8_t filterAddrMatches;
  uint8_t broadcastAddrMatches;

  /* first check to see if filtering is even enabled */
  if (!mrfiRxFilterEnabled)
    cb1c:	c2 93 53 02 	tst.b	&0x0253	
    cb20:	14 24       	jz	$+42     	;abs 0xcb4a
    cb22:	0e 43       	clr	r14		
    cb24:	4c 43       	clr.b	r12		
    cb26:	4b 43       	clr.b	r11		
 *
 * @return      zero     : address is not filtered
 *              non-zero : address is filtered
 **************************************************************************************************
 */
uint8_t MRFI_RxAddrIsFiltered(uint8_t * pAddr)
    cb28:	0d 4f       	mov	r15,	r13	
    cb2a:	0d 5e       	add	r14,	r13	

  /* loop through address to see if there is a match to filter address of broadcast address */
  for (i=0; i<MRFI_ADDR_SIZE; i++)
  {
    /* get byte from address to check */
    addrByte = pAddr[i];
    cb2c:	6d 4d       	mov.b	@r13,	r13	

    /* compare byte to filter address byte */
    if (addrByte == mrfiRxFilterAddr[i])
    cb2e:	ce 9d 00 02 	cmp.b	r13,	512(r14);0x0200(r14)
    cb32:	0e 24       	jz	$+30     	;abs 0xcb50
    {
      filterAddrMatches++;
    }
    if (addrByte == mrfiBroadcastAddr[i])
    cb34:	ce 9d 88 e4 	cmp.b	r13,	-7032(r14);0xe488(r14)
    cb38:	0f 24       	jz	$+32     	;abs 0xcb58
    {
      broadcastAddrMatches++;
    cb3a:	1e 53       	inc	r14		
  /* clear address byte match counts */
  filterAddrMatches    = 0;
  broadcastAddrMatches = 0;

  /* loop through address to see if there is a match to filter address of broadcast address */
  for (i=0; i<MRFI_ADDR_SIZE; i++)
    cb3c:	2e 92       	cmp	#4,	r14	;r2 As==10
    cb3e:	f4 23       	jnz	$-22     	;abs 0xcb28
  /*
   *  If address is *not* filtered, either the "filter address match count" or
   *  the "broadcast address match count" will equal the total number of bytes
   *  in the address.
   */
  if ((broadcastAddrMatches == MRFI_ADDR_SIZE) || (filterAddrMatches == MRFI_ADDR_SIZE))
    cb40:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    cb42:	03 24       	jz	$+8      	;abs 0xcb4a
  {
    /*
     *  Filtering is not enabled, so by definition the address is
     *  not filtered.  Return zero to indicate address is not filtered.
     */
    return( 0 );
    cb44:	5f 43       	mov.b	#1,	r15	;r3 As==01
    cb46:	6b 92       	cmp.b	#4,	r11	;r2 As==10
    cb48:	01 20       	jnz	$+4      	;abs 0xcb4c
   *  in the address.
   */
  if ((broadcastAddrMatches == MRFI_ADDR_SIZE) || (filterAddrMatches == MRFI_ADDR_SIZE))
  {
    /* address *not* filtered, return zero */
    return( 0 );
    cb4a:	4f 43       	clr.b	r15		
  else
  {
    /* address filtered, return non-zero */
    return( 1 );
  }
}
    cb4c:	3b 41       	pop	r11		
    cb4e:	30 41       	ret			
    addrByte = pAddr[i];

    /* compare byte to filter address byte */
    if (addrByte == mrfiRxFilterAddr[i])
    {
      filterAddrMatches++;
    cb50:	5b 53       	inc.b	r11		
    }
    if (addrByte == mrfiBroadcastAddr[i])
    cb52:	ce 9d 88 e4 	cmp.b	r13,	-7032(r14);0xe488(r14)
    cb56:	f1 23       	jnz	$-28     	;abs 0xcb3a
    {
      broadcastAddrMatches++;
    cb58:	5c 53       	inc.b	r12		
    cb5a:	ef 3f       	jmp	$-32     	;abs 0xcb3a

0000cb5c <MRFI_GpioIsr>:
 *
 * @return      none
 **************************************************************************************************
 */
void MRFI_GpioIsr(void)
{
    cb5c:	0b 12       	push	r11		
    cb5e:	21 83       	decd	r1		
    MRFI_GetLocalRawTime( sRxTimeStampAddr );

#endif

  /* see if sync pin interrupt is enabled and has fired */
  if (MRFI_SYNC_PIN_INT_IS_ENABLED() && MRFI_SYNC_PIN_INT_FLAG_IS_SET())
    cb60:	5f 42 2d 00 	mov.b	&0x002d,r15	
    cb64:	1f f3       	and	#1,	r15	;r3 As==01
    cb66:	04 24       	jz	$+10     	;abs 0xcb70
    cb68:	5f 42 2b 00 	mov.b	&0x002b,r15	
    cb6c:	1f f3       	and	#1,	r15	;r3 As==01
    cb6e:	03 20       	jnz	$+8      	;abs 0xcb76
     */
    MRFI_CLEAR_SYNC_PIN_INT_FLAG();

    Mrfi_SyncPinRxIsr();
  }
}
    cb70:	21 53       	incd	r1		
    cb72:	3b 41       	pop	r11		
    cb74:	30 41       	ret			
     *  reset the interrupt capture.  In other words, if a second interrupt
     *  occurs after the flag is cleared it must be processed, i.e. this interrupt
     *  exits then immediately starts again.  Most microcontrollers handle this
     *  naturally but it must be verified for every target.
     */
    MRFI_CLEAR_SYNC_PIN_INT_FLAG();
    cb76:	f2 f0 fe ff 	and.b	#-2,	&0x002b	;#0xfffe
    cb7a:	2b 00 
 * @return      none
 **************************************************************************************************
 */
static void Mrfi_SyncPinRxIsr(void)
{
  uint8_t frameLen = 0x00;
    cb7c:	c1 43 00 00 	mov.b	#0,	0(r1)	;r3 As==00, 0x0000(r1)
  /* We should receive this interrupt only in RX state
   * Should never receive it if RX was turned On only for
   * some internal mrfi processing like - during CCA.
   * Otherwise something is terribly wrong.
   */
  MRFI_ASSERT( mrfiRadioState == MRFI_RADIO_STATE_RX );
    cb80:	f2 90 03 00 	cmp.b	#3,	&0x024c	;#0x0003
    cb84:	4c 02 
    cb86:	03 24       	jz	$+8      	;abs 0xcb8e
    cb88:	32 c2       	dint			
    cb8a:	03 43       	nop			
    cb8c:	ff 3f       	jmp	$+0      	;abs 0xcb8c
   *  in a row to guarantee an accurate value.
   */
  {
    uint8_t rxBytesVerify;

    rxBytesVerify = mrfiSpiReadReg( RXBYTES );
    cb8e:	7f 40 3b 00 	mov.b	#59,	r15	;#0x003b
    cb92:	b0 12 04 c6 	call	#0xc604	
    cb96:	4b 4f       	mov.b	r15,	r11	
    cb98:	01 3c       	jmp	$+4      	;abs 0xcb9c

    do
    {
      rxBytes = rxBytesVerify;
      rxBytesVerify = mrfiSpiReadReg( RXBYTES );
    cb9a:	4b 4f       	mov.b	r15,	r11	
    cb9c:	7f 40 3b 00 	mov.b	#59,	r15	;#0x003b
    cba0:	b0 12 04 c6 	call	#0xc604	
    }
    while (rxBytes != rxBytesVerify);
    cba4:	4f 9b       	cmp.b	r11,	r15	
    cba6:	f9 23       	jnz	$-12     	;abs 0xcb9a
   *  It is possible nothing the FIFO is empty even though the interrupt fired.
   *  This can happen if address check is enabled and a non-matching packet is
   *  received.  In that case, the radio automatically removes the packet from
   *  the FIFO.
   */
  if (rxBytes == 0)
    cba8:	4b 93       	tst.b	r11		
    cbaa:	e2 27       	jz	$-58     	;abs 0xcb70
     *    Process frame length
     *   ----------------------
     */

    /* read the first byte from FIFO - the packet length */
    mrfiSpiReadRxFifo(&frameLen, MRFI_LENGTH_FIELD_SIZE);
    cbac:	5e 43       	mov.b	#1,	r14	;r3 As==01
    cbae:	0f 41       	mov	r1,	r15	
    cbb0:	b0 12 86 c8 	call	#0xc886	
     *   4) A failed transmit forced radio to IDLE state to flush the transmit FIFO.
     *      This could cause an active receive to be cut short.
     *
     *  Also check the sanity of the length to guard against rogue frames.
     */
    if ((rxBytes != (frameLen + MRFI_LENGTH_FIELD_SIZE + MRFI_RX_METRICS_SIZE))           ||
    cbb4:	6e 41       	mov.b	@r1,	r14	
    cbb6:	4f 4e       	mov.b	r14,	r15	
    cbb8:	4b 4b       	mov.b	r11,	r11	
    cbba:	0d 4f       	mov	r15,	r13	
    cbbc:	3d 50 03 00 	add	#3,	r13	;#0x0003
    cbc0:	0b 9d       	cmp	r13,	r11	
    cbc2:	06 20       	jnz	$+14     	;abs 0xcbd0
    cbc4:	3f 90 16 00 	cmp	#22,	r15	;#0x0016
    cbc8:	03 34       	jge	$+8      	;abs 0xcbd0
        ((frameLen + MRFI_LENGTH_FIELD_SIZE) > MRFI_MAX_FRAME_SIZE) ||
    cbca:	7e 90 0b 00 	cmp.b	#11,	r14	;#0x000b
    cbce:	1d 2c       	jc	$+60     	;abs 0xcc0a

      /*
       *  Flush receive FIFO to reset receive.  Must go to IDLE state to do this.
       *  The critical section guarantees a transmit does not occur while cleaning up.
       */
      BSP_ENTER_CRITICAL_SECTION(s);
    cbd0:	0b 42       	mov	r2,	r11	
    cbd2:	32 c2       	dint			
    cbd4:	03 43       	nop			
      MRFI_STROBE_IDLE_AND_WAIT();
    cbd6:	7f 40 36 00 	mov.b	#54,	r15	;#0x0036
    cbda:	b0 12 e6 c4 	call	#0xc4e6	
    cbde:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    cbe2:	b0 12 e6 c4 	call	#0xc4e6	
    cbe6:	3f b0 f0 00 	bit	#240,	r15	;#0x00f0
    cbea:	f9 23       	jnz	$-12     	;abs 0xcbde
      mrfiSpiCmdStrobe( SFRX );
    cbec:	7f 40 3a 00 	mov.b	#58,	r15	;#0x003a
    cbf0:	b0 12 e6 c4 	call	#0xc4e6	
      mrfiSpiCmdStrobe( SRX );
    cbf4:	7f 40 34 00 	mov.b	#52,	r15	;#0x0034
    cbf8:	b0 12 e6 c4 	call	#0xc4e6	
      BSP_EXIT_CRITICAL_SECTION(s);
    cbfc:	3b b2       	bit	#8,	r11	;r2 As==11
    cbfe:	01 24       	jz	$+4      	;abs 0xcc02
    cc00:	32 d2       	eint			
    cc02:	0f 42       	mov	r2,	r15	
     */
    MRFI_CLEAR_SYNC_PIN_INT_FLAG();

    Mrfi_SyncPinRxIsr();
  }
}
    cc04:	21 53       	incd	r1		
    cc06:	3b 41       	pop	r11		
    cc08:	30 41       	ret			
       *    Get packet
       *   ------------
       */

      /* clean out buffer to help protect against spurious frames */
      memset(mrfiIncomingPacket.frame, 0x00, sizeof(mrfiIncomingPacket.frame));
    cc0a:	82 43 34 02 	mov	#0,	&0x0234	;r3 As==00
    cc0e:	82 43 36 02 	mov	#0,	&0x0236	;r3 As==00
    cc12:	82 43 38 02 	mov	#0,	&0x0238	;r3 As==00
    cc16:	82 43 3a 02 	mov	#0,	&0x023a	;r3 As==00
    cc1a:	82 43 3c 02 	mov	#0,	&0x023c	;r3 As==00
    cc1e:	82 43 3e 02 	mov	#0,	&0x023e	;r3 As==00
    cc22:	82 43 40 02 	mov	#0,	&0x0240	;r3 As==00
    cc26:	82 43 42 02 	mov	#0,	&0x0242	;r3 As==00
    cc2a:	82 43 44 02 	mov	#0,	&0x0244	;r3 As==00
    cc2e:	82 43 46 02 	mov	#0,	&0x0246	;r3 As==00
    cc32:	82 43 48 02 	mov	#0,	&0x0248	;r3 As==00

      /* set length field */
      mrfiIncomingPacket.frame[MRFI_LENGTH_FIELD_OFS] = frameLen;
    cc36:	c2 4e 34 02 	mov.b	r14,	&0x0234	

      /* get packet from FIFO */
      mrfiSpiReadRxFifo(&(mrfiIncomingPacket.frame[MRFI_FRAME_BODY_OFS]), frameLen);
    cc3a:	3f 40 35 02 	mov	#565,	r15	;#0x0235
    cc3e:	b0 12 86 c8 	call	#0xc886	

      /* get receive metrics from FIFO */
      mrfiSpiReadRxFifo(&(mrfiIncomingPacket.rxMetrics[0]), MRFI_RX_METRICS_SIZE);
    cc42:	6e 43       	mov.b	#2,	r14	;r3 As==10
    cc44:	3f 40 4a 02 	mov	#586,	r15	;#0x024a
    cc48:	b0 12 86 c8 	call	#0xc886	


      MRFI_DISABLE_SYNC_PIN_INT( ); // disable radio sync interrupt so no more occur
    cc4c:	c2 93 52 02 	tst.b	&0x0252	
    cc50:	2c 24       	jz	$+90     	;abs 0xccaa
    cc52:	7e 43       	mov.b	#-1,	r14	;r3 As==11
    cc54:	c2 fe 2d 00 	and.b	r14,	&0x002d	
      rx_isr_context = true;        // deactivate sync pin interrupt enable/disable macros
    cc58:	d2 43 52 02 	mov.b	#1,	&0x0252	;r3 As==01
      BSP_ENABLE_INTERRUPTS( );     // enable interrupts so higher priority irqs can occur
    cc5c:	32 d2       	eint			
       *  This could cause reads from an empty receive FIFO which puts the radio
       *  into an undefined state.
       */

      /* determine if CRC failed */
      if (!(mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_CRC_LQI_OFS] & MRFI_RX_METRICS_CRC_OK_MASK))
    cc5e:	5b 42 4b 02 	mov.b	&0x024b,r11	
    cc62:	4b 93       	tst.b	r11		
    cc64:	09 38       	jl	$+20     	;abs 0xcc78
            /* call external, higher level "receive complete" processing routine */
            MRFI_RxCompleteISR();
          }
        }
      }
    BSP_DISABLE_INTERRUPTS( );    // disable interrupts so we can enable radio sync interrupt again
    cc66:	32 c2       	dint			
    cc68:	03 43       	nop			
    rx_isr_context = false;       // activate sync pin interrupt enable/disable macros
    cc6a:	c2 43 52 02 	mov.b	#0,	&0x0252	;r3 As==00
    MRFI_ENABLE_SYNC_PIN_INT( );  // enable radio sync interrupt again
    cc6e:	d2 d3 2d 00 	bis.b	#1,	&0x002d	;r3 As==01
     */
    MRFI_CLEAR_SYNC_PIN_INT_FLAG();

    Mrfi_SyncPinRxIsr();
  }
}
    cc72:	21 53       	incd	r1		
    cc74:	3b 41       	pop	r11		
    cc76:	30 41       	ret			
         *    Filtering
         *   -----------
         */

        /* if address is not filtered, receive is successful */
        if (!MRFI_RxAddrIsFiltered(MRFI_P_DST_ADDR(&mrfiIncomingPacket)))
    cc78:	3f 40 35 02 	mov	#565,	r15	;#0x0235
    cc7c:	b0 12 1a cb 	call	#0xcb1a	
    cc80:	4f 93       	tst.b	r15		
    cc82:	f1 23       	jnz	$-28     	;abs 0xcc66
             *   --------------------
             */

            /* Convert the raw RSSI value and do offset compensation for this radio */
            mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_RSSI_OFS] =
                Mrfi_CalculateRssi(mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_RSSI_OFS]);
    cc84:	5f 42 4a 02 	mov.b	&0x024a,r15	
  int16_t rssi;

  /* The raw value is in 2's complement and in half db steps. Convert it to
   * decimal taking into account the offset value.
   */
  if(rawValue >= 128)
    cc88:	4f 93       	tst.b	r15		
    cc8a:	12 38       	jl	$+38     	;abs 0xccb0
  {
    rssi = (int16_t)(rawValue - 256)/2 - MRFI_RSSI_OFFSET;
  }
  else
  {
    rssi = (rawValue/2) - MRFI_RSSI_OFFSET;
    cc8c:	12 c3       	clrc			
    cc8e:	4f 10       	rrc.b	r15		
    cc90:	4f 4f       	mov.b	r15,	r15	
    cc92:	3f 50 b8 ff 	add	#-72,	r15	;#0xffb8
    cc96:	4f 4f       	mov.b	r15,	r15	
             *    Receive successful
             *   --------------------
             */

            /* Convert the raw RSSI value and do offset compensation for this radio */
            mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_RSSI_OFS] =
    cc98:	c2 4f 4a 02 	mov.b	r15,	&0x024a	
                Mrfi_CalculateRssi(mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_RSSI_OFS]);

            /* Remove the CRC valid bit from the LQI byte */
            mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_CRC_LQI_OFS] =
    cc9c:	7b f0 7f 00 	and.b	#127,	r11	;#0x007f
    cca0:	c2 4b 4b 02 	mov.b	r11,	&0x024b	
              (mrfiIncomingPacket.rxMetrics[MRFI_RX_METRICS_CRC_LQI_OFS] & MRFI_RX_METRICS_LQI_MASK);


            /* call external, higher level "receive complete" processing routine */
            MRFI_RxCompleteISR();
    cca4:	b0 12 28 d6 	call	#0xd628	
    cca8:	de 3f       	jmp	$-66     	;abs 0xcc66

      /* get receive metrics from FIFO */
      mrfiSpiReadRxFifo(&(mrfiIncomingPacket.rxMetrics[0]), MRFI_RX_METRICS_SIZE);


      MRFI_DISABLE_SYNC_PIN_INT( ); // disable radio sync interrupt so no more occur
    ccaa:	7e 40 fe ff 	mov.b	#-2,	r14	;#0xfffe
    ccae:	d2 3f       	jmp	$-90     	;abs 0xcc54
  /* The raw value is in 2's complement and in half db steps. Convert it to
   * decimal taking into account the offset value.
   */
  if(rawValue >= 128)
  {
    rssi = (int16_t)(rawValue - 256)/2 - MRFI_RSSI_OFFSET;
    ccb0:	4e 4f       	mov.b	r15,	r14	
    ccb2:	0f 4e       	mov	r14,	r15	
    ccb4:	3f 50 00 ff 	add	#-256,	r15	;#0xff00
    ccb8:	0f 93       	tst	r15		
    ccba:	01 34       	jge	$+4      	;abs 0xccbe
    ccbc:	1f 53       	inc	r15		
    ccbe:	0f 11       	rra	r15		
    ccc0:	3f 50 b8 ff 	add	#-72,	r15	;#0xffb8
  {
    rssi = (rawValue/2) - MRFI_RSSI_OFFSET;
  }

  /* Restrict this value to least value can be held in an 8 bit signed int */
  if(rssi < -128)
    ccc4:	3f 90 80 ff 	cmp	#-128,	r15	;#0xff80
    ccc8:	e6 37       	jge	$-50     	;abs 0xcc96
    ccca:	7f 40 80 ff 	mov.b	#-128,	r15	;#0xff80
    ccce:	e4 3f       	jmp	$-54     	;abs 0xcc98

0000ccd0 <BSP_GpioPort1Isr>:
 *
 * @return      -
 **************************************************************************************************
 */
BSP_ISR_FUNCTION( BSP_GpioPort1Isr, PORT2_VECTOR )
{
    ccd0:	0f 12       	push	r15		
    ccd2:	0e 12       	push	r14		
    ccd4:	0d 12       	push	r13		
    ccd6:	0c 12       	push	r12		
  /*
   *  This ISR is easily replaced.  The new ISR must simply
   *  include the following function call.
   */
  MRFI_GpioIsr();
    ccd8:	b0 12 5c cb 	call	#0xcb5c	
}
    ccdc:	3c 41       	pop	r12		
    ccde:	3d 41       	pop	r13		
    cce0:	3e 41       	pop	r14		
    cce2:	3f 41       	pop	r15		
    cce4:	00 13       	reti			

0000cce6 <BSP_EARLY_INIT>:
 **************************************************************************************************
*/
int BSP_EARLY_INIT(void)
{
  /* Disable watchdog timer */
  WDTCTL = WDTPW | WDTHOLD;
    cce6:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    ccea:	20 01 

  /* Return 1 - run seg_init */
  return (1);
}
    ccec:	1f 43       	mov	#1,	r15	;r3 As==01
    ccee:	30 41       	ret			

0000ccf0 <BSP_InitBoard>:
 **************************************************************************************************
 */
void BSP_InitBoard(void)
{
  /* configure internal digitally controlled oscillator */
  DCOCTL  = BSP_CONFIG_MSP430_DCOCTL;
    ccf0:	d2 42 fc 10 	mov.b	&0x10fc,&0x0056	
    ccf4:	56 00 
  BCSCTL1 = BSP_CONFIG_MSP430_BCSCTL1;
    ccf6:	d2 42 fd 10 	mov.b	&0x10fd,&0x0057	
    ccfa:	57 00 

  /* Configure TimerA for use by the delay function */

  /* Reset the timer */
  TACTL |= TACLR; /* Set the TACLR */
    ccfc:	a2 d2 60 01 	bis	#4,	&0x0160	;r2 As==10

  /* Clear all settings */
  TACTL = 0x0;
    cd00:	82 43 60 01 	mov	#0,	&0x0160	;r3 As==00

  /* Select the clk source to be - SMCLK (Sub-Main CLK)*/
  TACTL |= TASSEL_2;
    cd04:	b2 d0 00 02 	bis	#512,	&0x0160	;#0x0200
    cd08:	60 01 
  if (!sIterationsPerUsec)
  {
    sIterationsPerUsec = 1;
  }
#endif   /* SW_TIMER */
}
    cd0a:	30 41       	ret			

0000cd0c <BSP_Delay>:
 **************************************************************************************************
 */
void BSP_Delay(uint16_t usec)
#if !defined(SW_TIMER)
{
  TACCTL0 &= ~CCIFG;
    cd0c:	b2 f0 fe ff 	and	#-2,	&0x0162	;#0xfffe
    cd10:	62 01 
  TAR = 0; /* initial count */
    cd12:	82 43 70 01 	mov	#0,	&0x0170	;r3 As==00
  TACCR0 = BSP_TIMER_CLK_MHZ*usec; /* compare count. (delay in ticks) */
    cd16:	0f 5f       	rla	r15		
    cd18:	0f 5f       	rla	r15		
    cd1a:	0f 5f       	rla	r15		
    cd1c:	82 4f 72 01 	mov	r15,	&0x0172	

  /* Start the timer in UP mode */
  TACTL |= MC_1;
    cd20:	b2 d0 10 00 	bis	#16,	&0x0160	;#0x0010
    cd24:	60 01 

  /* Loop till compare interrupt flag is set */
  while(!(TACCTL0 & CCIFG));
    cd26:	92 b3 62 01 	bit	#1,	&0x0162	;r3 As==01
    cd2a:	fd 27       	jz	$-4      	;abs 0xcd26

  /* Stop the timer */
  TACTL &= ~(MC_1);
    cd2c:	b2 f0 ef ff 	and	#-17,	&0x0160	;#0xffef
    cd30:	60 01 

  /* Clear the interrupt flag */
   TACCTL0 &= ~CCIFG;
    cd32:	b2 f0 fe ff 	and	#-2,	&0x0162	;#0xfffe
    cd36:	62 01 
}
    cd38:	30 41       	ret			

0000cd3a <BSP_InitLeds>:
 **************************************************************************************************
 */
void BSP_InitLeds(void)
{
  /* configure LEDs */
  BSP_CONFIG_LED1();
    cd3a:	d2 d3 22 00 	bis.b	#1,	&0x0022	;r3 As==01
  BSP_CONFIG_LED2();
    cd3e:	f2 d0 20 00 	bis.b	#32,	&0x002a	;#0x0020
    cd42:	2a 00 

  /* peform extended configuration if needed */
  BSP_LED_EXTENDED_CONFIG();

  /* turn all LEDs off as power-up default */
  BSP_TURN_OFF_LED1();
    cd44:	f2 f0 fe ff 	and.b	#-2,	&0x0021	;#0xfffe
    cd48:	21 00 
  BSP_TURN_OFF_LED2();
    cd4a:	f2 f0 df ff 	and.b	#-33,	&0x0029	;#0xffdf
    cd4e:	29 00 
  BSP_TURN_OFF_LED4();
  BSP_TURN_OFF_LED5();
  BSP_TURN_OFF_LED6();
  BSP_TURN_OFF_LED7();
  BSP_TURN_OFF_LED8();
}
    cd50:	30 41       	ret			

0000cd52 <BSP_InitDrivers>:
 **************************************************************************************************
 */
void BSP_InitDrivers(void)
{
#if (!defined BSP_NO_LEDS)
  BSP_InitLeds();
    cd52:	b0 12 3a cd 	call	#0xcd3a	
  BSP_CONFIG_BUTTON6();
  BSP_CONFIG_BUTTON7();
  BSP_CONFIG_BUTTON8();

  /* peform extended configuration if needed */
  BSP_BUTTON_EXTENDED_CONFIG();
    cd56:	f2 d2 21 00 	bis.b	#8,	&0x0021	;r2 As==11
    cd5a:	f2 d2 27 00 	bis.b	#8,	&0x0027	;r2 As==11
#endif

#if (!defined BSP_NO_BUTTONS)
  BSP_InitButtons();
#endif
}
    cd5e:	30 41       	ret			

0000cd60 <BSP_Init>:
 *
 * @return      none
 **************************************************************************************************
 */
void BSP_Init(void)
{
    cd60:	21 83       	decd	r1		
 **************************************************************************************************
 */
void BSP_InitBoard(void)
{
  /* configure internal digitally controlled oscillator */
  DCOCTL  = BSP_CONFIG_MSP430_DCOCTL;
    cd62:	d2 42 fc 10 	mov.b	&0x10fc,&0x0056	
    cd66:	56 00 
  BCSCTL1 = BSP_CONFIG_MSP430_BCSCTL1;
    cd68:	d2 42 fd 10 	mov.b	&0x10fd,&0x0057	
    cd6c:	57 00 

  /* Configure TimerA for use by the delay function */

  /* Reset the timer */
  TACTL |= TACLR; /* Set the TACLR */
    cd6e:	a2 d2 60 01 	bis	#4,	&0x0160	;r2 As==10

  /* Clear all settings */
  TACTL = 0x0;
    cd72:	82 43 60 01 	mov	#0,	&0x0160	;r3 As==00

  /* Select the clk source to be - SMCLK (Sub-Main CLK)*/
  TACTL |= TASSEL_2;
    cd76:	b2 d0 00 02 	bis	#512,	&0x0160	;#0x0200
    cd7a:	60 01 
  BSP_INIT_BOARD();
  BSP_INIT_DRIVERS();
    cd7c:	b0 12 52 cd 	call	#0xcd52	
  {
    uint16_t test = 0x00AA; /* first storage byte of 'test' is non-zero for little endian */
    BSP_ASSERT(!(*((uint8_t *)&test)) == !BSP_LITTLE_ENDIAN); /* endianess mismatch */
  }
#endif
}
    cd80:	21 53       	incd	r1		
    cd82:	30 41       	ret			

0000cd84 <BSP_InitButtons>:
    cd84:	f2 d2 21 00 	bis.b	#8,	&0x0021	;r2 As==11
    cd88:	f2 d2 27 00 	bis.b	#8,	&0x0027	;r2 As==11
}
    cd8c:	30 41       	ret			

0000cd8e <SMPL_Init>:
 *             SMPL_NO_JOIN     No Join reply. AP possibly not yet up.
 *             SMPL_NO_CHANNEL  Only if Frequency Agility enabled. Channel scan
 *                              failed. AP possibly not yet up.
 */
smplStatus_t SMPL_Init(uint8_t (*f)(linkID_t))
{
    cd8e:	21 83       	decd	r1		
  smplStatus_t rc;

  if (!sInit_done)
    cd90:	c2 93 54 02 	tst.b	&0x0254	
    cd94:	13 20       	jnz	$+40     	;abs 0xcdbc
  {
    /* set up radio. */
    MRFI_Init();
    cd96:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
    cd9a:	b0 12 04 c9 	call	#0xc904	

    /* initialize network */
    if ((rc=nwk_nwkInit(f)) != SMPL_SUCCESS)
    cd9e:	2f 41       	mov	@r1,	r15	
    cda0:	b0 12 d2 cf 	call	#0xcfd2	
    cda4:	0f 93       	tst	r15		
    cda6:	02 24       	jz	$+6      	;abs 0xcdac

  /* Join. if no AP or Join fails that status is returned. */
  rc = nwk_join();

  return rc;
}
    cda8:	21 53       	incd	r1		
    cdaa:	30 41       	ret			
    if ((rc=nwk_nwkInit(f)) != SMPL_SUCCESS)
    {
      return rc;
    }

    MRFI_WakeUp();
    cdac:	b0 12 a2 c6 	call	#0xc6a2	
    MRFI_RxOn();
#endif

#if defined( END_DEVICE )
    /* All except End Devices are in promiscuous mode */
    MRFI_SetRxAddrFilter((uint8_t *)nwk_getMyAddress());
    cdb0:	b0 12 56 dd 	call	#0xdd56	
    cdb4:	b0 12 be ca 	call	#0xcabe	
    MRFI_EnableRxAddrFilter();
    cdb8:	b0 12 ec ca 	call	#0xcaec	
#endif
  }
  sInit_done = 1;
    cdbc:	d2 43 54 02 	mov.b	#1,	&0x0254	;r3 As==01
      nwk_pllBackgrounder( false );
  #endif
#endif

  /* Join. if no AP or Join fails that status is returned. */
  rc = nwk_join();
    cdc0:	b0 12 68 d4 	call	#0xd468	

  return rc;
}
    cdc4:	21 53       	incd	r1		
    cdc6:	30 41       	ret			

0000cdc8 <SMPL_LinkListen>:
*                            Interval set in #defines above. linkID not valid.
 *
 */

smplStatus_t SMPL_LinkListen(linkID_t *linkID)
{
    cdc8:	0b 12       	push	r11		
    cdca:	0a 12       	push	r10		
    cdcc:	09 12       	push	r9		
    cdce:	08 12       	push	r8		
    cdd0:	08 4f       	mov	r15,	r8	
  uint8_t  radioState = MRFI_GetRadioState();
    cdd2:	b0 12 9c c4 	call	#0xc49c	
    cdd6:	49 4f       	mov.b	r15,	r9	

  /* Set the context. We want to reject any link frames received if
   * we're not listening. For example if we're an AP we are in
   * promiscuous mode and we'll see any broadcast link frames.
   */
  nwk_setListenContext(LINK_LISTEN_ON);
    cdd8:	4f 43       	clr.b	r15		
    cdda:	b0 12 be db 	call	#0xdbbe	

  NWK_CHECK_FOR_SETRX(radioState);
    cdde:	79 90 03 00 	cmp.b	#3,	r9	;#0x0003
    cde2:	04 24       	jz	$+10     	;abs 0xcdec
    cde4:	59 93       	cmp.b	#1,	r9	;r3 As==01
    cde6:	2d 24       	jz	$+92     	;abs 0xce42
    cde8:	b0 12 ba c5 	call	#0xc5ba	
*                            Interval set in #defines above. linkID not valid.
 *
 */

smplStatus_t SMPL_LinkListen(linkID_t *linkID)
{
    cdec:	3b 40 f4 01 	mov	#500,	r11	;#0x01f4
    cdf0:	06 3c       	jmp	$+14     	;abs 0xcdfe
    /* check the semaphore. local port is assigned when the reply is sent. */
    if ((locLinkID=nwk_getLocalLinkID()))
    {
      break;
    }
    NWK_DELAY(LINKLISTEN_POLL_PERIOD_MS);
    cdf2:	3f 40 0a 00 	mov	#10,	r15	;#0x000a
    cdf6:	b0 12 f8 c3 	call	#0xc3f8	
    cdfa:	3b 53       	add	#-1,	r11	;r3 As==11
   */
  nwk_setListenContext(LINK_LISTEN_ON);

  NWK_CHECK_FOR_SETRX(radioState);

  for (i=0; i<LINKLISTEN_POLL_COUNT; ++i)
    cdfc:	05 24       	jz	$+12     	;abs 0xce08
  {
    /* check the semaphore. local port is assigned when the reply is sent. */
    if ((locLinkID=nwk_getLocalLinkID()))
    cdfe:	b0 12 62 db 	call	#0xdb62	
    ce02:	4a 4f       	mov.b	r15,	r10	
    ce04:	4f 93       	tst.b	r15		
    ce06:	f5 27       	jz	$-20     	;abs 0xcdf2
      break;
    }
    NWK_DELAY(LINKLISTEN_POLL_PERIOD_MS);
  }

  NWK_CHECK_FOR_RESTORE_STATE(radioState);
    ce08:	79 90 03 00 	cmp.b	#3,	r9	;#0x0003
    ce0c:	04 24       	jz	$+10     	;abs 0xce16
    ce0e:	59 93       	cmp.b	#1,	r9	;r3 As==01
    ce10:	15 24       	jz	$+44     	;abs 0xce3c
    ce12:	b0 12 7a c5 	call	#0xc57a	

  /* If the listen is terminated without hearing a message and setting a
   * link ID the listen context must be explicitly turned off.
   */
  if (!(locLinkID))
    ce16:	4a 93       	tst.b	r10		
    ce18:	08 24       	jz	$+18     	;abs 0xce2a
  {
    nwk_setListenContext(LINK_LISTEN_OFF);
    return SMPL_TIMEOUT;
  }

  *linkID = locLinkID;
    ce1a:	c8 4a 00 00 	mov.b	r10,	0(r8)	;0x0000(r8)

  return SMPL_SUCCESS;
    ce1e:	0f 43       	clr	r15		
}
    ce20:	38 41       	pop	r8		
    ce22:	39 41       	pop	r9		
    ce24:	3a 41       	pop	r10		
    ce26:	3b 41       	pop	r11		
    ce28:	30 41       	ret			
  /* If the listen is terminated without hearing a message and setting a
   * link ID the listen context must be explicitly turned off.
   */
  if (!(locLinkID))
  {
    nwk_setListenContext(LINK_LISTEN_OFF);
    ce2a:	5f 43       	mov.b	#1,	r15	;r3 As==01
    ce2c:	b0 12 be db 	call	#0xdbbe	
    return SMPL_TIMEOUT;
    ce30:	1f 43       	mov	#1,	r15	;r3 As==01
  }

  *linkID = locLinkID;

  return SMPL_SUCCESS;
}
    ce32:	38 41       	pop	r8		
    ce34:	39 41       	pop	r9		
    ce36:	3a 41       	pop	r10		
    ce38:	3b 41       	pop	r11		
    ce3a:	30 41       	ret			
      break;
    }
    NWK_DELAY(LINKLISTEN_POLL_PERIOD_MS);
  }

  NWK_CHECK_FOR_RESTORE_STATE(radioState);
    ce3c:	b0 12 da c5 	call	#0xc5da	
    ce40:	ea 3f       	jmp	$-42     	;abs 0xce16
   * we're not listening. For example if we're an AP we are in
   * promiscuous mode and we'll see any broadcast link frames.
   */
  nwk_setListenContext(LINK_LISTEN_ON);

  NWK_CHECK_FOR_SETRX(radioState);
    ce42:	b0 12 a2 c6 	call	#0xc6a2	
    ce46:	d0 3f       	jmp	$-94     	;abs 0xcde8

0000ce48 <SMPL_SendOpt>:
 *             SMPL_TX_CCA_FAIL  CCA failure.
 *             SMPL_NO_ACK       If application auto acknowledgement enabled
 *                               and no acknowledgement is received
 */
smplStatus_t SMPL_SendOpt(linkID_t lid, uint8_t *msg, uint8_t len, txOpt_t options)
{
    ce48:	0b 12       	push	r11		
    ce4a:	0a 12       	push	r10		
    ce4c:	09 12       	push	r9		
    ce4e:	08 12       	push	r8		
    ce50:	0a 4e       	mov	r14,	r10	
    ce52:	49 4d       	mov.b	r13,	r9	
    ce54:	08 4c       	mov	r12,	r8	
  frameInfo_t  *pFrameInfo;
  connInfo_t   *pCInfo     = nwk_getConnInfo(lid);
    ce56:	b0 12 e0 d0 	call	#0xd0e0	
    ce5a:	0b 4f       	mov	r15,	r11	
  uint8_t       radioState;
  uint8_t       ackreq     = 0;
#if defined(ACCESS_POINT)
  uint8_t  loc;
#endif
  radioState = MRFI_GetRadioState();
    ce5c:	b0 12 9c c4 	call	#0xc49c	

  /* we have the connection info for this Link ID. make sure it is valid. */
   if (!pCInfo || ((rc=nwk_checkConnInfo(pCInfo, CHK_TX)) != SMPL_SUCCESS))
    ce60:	0b 93       	tst	r11		
    ce62:	0d 24       	jz	$+28     	;abs 0xce7e
    ce64:	5e 43       	mov.b	#1,	r14	;r3 As==01
    ce66:	0f 4b       	mov	r11,	r15	
    ce68:	b0 12 b8 d1 	call	#0xd1b8	
    ce6c:	0f 93       	tst	r15		
    ce6e:	08 20       	jnz	$+18     	;abs 0xce80
  {
    return rc;
  }

  /* parameter sanity check... */
  if (!msg || (len > MAX_APP_PAYLOAD))
    ce70:	0a 93       	tst	r10		
    ce72:	06 24       	jz	$+14     	;abs 0xce80
    ce74:	79 90 0b 00 	cmp.b	#11,	r9	;#0x000b
    ce78:	03 2c       	jc	$+8      	;abs 0xce80

  /* Build an outgoing message frame destined for the port from the
   * connection info using the destination address also from the
   * connection info.
   */
  if (SMPL_TXOPTION_NONE == options)
    ce7a:	08 93       	tst	r8		
    ce7c:	06 24       	jz	$+14     	;abs 0xce8a
    }
  }
#endif  /* APP_AUTO_ACK */
  else
  {
    return SMPL_BAD_PARAM;
    ce7e:	2f 43       	mov	#2,	r15	;r3 As==10
    BSP_EXIT_CRITICAL_SECTION(intState);
  }

  return rc;
#endif  /* APP_AUTO_ACK */
}
    ce80:	38 41       	pop	r8		
    ce82:	39 41       	pop	r9		
    ce84:	3a 41       	pop	r10		
    ce86:	3b 41       	pop	r11		
    ce88:	30 41       	ret			
   * connection info using the destination address also from the
   * connection info.
   */
  if (SMPL_TXOPTION_NONE == options)
  {
    pFrameInfo = nwk_buildFrame(pCInfo->portTx, msg, len, pCInfo->hops2target);
    ce8a:	5c 4b 01 00 	mov.b	1(r11),	r12	;0x0001(r11)
    ce8e:	4d 49       	mov.b	r9,	r13	
    ce90:	0e 4a       	mov	r10,	r14	
    ce92:	5f 4b 09 00 	mov.b	9(r11),	r15	;0x0009(r11)
    ce96:	b0 12 94 d5 	call	#0xd594	
  else
  {
    return SMPL_BAD_PARAM;
  }

  if (!pFrameInfo)
    ce9a:	0f 93       	tst	r15		
    ce9c:	10 24       	jz	$+34     	;abs 0xcebe
  {
    return SMPL_NOMEM;
  }
  memcpy(MRFI_P_DST_ADDR(&pFrameInfo->mrfiPkt), pCInfo->peerAddr, NET_ADDR_SIZE);
    ce9e:	df 4b 02 00 	mov.b	2(r11),	3(r15)	;0x0002(r11), 0x0003(r15)
    cea2:	03 00 
    cea4:	df 4b 03 00 	mov.b	3(r11),	4(r15)	;0x0003(r11), 0x0004(r15)
    cea8:	04 00 
    ceaa:	df 4b 04 00 	mov.b	4(r11),	5(r15)	;0x0004(r11), 0x0005(r15)
    ceae:	05 00 
    ceb0:	df 4b 05 00 	mov.b	5(r11),	6(r15)	;0x0005(r11), 0x0006(r15)
    ceb4:	06 00 
     return SMPL_SUCCESS;
  }
  else
#endif  /* ACCESS_POINT */
  {
    rc = nwk_sendFrame(pFrameInfo, MRFI_TX_TYPE_CCA);
    ceb6:	5e 43       	mov.b	#1,	r14	;r3 As==01
    ceb8:	b0 12 a4 d7 	call	#0xd7a4	
  }

#if !defined(APP_AUTO_ACK)
  /* save a little code space with this #if */
  (void) ackreq;    /* keep compiler happy */
  return rc;
    cebc:	e1 3f       	jmp	$-60     	;abs 0xce80
    return SMPL_BAD_PARAM;
  }

  if (!pFrameInfo)
  {
    return SMPL_NOMEM;
    cebe:	3f 40 03 00 	mov	#3,	r15	;#0x0003
    cec2:	de 3f       	jmp	$-66     	;abs 0xce80

0000cec4 <SMPL_Send>:
 *             SMPL_NOMEM        No room in output frame queue
 *             SMPL_TX_CCA_FAIL  CCA failure.
 */
smplStatus_t SMPL_Send(linkID_t lid, uint8_t *msg, uint8_t len)
{
  return SMPL_SendOpt(lid, msg, len, SMPL_TXOPTION_NONE);
    cec4:	0c 43       	clr	r12		
    cec6:	b0 12 48 ce 	call	#0xce48	
}
    ceca:	30 41       	ret			

0000cecc <SMPL_Receive>:
 *              SMPL_TX_CCA_FAIL    Could not send poll frame
 *              SMPL_NOMEM          No memory in output frame queue
 *              SMPL_NO_CHANNEL     Frequency Agility enabled and could not find channel
 */
smplStatus_t SMPL_Receive(linkID_t lid, uint8_t *msg, uint8_t *len)
{
    cecc:	0b 12       	push	r11		
    cece:	0a 12       	push	r10		
    ced0:	09 12       	push	r9		
    ced2:	21 82       	sub	#4,	r1	;r2 As==10
    ced4:	49 4f       	mov.b	r15,	r9	
    ced6:	0b 4e       	mov	r14,	r11	
    ced8:	0a 4d       	mov	r13,	r10	
  connInfo_t  *pCInfo = nwk_getConnInfo(lid);
    ceda:	b0 12 e0 d0 	call	#0xd0e0	
  smplStatus_t rc = SMPL_BAD_PARAM;
  rcvContext_t rcv;

  if (!pCInfo || ((rc=nwk_checkConnInfo(pCInfo, CHK_RX)) != SMPL_SUCCESS))
    cede:	0f 93       	tst	r15		
    cee0:	1c 24       	jz	$+58     	;abs 0xcf1a
    cee2:	4e 43       	clr.b	r14		
    cee4:	b0 12 b8 d1 	call	#0xd1b8	
    cee8:	0f 93       	tst	r15		
    ceea:	05 24       	jz	$+12     	;abs 0xcef6
#endif

#else  /* RX_POLLS */
  return nwk_retrieveFrame(&rcv, msg, len, 0, 0);
#endif  /* RX_POLLS */
}
    ceec:	21 52       	add	#4,	r1	;r2 As==10
    ceee:	39 41       	pop	r9		
    cef0:	3a 41       	pop	r10		
    cef2:	3b 41       	pop	r11		
    cef4:	30 41       	ret			
  if (!pCInfo || ((rc=nwk_checkConnInfo(pCInfo, CHK_RX)) != SMPL_SUCCESS))
  {
    return rc;
  }

  rcv.type  = RCV_APP_LID;
    cef6:	91 43 00 00 	mov	#1,	0(r1)	;r3 As==01, 0x0000(r1)
  rcv.t.lid = lid;
    cefa:	c1 49 02 00 	mov.b	r9,	2(r1)	;0x0002(r1)
#if defined(FREQUENCY_AGILITY)
  return SMPL_NO_CHANNEL;
#endif

#else  /* RX_POLLS */
  return nwk_retrieveFrame(&rcv, msg, len, 0, 0);
    cefe:	03 12       	push	#0		;r3 As==00
    cf00:	0c 43       	clr	r12		
    cf02:	0d 4a       	mov	r10,	r13	
    cf04:	0e 4b       	mov	r11,	r14	
    cf06:	0f 41       	mov	r1,	r15	
    cf08:	2f 53       	incd	r15		
    cf0a:	b0 12 be d6 	call	#0xd6be	
    cf0e:	21 53       	incd	r1		
#endif  /* RX_POLLS */
}
    cf10:	21 52       	add	#4,	r1	;r2 As==10
    cf12:	39 41       	pop	r9		
    cf14:	3a 41       	pop	r10		
    cf16:	3b 41       	pop	r11		
    cf18:	30 41       	ret			
 *              SMPL_NO_CHANNEL     Frequency Agility enabled and could not find channel
 */
smplStatus_t SMPL_Receive(linkID_t lid, uint8_t *msg, uint8_t *len)
{
  connInfo_t  *pCInfo = nwk_getConnInfo(lid);
  smplStatus_t rc = SMPL_BAD_PARAM;
    cf1a:	2f 43       	mov	#2,	r15	;r3 As==10
#endif

#else  /* RX_POLLS */
  return nwk_retrieveFrame(&rcv, msg, len, 0, 0);
#endif  /* RX_POLLS */
}
    cf1c:	21 52       	add	#4,	r1	;r2 As==10
    cf1e:	39 41       	pop	r9		
    cf20:	3a 41       	pop	r10		
    cf22:	3b 41       	pop	r11		
    cf24:	30 41       	ret			

0000cf26 <SMPL_Link>:
 *             SMPL_NO_LINK       No reply frame during wait window.
 *             SMPL_TX_CCA_FAIL   Could not send Link frame.
 */
smplStatus_t SMPL_Link(linkID_t *lid)
{
  return nwk_link(lid);
    cf26:	b0 12 36 d8 	call	#0xd836	
}
    cf2a:	30 41       	ret			

0000cf2c <SMPL_Ioctl>:
 *           SMPL_BAD_PARAM is returned if this API is called before
 *                          initialization and the object is not one of
 *                          the valid exceptions.
 */
smplStatus_t SMPL_Ioctl(ioctlObject_t object, ioctlAction_t action, void *val)
{
    cf2c:	21 83       	decd	r1		
    cf2e:	0c 4e       	mov	r14,	r12	
  smplStatus_t rc;

  /* if init hasn't occurred see if access is still valid */
  if (!sInit_done && !ioctlPreInitAccessIsOK(object))
    cf30:	c2 93 54 02 	tst.b	&0x0254	
    cf34:	0c 20       	jnz	$+26     	;abs 0xcf4e
    cf36:	0e 4f       	mov	r15,	r14	
    cf38:	3e 50 fb ff 	add	#-5,	r14	;#0xfffb
    cf3c:	3e 90 06 00 	cmp	#6,	r14	;#0x0006
    cf40:	03 28       	jnc	$+8      	;abs 0xcf48
        *((uint8_t *)val) = nwk_getProtocolVersion();
        rc = SMPL_SUCCESS;
      }
      else
      {
        rc = SMPL_BAD_PARAM;
    cf42:	2f 43       	mov	#2,	r15	;r3 As==10
      rc = SMPL_BAD_PARAM;
      break;
  }

  return rc;
}
    cf44:	21 53       	incd	r1		
    cf46:	30 41       	ret			
smplStatus_t SMPL_Ioctl(ioctlObject_t object, ioctlAction_t action, void *val)
{
  smplStatus_t rc;

  /* if init hasn't occurred see if access is still valid */
  if (!sInit_done && !ioctlPreInitAccessIsOK(object))
    cf48:	ce 93 e2 e4 	tst.b	-6942(r14)	;0xe4e2(r14)
    cf4c:	fa 27       	jz	$-10     	;abs 0xcf42
  {
    return SMPL_BAD_PARAM;
  }

  switch (object)
    cf4e:	3f 90 09 00 	cmp	#9,	r15	;#0x0009
    cf52:	f7 2f       	jc	$-16     	;abs 0xcf42
    cf54:	0f 5f       	rla	r15		
    cf56:	10 4f d0 e4 	br	-6960(r15)	;0xe4d0(r15)
        rc = SMPL_BAD_PARAM;
      }
      break;

    case IOCTL_OBJ_PROTOVER:
      if (IOCTL_ACT_GET == action)
    cf5a:	1c 93       	cmp	#1,	r12	;r3 As==01
    cf5c:	f2 23       	jnz	$-26     	;abs 0xcf42
      {
        *((uint8_t *)val) = nwk_getProtocolVersion();
    cf5e:	81 4d 00 00 	mov	r13,	0(r1)	;0x0000(r1)
    cf62:	b0 12 6e dd 	call	#0xdd6e	
    cf66:	2d 41       	mov	@r1,	r13	
    cf68:	cd 4f 00 00 	mov.b	r15,	0(r13)	;0x0000(r13)
        rc = SMPL_SUCCESS;
    cf6c:	0f 43       	clr	r15		
    cf6e:	ea 3f       	jmp	$-42     	;abs 0xcf44
    case IOCTL_OBJ_PLL:
      rc = nwk_pllControl(action, val);
      break;
#endif
    case IOCTL_OBJ_FWVER:
      if (IOCTL_ACT_GET == action)
    cf70:	1c 93       	cmp	#1,	r12	;r3 As==01
    cf72:	e7 23       	jnz	$-48     	;abs 0xcf42
      {
        memcpy(val, nwk_getFWVersion(), SMPL_FWVERSION_SIZE);
    cf74:	81 4d 00 00 	mov	r13,	0(r1)	;0x0000(r1)
    cf78:	b0 12 68 dd 	call	#0xdd68	
    cf7c:	2d 41       	mov	@r1,	r13	
    cf7e:	fd 4f 00 00 	mov.b	@r15+,	0(r13)	;0x0000(r13)
    cf82:	1d 53       	inc	r13		
    cf84:	fd 4f 00 00 	mov.b	@r15+,	0(r13)	;0x0000(r13)
    cf88:	1d 53       	inc	r13		
    cf8a:	fd 4f 00 00 	mov.b	@r15+,	0(r13)	;0x0000(r13)
    cf8e:	ed 4f 01 00 	mov.b	@r15,	1(r13)	;0x0001(r13)
        rc = SMPL_SUCCESS;
    cf92:	0f 43       	clr	r15		
    cf94:	d7 3f       	jmp	$-80     	;abs 0xcf44
      rc = nwk_NVObj(action, (ioctlNVObj_t *)val);
      break;
#endif  /* EXTENDED_API */

    case IOCTL_OBJ_CONNOBJ:
      rc = nwk_connectionControl(action, val);
    cf96:	0e 4d       	mov	r13,	r14	
    cf98:	0f 4c       	mov	r12,	r15	
    cf9a:	b0 12 10 dd 	call	#0xdd10	
      break;
    cf9e:	d2 3f       	jmp	$-90     	;abs 0xcf44

    case IOCTL_OBJ_ADDR:
      if ((IOCTL_ACT_GET == action) || (IOCTL_ACT_SET == action))
    cfa0:	2c 93       	cmp	#2,	r12	;r3 As==10
    cfa2:	cf 2f       	jc	$-96     	;abs 0xcf42
      {
        rc = nwk_deviceAddress(action, (addr_t *)val);
    cfa4:	0e 4d       	mov	r13,	r14	
    cfa6:	0f 4c       	mov	r12,	r15	
    cfa8:	b0 12 d0 dc 	call	#0xdcd0	
    cfac:	cb 3f       	jmp	$-104    	;abs 0xcf44
        rc = SMPL_BAD_PARAM;
      }
      break;

    case IOCTL_OBJ_RADIO:
      rc = nwk_radioControl(action, val);
    cfae:	0e 4d       	mov	r13,	r14	
    cfb0:	0f 4c       	mov	r12,	r15	
    cfb2:	b0 12 4a dc 	call	#0xdc4a	
      break;
    cfb6:	c6 3f       	jmp	$-114    	;abs 0xcf44
        rc = SMPL_BAD_PARAM;
      }
      break;

    case IOCTL_OBJ_RAW_IO:
      if (IOCTL_ACT_WRITE == action)
    cfb8:	3c 90 03 00 	cmp	#3,	r12	;#0x0003
    cfbc:	06 24       	jz	$+14     	;abs 0xcfca
      {
        rc = nwk_rawSend((ioctlRawSend_t *)val);
      }
      else if (IOCTL_ACT_READ == action)
    cfbe:	2c 93       	cmp	#2,	r12	;r3 As==10
    cfc0:	c0 23       	jnz	$-126    	;abs 0xcf42
      {
        rc = nwk_rawReceive((ioctlRawReceive_t *)val);
    cfc2:	0f 4d       	mov	r13,	r15	
    cfc4:	b0 12 1e dc 	call	#0xdc1e	
    cfc8:	bd 3f       	jmp	$-132    	;abs 0xcf44
      break;

    case IOCTL_OBJ_RAW_IO:
      if (IOCTL_ACT_WRITE == action)
      {
        rc = nwk_rawSend((ioctlRawSend_t *)val);
    cfca:	0f 4d       	mov	r13,	r15	
    cfcc:	b0 12 cc db 	call	#0xdbcc	
    cfd0:	b9 3f       	jmp	$-140    	;abs 0xcf44

0000cfd2 <nwk_nwkInit>:
 * output parameters
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_nwkInit(uint8_t (*f)(linkID_t))
{
    cfd2:	0b 12       	push	r11		
    cfd4:	0b 4f       	mov	r15,	r11	
  /* Truly ugly initialization because CCE won't initialize properly. Must
   * skip first const element. Yuk.
   */
  memset((((uint8_t *)&sPersistInfo)+1), 0x0, (sizeof(sPersistInfo)-1));
    cfd6:	3d 40 29 00 	mov	#41,	r13	;#0x0029
    cfda:	0e 43       	clr	r14		
    cfdc:	3f 40 05 02 	mov	#517,	r15	;#0x0205
    cfe0:	b0 12 1c e4 	call	#0xe41c	
  /* OK. The zeroed elements are set. Now go back and do fixups...  */

  sPersistInfo.numConnections   = SYS_NUM_CONNECTIONS;
    cfe4:	f2 40 03 00 	mov.b	#3,	&0x0205	;#0x0003
    cfe8:	05 02 
  sPersistInfo.curNextLinkPort  = SMPL_PORT_USER_MAX;
    cfea:	f2 40 3d 00 	mov.b	#61,	&0x0206	;#0x003d
    cfee:	06 02 
  sPersistInfo.curMaxReplyPort  = PORT_BASE_NUMBER;
    cff0:	f2 40 20 00 	mov.b	#32,	&0x0207	;#0x0020
    cff4:	07 02 
  sPersistInfo.nextLinkID       = 1;
    cff6:	d2 43 08 02 	mov.b	#1,	&0x0208	;r3 As==01

  /* initialize globals */
  nwk_globalsInit();
    cffa:	b0 12 36 dd 	call	#0xdd36	

  /* initialize frame processing */
  nwk_frameInit(f);
    cffe:	0f 4b       	mov	r11,	r15	
    d000:	b0 12 76 d5 	call	#0xd576	

  /* initialize queue manager */
  nwk_QInit();
    d004:	b0 12 d0 df 	call	#0xdfd0	
	
  /* initialize each network application. */
  nwk_freqInit();
    d008:	b0 12 dc dd 	call	#0xdddc	
  nwk_pingInit();
    d00c:	b0 12 e2 dd 	call	#0xdde2	
  nwk_joinInit(f);
    d010:	0f 4b       	mov	r11,	r15	
    d012:	b0 12 1c d4 	call	#0xd41c	
  nwk_mgmtInit();
    d016:	b0 12 1c df 	call	#0xdf1c	
  nwk_linkInit();
    d01a:	b0 12 de d7 	call	#0xd7de	
  nwk_securityInit();
    d01e:	b0 12 ca df 	call	#0xdfca	
#ifdef NWK_PLL
  nwk_PLLInit();
#endif

  /* set up the last connection as the broadcast port mapped to the broadcast Link ID */
  if (CONNSTATE_FREE == sPersistInfo.connStruct[NUM_CONNECTIONS].connState)
    d022:	5f 42 22 02 	mov.b	&0x0222,r15	
    d026:	4f 93       	tst.b	r15		
    d028:	17 20       	jnz	$+48     	;abs 0xd058
  {
    sPersistInfo.connStruct[NUM_CONNECTIONS].connState   = CONNSTATE_CONNECTED;
    d02a:	e2 43 22 02 	mov.b	#2,	&0x0222	;r3 As==10
    sPersistInfo.connStruct[NUM_CONNECTIONS].hops2target = MAX_HOPS;
    d02e:	f2 40 03 00 	mov.b	#3,	&0x0223	;#0x0003
    d032:	23 02 
    sPersistInfo.connStruct[NUM_CONNECTIONS].portRx      = SMPL_PORT_USER_BCAST;
    d034:	f2 40 3f 00 	mov.b	#63,	&0x022a	;#0x003f
    d038:	2a 02 
    sPersistInfo.connStruct[NUM_CONNECTIONS].portTx      = SMPL_PORT_USER_BCAST;
    d03a:	f2 40 3f 00 	mov.b	#63,	&0x022b	;#0x003f
    d03e:	2b 02 
    sPersistInfo.connStruct[NUM_CONNECTIONS].thisLinkID  = SMPL_LINKID_USER_UUD;
    d040:	f2 43 2c 02 	mov.b	#-1,	&0x022c	;r3 As==11
    /* set peer address to broadcast so it is used when Application sends to the broadcast Link ID */
    memcpy(sPersistInfo.connStruct[NUM_CONNECTIONS].peerAddr, nwk_getBCastAddress(), NET_ADDR_SIZE);
    d044:	b0 12 d6 dd 	call	#0xddd6	
    d048:	f2 4f 24 02 	mov.b	@r15+,	&0x0224	
    d04c:	f2 4f 25 02 	mov.b	@r15+,	&0x0225	
    d050:	f2 4f 26 02 	mov.b	@r15+,	&0x0226	
    d054:	e2 4f 27 02 	mov.b	@r15,	&0x0227	
  }

  return SMPL_SUCCESS;
}
    d058:	0f 43       	clr	r15		
    d05a:	3b 41       	pop	r11		
    d05c:	30 41       	ret			

0000d05e <nwk_getNextConnection>:
{
  uint8_t  i;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i)
  {
    if (sPersistInfo.connStruct[i].connState == CONNSTATE_CONNECTED)
    d05e:	5f 42 0a 02 	mov.b	&0x020a,r15	
    d062:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    d064:	2c 24       	jz	$+90     	;abs 0xd0be
    d066:	0e 43       	clr	r14		
  if (SYS_NUM_CONNECTIONS == i)
  {
    return (connInfo_t *)0;
  }

  initializeConnection(&sPersistInfo.connStruct[i]);
    d068:	0f 4e       	mov	r14,	r15	
    d06a:	0f 5f       	rla	r15		
    d06c:	0f 5e       	add	r14,	r15	
    d06e:	0f 5f       	rla	r15		
    d070:	0f 5f       	rla	r15		
    d072:	3f 50 06 00 	add	#6,	r15	;#0x0006
    d076:	3f 50 04 02 	add	#516,	r15	;#0x0204
{
  linkID_t *locLID = &sPersistInfo.nextLinkID;
  uint8_t   tmp;

    /* this element will be populated during the exchange with the peer. */
  pCInfo->portTx = 0;
    d07a:	cf 43 09 00 	mov.b	#0,	9(r15)	;r3 As==00, 0x0009(r15)

  pCInfo->connState  =  CONNSTATE_CONNECTED;
    d07e:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
  pCInfo->thisLinkID = *locLID;
    d082:	5d 42 08 02 	mov.b	&0x0208,r13	
    d086:	cf 4d 0a 00 	mov.b	r13,	10(r15)	;0x000a(r15)
   * we can end up with confusing duplicates. We can protect aginst using
   * one that is already in use but we can't protect against a stale Link ID
   * remembered by an application that doesn't know its connection has been
   * torn down. The test for 0 will hopefully never be true (indicating a wrap).
   */
  (*locLID)++;
    d08a:	5d 53       	inc.b	r13		
    d08c:	c2 4d 08 02 	mov.b	r13,	&0x0208	

  while (!*locLID || (*locLID == SMPL_LINKID_USER_UUD) || map_lid2idx(*locLID, &tmp))
    d090:	4e 4d       	mov.b	r13,	r14	
    d092:	7e 53       	add.b	#-1,	r14	;r3 As==11
    d094:	7e 90 fe ff 	cmp.b	#-2,	r14	;#0xfffe
    d098:	0e 2c       	jc	$+30     	;abs 0xd0b6
 * @return   Non-zero if Link ID found and output is valid else 0.
 */
static uint8_t map_lid2idx(linkID_t lid, uint8_t *idx)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;
    d09a:	3e 40 0a 02 	mov	#522,	r14	;#0x020a

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
  {
    if ((CONNSTATE_CONNECTED == ptr->connState) && (ptr->thisLinkID == lid))
    d09e:	6c 4e       	mov.b	@r14,	r12	
    d0a0:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    d0a2:	06 24       	jz	$+14     	;abs 0xd0b0
static uint8_t map_lid2idx(linkID_t lid, uint8_t *idx)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
    d0a4:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    d0a8:	3e 90 2e 02 	cmp	#558,	r14	;#0x022e
    d0ac:	f8 23       	jnz	$-14     	;abs 0xd09e
    d0ae:	30 41       	ret			
  {
    if ((CONNSTATE_CONNECTED == ptr->connState) && (ptr->thisLinkID == lid))
    d0b0:	ce 9d 0a 00 	cmp.b	r13,	10(r14)	;0x000a(r14)
    d0b4:	f7 23       	jnz	$-16     	;abs 0xd0a4
   */
  (*locLID)++;

  while (!*locLID || (*locLID == SMPL_LINKID_USER_UUD) || map_lid2idx(*locLID, &tmp))
  {
    (*locLID)++;
    d0b6:	5d 53       	inc.b	r13		
    d0b8:	c2 4d 08 02 	mov.b	r13,	&0x0208	
    d0bc:	e9 3f       	jmp	$-44     	;abs 0xd090
{
  uint8_t  i;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i)
  {
    if (sPersistInfo.connStruct[i].connState == CONNSTATE_CONNECTED)
    d0be:	5f 42 16 02 	mov.b	&0x0216,r15	
    d0c2:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    d0c4:	02 24       	jz	$+6      	;abs 0xd0ca
    d0c6:	1e 43       	mov	#1,	r14	;r3 As==01
    d0c8:	cf 3f       	jmp	$-96     	;abs 0xd068
    d0ca:	5f 42 22 02 	mov.b	&0x0222,r15	
    d0ce:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    d0d0:	02 24       	jz	$+6      	;abs 0xd0d6
    d0d2:	2e 43       	mov	#2,	r14	;r3 As==10
    d0d4:	c9 3f       	jmp	$-108    	;abs 0xd068
    break;
  }

  if (SYS_NUM_CONNECTIONS == i)
  {
    return (connInfo_t *)0;
    d0d6:	0f 43       	clr	r15		
  }

  initializeConnection(&sPersistInfo.connStruct[i]);

  return &sPersistInfo.connStruct[i];
}
    d0d8:	30 41       	ret			

0000d0da <nwk_freeConnection>:
 * @return   None.
 */
void nwk_freeConnection(connInfo_t *pCInfo)
{
#if NUM_CONNECTIONS > 0
  pCInfo->connState = CONNSTATE_FREE;
    d0da:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
#endif
}
    d0de:	30 41       	ret			

0000d0e0 <nwk_getConnInfo>:
static uint8_t map_lid2idx(linkID_t lid, uint8_t *idx)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
    d0e0:	4d 43       	clr.b	r13		
 * @return   Non-zero if Link ID found and output is valid else 0.
 */
static uint8_t map_lid2idx(linkID_t lid, uint8_t *idx)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;
    d0e2:	3e 40 0a 02 	mov	#522,	r14	;#0x020a

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
  {
    if ((CONNSTATE_CONNECTED == ptr->connState) && (ptr->thisLinkID == lid))
    d0e6:	6c 4e       	mov.b	@r14,	r12	
    d0e8:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    d0ea:	08 24       	jz	$+18     	;abs 0xd0fc
static uint8_t map_lid2idx(linkID_t lid, uint8_t *idx)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
    d0ec:	5d 53       	inc.b	r13		
    d0ee:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    d0f2:	7d 90 03 00 	cmp.b	#3,	r13	;#0x0003
    d0f6:	f7 23       	jnz	$-16     	;abs 0xd0e6
{
  uint8_t idx, rc;

  rc = map_lid2idx(linkID, &idx);

  return (rc && (CONNSTATE_CONNECTED == sPersistInfo.connStruct[idx].connState)) ? &sPersistInfo.connStruct[idx] : (connInfo_t *)0;
    d0f8:	0f 43       	clr	r15		
    d0fa:	30 41       	ret			
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
  {
    if ((CONNSTATE_CONNECTED == ptr->connState) && (ptr->thisLinkID == lid))
    d0fc:	5f 9e 0a 00 	cmp.b	10(r14),r15	;0x000a(r14)
    d100:	f5 23       	jnz	$-20     	;abs 0xd0ec
{
  uint8_t idx, rc;

  rc = map_lid2idx(linkID, &idx);

  return (rc && (CONNSTATE_CONNECTED == sPersistInfo.connStruct[idx].connState)) ? &sPersistInfo.connStruct[idx] : (connInfo_t *)0;
    d102:	4d 4d       	mov.b	r13,	r13	
    d104:	0f 4d       	mov	r13,	r15	
    d106:	0f 5f       	rla	r15		
    d108:	0f 5d       	add	r13,	r15	
    d10a:	0e 4f       	mov	r15,	r14	
    d10c:	0e 5e       	rla	r14		
    d10e:	0e 5e       	rla	r14		
    d110:	3e 50 0a 02 	add	#522,	r14	;#0x020a
    d114:	6e 4e       	mov.b	@r14,	r14	
    d116:	6e 93       	cmp.b	#2,	r14	;r3 As==10
    d118:	07 20       	jnz	$+16     	;abs 0xd128
    d11a:	0f 5f       	rla	r15		
    d11c:	0f 5f       	rla	r15		
    d11e:	3f 50 06 00 	add	#6,	r15	;#0x0006
    d122:	3f 50 04 02 	add	#516,	r15	;#0x0204
    d126:	30 41       	ret			
    d128:	0f 43       	clr	r15		
}
    d12a:	30 41       	ret			

0000d12c <nwk_isLinkDuplicate>:
 *
 * @return   Returns pointer to connection entry if the address and remote Port
 *           match an existing entry, otherwise 0.
 */
connInfo_t *nwk_isLinkDuplicate(uint8_t *addr, uint8_t remotePort)
{
    d12c:	0b 12       	push	r11		
    d12e:	0a 12       	push	r10		
    d130:	09 12       	push	r9		
    d132:	0a 4f       	mov	r15,	r10	
    d134:	49 4e       	mov.b	r14,	r9	
#if NUM_CONNECTIONS > 0
  uint8_t       i;
  connInfo_t   *ptr = sPersistInfo.connStruct;
    d136:	3b 40 0a 02 	mov	#522,	r11	;#0x020a

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    d13a:	6d 4b       	mov.b	@r11,	r13	
    d13c:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    d13e:	0b 24       	jz	$+24     	;abs 0xd156
{
#if NUM_CONNECTIONS > 0
  uint8_t       i;
  connInfo_t   *ptr = sPersistInfo.connStruct;

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
    d140:	3b 50 0c 00 	add	#12,	r11	;#0x000c
    d144:	3b 90 22 02 	cmp	#546,	r11	;#0x0222
    d148:	f8 23       	jnz	$-14     	;abs 0xd13a
      }
    }
  }
#endif

  return (connInfo_t *)NULL;
    d14a:	0b 43       	clr	r11		
}
    d14c:	0f 4b       	mov	r11,	r15	
    d14e:	39 41       	pop	r9		
    d150:	3a 41       	pop	r10		
    d152:	3b 41       	pop	r11		
    d154:	30 41       	ret			

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    {
      if (!(memcmp(ptr->peerAddr, addr, NET_ADDR_SIZE)) &&
    d156:	2d 42       	mov	#4,	r13	;r2 As==10
    d158:	0e 4a       	mov	r10,	r14	
    d15a:	0f 4b       	mov	r11,	r15	
    d15c:	2f 53       	incd	r15		
    d15e:	b0 12 08 e2 	call	#0xe208	
    d162:	0f 93       	tst	r15		
    d164:	ed 23       	jnz	$-36     	;abs 0xd140
    d166:	cb 99 09 00 	cmp.b	r9,	9(r11)	;0x0009(r11)
    d16a:	ea 23       	jnz	$-42     	;abs 0xd140
    d16c:	ef 3f       	jmp	$-32     	;abs 0xd14c

0000d16e <nwk_findAddressMatch>:
 * output parameters
 *
 * @return   Returns non-zero if a match is found, otherwise 0.
 */
uint8_t nwk_findAddressMatch(mrfiPacket_t *frame)
{
    d16e:	0b 12       	push	r11		
    d170:	0b 4f       	mov	r15,	r11	
  connInfo_t   *ptr = sPersistInfo.connStruct;

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {

    if (CONNSTATE_CONNECTED == ptr->connState)
    d172:	5f 42 0a 02 	mov.b	&0x020a,r15	
    d176:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    d178:	13 24       	jz	$+40     	;abs 0xd1a0
    d17a:	5f 42 16 02 	mov.b	&0x0216,r15	
    d17e:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    d180:	03 24       	jz	$+8      	;abs 0xd188
      }
    }
  }
#endif

  return 0;
    d182:	4f 43       	clr.b	r15		
}
    d184:	3b 41       	pop	r11		
    d186:	30 41       	ret			
  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {

    if (CONNSTATE_CONNECTED == ptr->connState)
    {
      if (!(memcmp(ptr->peerAddr, MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE)))
    d188:	2d 42       	mov	#4,	r13	;r2 As==10
    d18a:	0e 4b       	mov	r11,	r14	
    d18c:	3e 50 05 00 	add	#5,	r14	;#0x0005
    d190:	3f 40 18 02 	mov	#536,	r15	;#0x0218
    d194:	b0 12 08 e2 	call	#0xe208	
    d198:	0f 93       	tst	r15		
    d19a:	f3 23       	jnz	$-24     	;abs 0xd182
      {
        return 1;
    d19c:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d19e:	f2 3f       	jmp	$-26     	;abs 0xd184
  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {

    if (CONNSTATE_CONNECTED == ptr->connState)
    {
      if (!(memcmp(ptr->peerAddr, MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE)))
    d1a0:	2d 42       	mov	#4,	r13	;r2 As==10
    d1a2:	0e 4b       	mov	r11,	r14	
    d1a4:	3e 50 05 00 	add	#5,	r14	;#0x0005
    d1a8:	3f 40 0c 02 	mov	#524,	r15	;#0x020c
    d1ac:	b0 12 08 e2 	call	#0xe208	
    d1b0:	0f 93       	tst	r15		
    d1b2:	e3 23       	jnz	$-56     	;abs 0xd17a
      {
        return 1;
    d1b4:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d1b6:	e6 3f       	jmp	$-50     	;abs 0xd184

0000d1b8 <nwk_checkConnInfo>:
smplStatus_t nwk_checkConnInfo(connInfo_t *ptr, uint8_t which)
{
  uint8_t  port;

  /* make sure port isn't null and that the entry is active */
  port = (CHK_RX == which) ? ptr->portRx : ptr->portTx;
    d1b8:	4e 93       	tst.b	r14		
    d1ba:	06 20       	jnz	$+14     	;abs 0xd1c8
    d1bc:	5e 4f 08 00 	mov.b	8(r15),	r14	;0x0008(r15)
  if (!port || (CONNSTATE_FREE == ptr->connState))
    d1c0:	4e 93       	tst.b	r14		
    d1c2:	06 20       	jnz	$+14     	;abs 0xd1d0
  {
    return SMPL_BAD_PARAM;
    d1c4:	2f 43       	mov	#2,	r15	;r3 As==10
    d1c6:	30 41       	ret			
smplStatus_t nwk_checkConnInfo(connInfo_t *ptr, uint8_t which)
{
  uint8_t  port;

  /* make sure port isn't null and that the entry is active */
  port = (CHK_RX == which) ? ptr->portRx : ptr->portTx;
    d1c8:	5e 4f 09 00 	mov.b	9(r15),	r14	;0x0009(r15)
  if (!port || (CONNSTATE_FREE == ptr->connState))
    d1cc:	4e 93       	tst.b	r14		
    d1ce:	fa 27       	jz	$-10     	;abs 0xd1c4
    d1d0:	6f 4f       	mov.b	@r15,	r15	
    d1d2:	4f 93       	tst.b	r15		
    d1d4:	f7 27       	jz	$-16     	;abs 0xd1c4
  {
    return SMPL_BAD_PARAM;
  }

  /* validate port number */
  if (port < PORT_BASE_NUMBER)
    d1d6:	7e 90 20 00 	cmp.b	#32,	r14	;#0x0020
    d1da:	f4 2b       	jnc	$-22     	;abs 0xd1c4
  {
    return SMPL_BAD_PARAM;
  }

  return SMPL_SUCCESS;
    d1dc:	0f 43       	clr	r15		
}
    d1de:	30 41       	ret			

0000d1e0 <nwk_isConnectionValid>:
 * @param   lid   - link ID of found connection
 *
 * @return   0 if connection specified in frame is not valid, otherwise non-zero.
 */
uint8_t nwk_isConnectionValid(mrfiPacket_t *frame, linkID_t *lid)
{
    d1e0:	0b 12       	push	r11		
    d1e2:	0a 12       	push	r10		
    d1e4:	09 12       	push	r9		
    d1e6:	08 12       	push	r8		
    d1e8:	0a 4e       	mov	r14,	r10	
  uint8_t       i;
  connInfo_t   *ptr  = sPersistInfo.connStruct;
  uint8_t       port = GET_FROM_FRAME(MRFI_P_PAYLOAD(frame), F_PORT_OS);
    d1ea:	59 4f 09 00 	mov.b	9(r15),	r9	;0x0009(r15)
    d1ee:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f
 * @return   0 if connection specified in frame is not valid, otherwise non-zero.
 */
uint8_t nwk_isConnectionValid(mrfiPacket_t *frame, linkID_t *lid)
{
  uint8_t       i;
  connInfo_t   *ptr  = sPersistInfo.connStruct;
    d1f2:	3b 40 0a 02 	mov	#522,	r11	;#0x020a
    {
      /* check port first since we're done if the port is the user bcast port. */
      if (port == ptr->portRx)
      {
        /* yep...ports match. */
        if ((SMPL_PORT_USER_BCAST == port) || !(memcmp(ptr->peerAddr, MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE)))
    d1f6:	08 4f       	mov	r15,	r8	
    d1f8:	38 50 05 00 	add	#5,	r8	;#0x0005
  connInfo_t   *ptr  = sPersistInfo.connStruct;
  uint8_t       port = GET_FROM_FRAME(MRFI_P_PAYLOAD(frame), F_PORT_OS);

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i,++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    d1fc:	6d 4b       	mov.b	@r11,	r13	
    d1fe:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    d200:	0b 24       	jz	$+24     	;abs 0xd218
{
  uint8_t       i;
  connInfo_t   *ptr  = sPersistInfo.connStruct;
  uint8_t       port = GET_FROM_FRAME(MRFI_P_PAYLOAD(frame), F_PORT_OS);

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i,++ptr)
    d202:	3b 50 0c 00 	add	#12,	r11	;#0x000c
    d206:	3b 90 2e 02 	cmp	#558,	r11	;#0x022e
    d20a:	f8 23       	jnz	$-14     	;abs 0xd1fc
      }
    }
  }

  /* no matches */
  return 0;
    d20c:	4f 43       	clr.b	r15		
}
    d20e:	38 41       	pop	r8		
    d210:	39 41       	pop	r9		
    d212:	3a 41       	pop	r10		
    d214:	3b 41       	pop	r11		
    d216:	30 41       	ret			
  for (i=0; i<SYS_NUM_CONNECTIONS; ++i,++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    {
      /* check port first since we're done if the port is the user bcast port. */
      if (port == ptr->portRx)
    d218:	cb 99 08 00 	cmp.b	r9,	8(r11)	;0x0008(r11)
    d21c:	f2 23       	jnz	$-26     	;abs 0xd202
      {
        /* yep...ports match. */
        if ((SMPL_PORT_USER_BCAST == port) || !(memcmp(ptr->peerAddr, MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE)))
    d21e:	79 90 3f 00 	cmp.b	#63,	r9	;#0x003f
    d222:	08 24       	jz	$+18     	;abs 0xd234
    d224:	2d 42       	mov	#4,	r13	;r2 As==10
    d226:	0e 48       	mov	r8,	r14	
    d228:	0f 4b       	mov	r11,	r15	
    d22a:	2f 53       	incd	r15		
    d22c:	b0 12 08 e2 	call	#0xe208	
    d230:	0f 93       	tst	r15		
    d232:	e7 23       	jnz	$-48     	;abs 0xd202
        {
          uint8_t rc = 1;

          /* we're done. */
          *lid = ptr->thisLinkID;
    d234:	da 4b 0a 00 	mov.b	10(r11),0(r10)	;0x000a(r11), 0x0000(r10)
    d238:	00 00 
          }
#endif  /* APP_AUTO_ACK */
          /* Unconditionally kill the reply delay semaphore. This used to be done
           * unconditionally in the calling routine.
           */
          MRFI_PostKillSem();
    d23a:	b0 12 8e c4 	call	#0xc48e	
          return rc;
    d23e:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d240:	e6 3f       	jmp	$-50     	;abs 0xd20e

0000d242 <nwk_allocateLocalRxPort>:
 * @param   newPtr->portRx  - element is populated with port number.
 *
 * @return   Non-zero if port number assigned. 0 if no port available.
 */
uint8_t nwk_allocateLocalRxPort(uint8_t which, connInfo_t *newPtr)
{
    d242:	0b 12       	push	r11		
    d244:	0a 12       	push	r10		
    d246:	09 12       	push	r9		
    d248:	08 12       	push	r8		
    d24a:	07 12       	push	r7		
    d24c:	21 83       	decd	r1		
    d24e:	49 4f       	mov.b	r15,	r9	
    d250:	0a 4e       	mov	r14,	r10	
#if NUM_CONNECTIONS > 0
  uint8_t     num, i;
  uint8_t     marker[NUM_CONNECTIONS];
  connInfo_t *ptr = sPersistInfo.connStruct;

  memset(&marker, 0x0, sizeof(marker));
    d252:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00, 0x0000(r1)
uint8_t nwk_allocateLocalRxPort(uint8_t which, connInfo_t *newPtr)
{
#if NUM_CONNECTIONS > 0
  uint8_t     num, i;
  uint8_t     marker[NUM_CONNECTIONS];
  connInfo_t *ptr = sPersistInfo.connStruct;
    d256:	3b 40 0a 02 	mov	#522,	r11	;#0x020a
        if (ptr->portRx > sPersistInfo.curNextLinkPort)
        {
          marker[SMPL_PORT_USER_MAX - ptr->portRx] = 1;
        }
      }
      else if (!memcmp(ptr->peerAddr, newPtr->peerAddr, NET_ADDR_SIZE))
    d25a:	07 4e       	mov	r14,	r7	
    d25c:	27 53       	incd	r7		
  memset(&marker, 0x0, sizeof(marker));

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {
    /* Mark the port number as used unless it's a statically allocated port */
    if ((ptr != newPtr) && (CONNSTATE_CONNECTED == ptr->connState) && (ptr->portRx <= SMPL_PORT_USER_MAX))
    d25e:	0b 9a       	cmp	r10,	r11	
    d260:	03 24       	jz	$+8      	;abs 0xd268
    d262:	6f 4b       	mov.b	@r11,	r15	
    d264:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    d266:	1f 24       	jz	$+64     	;abs 0xd2a6
  uint8_t     marker[NUM_CONNECTIONS];
  connInfo_t *ptr = sPersistInfo.connStruct;

  memset(&marker, 0x0, sizeof(marker));

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
    d268:	3b 50 0c 00 	add	#12,	r11	;#0x000c
    d26c:	3b 90 22 02 	cmp	#546,	r11	;#0x0222
    d270:	f6 23       	jnz	$-18     	;abs 0xd25e
  }

  num = 0;
  for (i=0; i<NUM_CONNECTIONS; ++i)
  {
    if (!marker[i])
    d272:	c1 93 00 00 	tst.b	0(r1)		;0x0000(r1)
    d276:	3c 24       	jz	$+122    	;abs 0xd2f0
    d278:	c1 93 01 00 	tst.b	1(r1)		;0x0001(r1)
    d27c:	40 24       	jz	$+130    	;abs 0xd2fe
          marker[ptr->portRx - PORT_BASE_NUMBER] = 1;
      }
    }
  }

  num = 0;
    d27e:	4f 43       	clr.b	r15		
      }
      break;
    }
  }

  if (LINK_REPLY == which)
    d280:	69 93       	cmp.b	#2,	r9	;r3 As==10
    d282:	06 24       	jz	$+14     	;abs 0xd290
  else
  {
    /* if the number we have doesn't overlap the assignment of ports used
     * for sending link frame replies, use it.
     */
    if (num >= sPersistInfo.curMaxReplyPort)
    d284:	5f 92 07 02 	cmp.b	&0x0207,r15	
    d288:	0c 28       	jnc	$+26     	;abs 0xd2a2
    {
      if (num == sPersistInfo.curNextLinkPort)
    d28a:	c2 9f 06 02 	cmp.b	r15,	&0x0206	
    d28e:	22 24       	jz	$+70     	;abs 0xd2d4
       */
      num = 0;
    }
  }

  newPtr->portRx = num;
    d290:	ca 4f 08 00 	mov.b	r15,	8(r10)	;0x0008(r10)
  return num;
#else
  return 0;
#endif  /* NUM_CONNECTIONS > 0 */

}
    d294:	21 53       	incd	r1		
    d296:	37 41       	pop	r7		
    d298:	38 41       	pop	r8		
    d29a:	39 41       	pop	r9		
    d29c:	3a 41       	pop	r10		
    d29e:	3b 41       	pop	r11		
    d2a0:	30 41       	ret			
      /* the port number we need has already been used in the other context. It may or
       * may not have been used for the same address but we don't bother to check...we
       * just reject the asignment. This is the overly cautious part but is extermely
       * unlikely to ever occur.
       */
      num = 0;
    d2a2:	4f 43       	clr.b	r15		
    d2a4:	f5 3f       	jmp	$-20     	;abs 0xd290
  memset(&marker, 0x0, sizeof(marker));

  for (i=0; i<NUM_CONNECTIONS; ++i,++ptr)
  {
    /* Mark the port number as used unless it's a statically allocated port */
    if ((ptr != newPtr) && (CONNSTATE_CONNECTED == ptr->connState) && (ptr->portRx <= SMPL_PORT_USER_MAX))
    d2a6:	58 4b 08 00 	mov.b	8(r11),	r8	;0x0008(r11)
    d2aa:	78 90 3e 00 	cmp.b	#62,	r8	;#0x003e
    d2ae:	dc 2f       	jc	$-70     	;abs 0xd268
    {
      if (LINK_SEND == which)
    d2b0:	59 93       	cmp.b	#1,	r9	;r3 As==01
    d2b2:	15 24       	jz	$+44     	;abs 0xd2de
        if (ptr->portRx > sPersistInfo.curNextLinkPort)
        {
          marker[SMPL_PORT_USER_MAX - ptr->portRx] = 1;
        }
      }
      else if (!memcmp(ptr->peerAddr, newPtr->peerAddr, NET_ADDR_SIZE))
    d2b4:	2d 42       	mov	#4,	r13	;r2 As==10
    d2b6:	0e 47       	mov	r7,	r14	
    d2b8:	0f 4b       	mov	r11,	r15	
    d2ba:	2f 53       	incd	r15		
    d2bc:	b0 12 08 e2 	call	#0xe208	
    d2c0:	0f 93       	tst	r15		
    d2c2:	d2 23       	jnz	$-90     	;abs 0xd268
      {
          marker[ptr->portRx - PORT_BASE_NUMBER] = 1;
    d2c4:	48 48       	mov.b	r8,	r8	
    d2c6:	3e 40 e0 ff 	mov	#-32,	r14	;#0xffe0
    d2ca:	0e 51       	add	r1,	r14	
    d2cc:	08 5e       	add	r14,	r8	
    d2ce:	d8 43 00 00 	mov.b	#1,	0(r8)	;r3 As==01, 0x0000(r8)
    d2d2:	ca 3f       	jmp	$-106    	;abs 0xd268
     */
    if (num >= sPersistInfo.curMaxReplyPort)
    {
      if (num == sPersistInfo.curNextLinkPort)
      {
        sPersistInfo.curNextLinkPort--;
    d2d4:	4e 4f       	mov.b	r15,	r14	
    d2d6:	7e 53       	add.b	#-1,	r14	;r3 As==11
    d2d8:	c2 4e 06 02 	mov.b	r14,	&0x0206	
    d2dc:	d9 3f       	jmp	$-76     	;abs 0xd290
    /* Mark the port number as used unless it's a statically allocated port */
    if ((ptr != newPtr) && (CONNSTATE_CONNECTED == ptr->connState) && (ptr->portRx <= SMPL_PORT_USER_MAX))
    {
      if (LINK_SEND == which)
      {
        if (ptr->portRx > sPersistInfo.curNextLinkPort)
    d2de:	c2 98 06 02 	cmp.b	r8,	&0x0206	
    d2e2:	c2 2f       	jc	$-122    	;abs 0xd268
        {
          marker[SMPL_PORT_USER_MAX - ptr->portRx] = 1;
    d2e4:	48 48       	mov.b	r8,	r8	
    d2e6:	0f 41       	mov	r1,	r15	
    d2e8:	0f 88       	sub	r8,	r15	
    d2ea:	df 43 3d 00 	mov.b	#1,	61(r15)	;r3 As==01, 0x003d(r15)
    d2ee:	bc 3f       	jmp	$-134    	;abs 0xd268
  }

  num = 0;
  for (i=0; i<NUM_CONNECTIONS; ++i)
  {
    if (!marker[i])
    d2f0:	4e 43       	clr.b	r14		
    {
      if (LINK_REPLY == which)
    d2f2:	69 93       	cmp.b	#2,	r9	;r3 As==10
    d2f4:	06 24       	jz	$+14     	;abs 0xd302
      {
        num = PORT_BASE_NUMBER + i;
      }
      else
      {
        num = SMPL_PORT_USER_MAX - i;
    d2f6:	7f 40 3d 00 	mov.b	#61,	r15	;#0x003d
    d2fa:	4f 8e       	sub.b	r14,	r15	
    d2fc:	c3 3f       	jmp	$-120    	;abs 0xd284
      }
    }
  }

  num = 0;
  for (i=0; i<NUM_CONNECTIONS; ++i)
    d2fe:	5e 43       	mov.b	#1,	r14	;r3 As==01
    d300:	f8 3f       	jmp	$-14     	;abs 0xd2f2
  {
    if (!marker[i])
    {
      if (LINK_REPLY == which)
      {
        num = PORT_BASE_NUMBER + i;
    d302:	4f 4e       	mov.b	r14,	r15	
    d304:	7f 50 20 00 	add.b	#32,	r15	;#0x0020
  if (LINK_REPLY == which)
  {
    /* if the number we have doesn't overlap the assignment of ports used
     * for sending link frames, use it.
     */
    if (num <= sPersistInfo.curNextLinkPort)
    d308:	c2 9f 06 02 	cmp.b	r15,	&0x0206	
    d30c:	ca 2b       	jnc	$-106    	;abs 0xd2a2
    {
      if (num > sPersistInfo.curMaxReplyPort)
    d30e:	c2 9f 07 02 	cmp.b	r15,	&0x0207	
    d312:	be 2f       	jc	$-130    	;abs 0xd290
      {
        /* remember maximum port number used */
        sPersistInfo.curMaxReplyPort = num;
    d314:	c2 4f 07 02 	mov.b	r15,	&0x0207	
    d318:	bb 3f       	jmp	$-136    	;abs 0xd290

0000d31a <nwk_isValidReply>:
 *               SMPL_NOT_REPLY: not a reply
 *               SMPL_MY_REPLY : a reply that matches input parameters
 *               SMPL_A_REPLY  : a reply but does not match input parameters
 */
uint8_t nwk_isValidReply(mrfiPacket_t *frame, uint8_t tid, uint8_t infoOffset, uint8_t tidOffset)
{
    d31a:	0b 12       	push	r11		
    d31c:	0b 4f       	mov	r15,	r11	
  uint8_t rc = SMPL_NOT_REPLY;

  if ((*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+infoOffset) & NWK_APP_REPLY_BIT))
    d31e:	4d 4d       	mov.b	r13,	r13	
    d320:	0d 5f       	add	r15,	r13	
    d322:	cd 93 0c 00 	tst.b	12(r13)	;0x000c(r13)
    d326:	04 38       	jl	$+10     	;abs 0xd330
 *               SMPL_MY_REPLY : a reply that matches input parameters
 *               SMPL_A_REPLY  : a reply but does not match input parameters
 */
uint8_t nwk_isValidReply(mrfiPacket_t *frame, uint8_t tid, uint8_t infoOffset, uint8_t tidOffset)
{
  uint8_t rc = SMPL_NOT_REPLY;
    d328:	6e 43       	mov.b	#2,	r14	;r3 As==10
      rc = SMPL_A_REPLY;
    }
  }

  return rc;
}
    d32a:	4f 4e       	mov.b	r14,	r15	
    d32c:	3b 41       	pop	r11		
    d32e:	30 41       	ret			
{
  uint8_t rc = SMPL_NOT_REPLY;

  if ((*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+infoOffset) & NWK_APP_REPLY_BIT))
  {
    if ((*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+tidOffset) == tid) &&
    d330:	4c 4c       	mov.b	r12,	r12	
    d332:	0c 5f       	add	r15,	r12	
    d334:	5e 9c 0c 00 	cmp.b	12(r12),r14	;0x000c(r12)
    d338:	04 24       	jz	$+10     	;abs 0xd342
    {
      rc = SMPL_MY_REPLY;
    }
    else
    {
      rc = SMPL_A_REPLY;
    d33a:	5e 43       	mov.b	#1,	r14	;r3 As==01
    }
  }

  return rc;
}
    d33c:	4f 4e       	mov.b	r14,	r15	
    d33e:	3b 41       	pop	r11		
    d340:	30 41       	ret			
  uint8_t rc = SMPL_NOT_REPLY;

  if ((*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+infoOffset) & NWK_APP_REPLY_BIT))
  {
    if ((*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+tidOffset) == tid) &&
        !memcmp(MRFI_P_DST_ADDR(frame), nwk_getMyAddress(), NET_ADDR_SIZE))
    d342:	b0 12 56 dd 	call	#0xdd56	
    d346:	2d 42       	mov	#4,	r13	;r2 As==10
    d348:	0e 4f       	mov	r15,	r14	
    d34a:	0f 4b       	mov	r11,	r15	
    d34c:	1f 53       	inc	r15		
    d34e:	b0 12 08 e2 	call	#0xe208	
 * @return   reply category:
 *               SMPL_NOT_REPLY: not a reply
 *               SMPL_MY_REPLY : a reply that matches input parameters
 *               SMPL_A_REPLY  : a reply but does not match input parameters
 */
uint8_t nwk_isValidReply(mrfiPacket_t *frame, uint8_t tid, uint8_t infoOffset, uint8_t tidOffset)
    d352:	5e 43       	mov.b	#1,	r14	;r3 As==01
    d354:	0f 93       	tst	r15		
    d356:	e9 23       	jnz	$-44     	;abs 0xd32a
    d358:	4e 43       	clr.b	r14		
    d35a:	e7 3f       	jmp	$-48     	;abs 0xd32a

0000d35c <nwk_findPeer>:
 * output parameters
 *
 * @return   Pointer to matching connection table entry else 0.
 */
connInfo_t *nwk_findPeer(addr_t *peerAddr, uint8_t peerPort)
{
    d35c:	0b 12       	push	r11		
    d35e:	0a 12       	push	r10		
    d360:	09 12       	push	r9		
    d362:	0a 4f       	mov	r15,	r10	
    d364:	49 4e       	mov.b	r14,	r9	
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;
    d366:	3b 40 0a 02 	mov	#522,	r11	;#0x020a

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    d36a:	6d 4b       	mov.b	@r11,	r13	
    d36c:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    d36e:	0b 24       	jz	$+24     	;abs 0xd386
connInfo_t *nwk_findPeer(addr_t *peerAddr, uint8_t peerPort)
{
  uint8_t     i;
  connInfo_t *ptr = sPersistInfo.connStruct;

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
    d370:	3b 50 0c 00 	add	#12,	r11	;#0x000c
    d374:	3b 90 2e 02 	cmp	#558,	r11	;#0x022e
    d378:	f8 23       	jnz	$-14     	;abs 0xd36a
        }
      }
    }
  }

  return (connInfo_t *)NULL;
    d37a:	0b 43       	clr	r11		
}
    d37c:	0f 4b       	mov	r11,	r15	
    d37e:	39 41       	pop	r9		
    d380:	3a 41       	pop	r10		
    d382:	3b 41       	pop	r11		
    d384:	30 41       	ret			

  for (i=0; i<SYS_NUM_CONNECTIONS; ++i, ++ptr)
  {
    if (CONNSTATE_CONNECTED == ptr->connState)
    {
      if (!memcmp(peerAddr, ptr->peerAddr, NET_ADDR_SIZE))
    d386:	2d 42       	mov	#4,	r13	;r2 As==10
    d388:	0e 4b       	mov	r11,	r14	
    d38a:	2e 53       	incd	r14		
    d38c:	0f 4a       	mov	r10,	r15	
    d38e:	b0 12 08 e2 	call	#0xe208	
    d392:	0f 93       	tst	r15		
    d394:	ed 23       	jnz	$-36     	;abs 0xd370
      {
        if (peerPort == ptr->portTx)
    d396:	cb 99 09 00 	cmp.b	r9,	9(r11)	;0x0009(r11)
    d39a:	ea 23       	jnz	$-42     	;abs 0xd370
    d39c:	ef 3f       	jmp	$-32     	;abs 0xd37c

0000d39e <nwk_checkAppMsgTID>:
 *           processed. The last-seen TID should be updated with the current
 *           application payload TID.
 *
 */
uint8_t nwk_checkAppMsgTID(appPTid_t lastTID, appPTid_t appMsgTID)
{
    d39e:	4d 4f       	mov.b	r15,	r13	
  uint8_t rc = 0;

  /* If the values are equal this is a duplicate. We're done. */
  if (lastTID != appMsgTID)
    d3a0:	4f 9e       	cmp.b	r14,	r15	
    d3a2:	10 24       	jz	$+34     	;abs 0xd3c4
  {
    /* Is the new TID bigger? */
    if (appMsgTID > lastTID)
    d3a4:	08 2c       	jc	$+18     	;abs 0xd3b6
       * (duplicate) message that occurred just before the TID wrapped. This is
       * considered a duplicate and we should discard it.
       */
      if (!(DUP_TID_AFTER_WRAP(lastTID, appMsgTID)))
      {
        rc = 1;
    d3a6:	5f 43       	mov.b	#1,	r15	;r3 As==01
    {
      /* In this case the current payload is OK unless we've received a late
       * (duplicate) message that occurred just before the TID wrapped. This is
       * considered a duplicate and we should discard it.
       */
      if (!(DUP_TID_AFTER_WRAP(lastTID, appMsgTID)))
    d3a8:	7e 90 fd ff 	cmp.b	#-3,	r14	;#0xfffd
    d3ac:	0f 28       	jnc	$+32     	;abs 0xd3cc
 *           Otherwise returns non-zero. In this case the message should be
 *           processed. The last-seen TID should be updated with the current
 *           application payload TID.
 *
 */
uint8_t nwk_checkAppMsgTID(appPTid_t lastTID, appPTid_t appMsgTID)
    d3ae:	7d 90 03 00 	cmp.b	#3,	r13	;#0x0003
    d3b2:	08 28       	jnc	$+18     	;abs 0xd3c4
      }
    }
  }

  return rc;
}
    d3b4:	30 41       	ret			
    {
      /* New TID is smaller. Accept the payload if this is the wrap case or we missed
       * the specific wrap frame but are still within the range in which we assume
       * we missed it. Otherwise is a genuine late frame so we should ignore it.
       */
      if (CHECK_TID_WRAP(lastTID, appMsgTID))
    d3b6:	7f 90 fd ff 	cmp.b	#-3,	r15	;#0xfffd
    d3ba:	06 28       	jnc	$+14     	;abs 0xd3c8
 *           application payload TID.
 *
 */
uint8_t nwk_checkAppMsgTID(appPTid_t lastTID, appPTid_t appMsgTID)
{
  uint8_t rc = 0;
    d3bc:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d3be:	7e 90 03 00 	cmp.b	#3,	r14	;#0x0003
    d3c2:	f8 2b       	jnc	$-14     	;abs 0xd3b4
    d3c4:	4f 43       	clr.b	r15		
    d3c6:	30 41       	ret			
    d3c8:	4f 43       	clr.b	r15		
      }
    }
  }

  return rc;
}
    d3ca:	30 41       	ret			
    d3cc:	30 41       	ret			

0000d3ce <nwk_getNumObjectFromMsg>:
 *                 guaranteed only for object size cases defined (and
 *                 vacuously size 1).
 *
 */
void nwk_getNumObjectFromMsg(void *src, void *dest, uint8_t objSize)
{
    d3ce:	0c 4e       	mov	r14,	r12	
  /* Take care of alignment */
  memmove(dest, src, objSize);
    d3d0:	4d 4d       	mov.b	r13,	r13	
    d3d2:	0e 4f       	mov	r15,	r14	
    d3d4:	0f 4c       	mov	r12,	r15	
    d3d6:	b0 12 22 e3 	call	#0xe322	
      *((uint32_t *)dest) = ntohl(*((uint32_t *)dest));
      break;
  }

  return;
}
    d3da:	30 41       	ret			

0000d3dc <nwk_putNumObjectIntoMsg>:
 * @return   void. There is no warning if there is no case for the supplied
 *                 object size. A simple copy is then done.
 *
 */
void nwk_putNumObjectIntoMsg(void *src, void *dest, uint8_t objSize)
{
    d3dc:	0b 12       	push	r11		
    d3de:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    d3e2:	0b 4e       	mov	r14,	r11	
  uint8_t *ptr;
  uint16_t u16;
  uint32_t u32;

  /* Take care of endianess */
  switch(objSize)
    d3e4:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    d3e6:	0c 24       	jz	$+26     	;abs 0xd400
    d3e8:	6d 92       	cmp.b	#4,	r13	;r2 As==10
    d3ea:	0e 24       	jz	$+30     	;abs 0xd408
    d3ec:	0c 4f       	mov	r15,	r12	
      ptr = (uint8_t *)src;
      break;
  }

  /* Take care of alignment */
  memmove(dest, ptr, objSize);
    d3ee:	4d 4d       	mov.b	r13,	r13	
    d3f0:	0e 4c       	mov	r12,	r14	
    d3f2:	0f 4b       	mov	r11,	r15	
    d3f4:	b0 12 22 e3 	call	#0xe322	

  return;
}
    d3f8:	31 50 06 00 	add	#6,	r1	;#0x0006
    d3fc:	3b 41       	pop	r11		
    d3fe:	30 41       	ret			
    case 1:
      ptr = (uint8_t *)src;
      break;

    case 2:
      u16 = htons(*((uint16_t *)src));
    d400:	a1 4f 00 00 	mov	@r15,	0(r1)	;0x0000(r1)
      ptr = (uint8_t *)&u16;
    d404:	0c 41       	mov	r1,	r12	
      break;
    d406:	f3 3f       	jmp	$-24     	;abs 0xd3ee

    case 4:
      u32 = htonl(*((uint32_t *)src));
    d408:	a1 4f 02 00 	mov	@r15,	2(r1)	;0x0002(r1)
    d40c:	91 4f 02 00 	mov	2(r15),	4(r1)	;0x0002(r15), 0x0004(r1)
    d410:	04 00 
      ptr = (uint8_t *)&u32;
    d412:	0c 41       	mov	r1,	r12	
    d414:	2c 53       	incd	r12		
      break;
    d416:	eb 3f       	jmp	$-40     	;abs 0xd3ee

0000d418 <nwk_NVObj>:

  return rc;
#else  /* NVOBJECT_SUPPORT */
  return SMPL_BAD_PARAM;
#endif
}
    d418:	2f 43       	mov	#2,	r15	;r3 As==10
    d41a:	30 41       	ret			

0000d41c <nwk_joinInit>:
 *
 * @return   void
 */
void nwk_joinInit(uint8_t (*pf)(linkID_t))
{
  if (!sJoinToken) 
    d41c:	82 93 58 02 	tst	&0x0258	
    d420:	09 20       	jnz	$+20     	;abs 0xd434
    d422:	82 93 5a 02 	tst	&0x025a	
    d426:	06 20       	jnz	$+14     	;abs 0xd434
  {
    sJoinToken = DEFAULT_JOIN_TOKEN;
    d428:	b2 40 08 07 	mov	#1800,	&0x0258	;#0x0708
    d42c:	58 02 
    d42e:	b2 40 06 05 	mov	#1286,	&0x025a	;#0x0506
    d432:	5a 02 
  }
  
  spCallback = pf;
    d434:	82 4f 5c 02 	mov	r15,	&0x025c	
  (void) spCallback;  /* keep compiler happy if we don't use this */

  sTid = MRFI_RandomByte() ;
    d438:	b0 12 30 c3 	call	#0xc330	
    d43c:	c2 4f 56 02 	mov.b	r15,	&0x0256	
#endif
  spSandFContext = nwk_getSFInfoPtr();
#endif

  return;
}
    d440:	30 41       	ret			

0000d442 <nwk_setJoinToken>:
 * @return   void
 */
void nwk_setJoinToken(uint32_t token)
{
  /* only set if the supplied token is non-zero. */
  if (token)
    d442:	0e 93       	tst	r14		
    d444:	03 20       	jnz	$+8      	;abs 0xd44c
    d446:	0f 93       	tst	r15		
    d448:	01 20       	jnz	$+4      	;abs 0xd44c
    d44a:	30 41       	ret			
  {
    sJoinToken = token;
    d44c:	82 4e 58 02 	mov	r14,	&0x0258	
    d450:	82 4f 5a 02 	mov	r15,	&0x025a	
    d454:	30 41       	ret			

0000d456 <nwk_getJoinToken>:
 * @return   Current link token
 */
void nwk_getJoinToken(uint32_t *pToken)
{
  /* only set if the supplied token is non-zero. */
  if (pToken)
    d456:	0f 93       	tst	r15		
    d458:	06 24       	jz	$+14     	;abs 0xd466
  {
    *pToken = sJoinToken;
    d45a:	9f 42 58 02 	mov	&0x0258,0(r15)	;0x0000(r15)
    d45e:	00 00 
    d460:	9f 42 5a 02 	mov	&0x025a,2(r15)	;0x0002(r15)
    d464:	02 00 
    d466:	30 41       	ret			

0000d468 <nwk_join>:
 * output parameters
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_join(void)
{
    d468:	0b 12       	push	r11		
    d46a:	31 50 e8 ff 	add	#-24,	r1	;#0xffe8
  uint8_t      msg[JOIN_FRAME_SIZE];
  uint32_t     linkToken;
  addr_t       apAddr;
  uint8_t      radioState = MRFI_GetRadioState();
    d46e:	b0 12 9c c4 	call	#0xc49c	
    d472:	4b 4f       	mov.b	r15,	r11	
    nwk_setChannel(&channels[i]);
#else
  {
#endif

    ioctl_info.send.addr = (addr_t *)nwk_getBCastAddress();
    d474:	b0 12 d6 dd 	call	#0xddd6	
    d478:	81 4f 10 00 	mov	r15,	16(r1)	;0x0010(r1)
    ioctl_info.send.msg  = msg;
    d47c:	0f 41       	mov	r1,	r15	
    d47e:	3f 52       	add	#8,	r15	;r2 As==11
    d480:	81 4f 12 00 	mov	r15,	18(r1)	;0x0012(r1)
    ioctl_info.send.len  = sizeof(msg);
    d484:	f1 42 14 00 	mov.b	#8,	20(r1)	;r2 As==11, 0x0014(r1)
    ioctl_info.send.port = SMPL_PORT_JOIN;
    d488:	f1 40 03 00 	mov.b	#3,	21(r1)	;#0x0003, 0x0015(r1)
    d48c:	15 00 

    /* Put join token in */
    nwk_putNumObjectIntoMsg((void *)&sJoinToken, msg+J_JOIN_TOKEN_OS, sizeof(sJoinToken));
    d48e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    d490:	0e 41       	mov	r1,	r14	
    d492:	3e 50 0a 00 	add	#10,	r14	;#0x000a
    d496:	3f 40 58 02 	mov	#600,	r15	;#0x0258
    d49a:	b0 12 dc d3 	call	#0xd3dc	
    /* set app info byte */
    msg[JB_REQ_OS] = JOIN_REQ_JOIN;
    d49e:	d1 43 08 00 	mov.b	#1,	8(r1)	;r3 As==01, 0x0008(r1)
    msg[JB_TID_OS] = sTid;
    d4a2:	d1 42 56 02 	mov.b	&0x0256,9(r1)	;0x0009(r1)
    d4a6:	09 00 
    /* Set number of connections supported. Used only by AP if it is
     * a data hub.
     */
    msg[J_NUMCONN_OS] = NUM_CONNECTIONS;
    d4a8:	e1 43 0e 00 	mov.b	#2,	14(r1)	;r3 As==10, 0x000e(r1)
    /* protocol version number */
    msg[J_PROTOCOL_VERSION_OS] = nwk_getProtocolVersion();
    d4ac:	b0 12 6e dd 	call	#0xdd6e	
    d4b0:	c1 4f 0f 00 	mov.b	r15,	15(r1)	;0x000f(r1)

    SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_WRITE, &ioctl_info.send);
    d4b4:	0d 41       	mov	r1,	r13	
    d4b6:	3d 50 10 00 	add	#16,	r13	;#0x0010
    d4ba:	3e 40 03 00 	mov	#3,	r14	;#0x0003
    d4be:	2f 43       	mov	#2,	r15	;r3 As==10
    d4c0:	b0 12 2c cf 	call	#0xcf2c	

    ioctl_info.recv.port = SMPL_PORT_JOIN;
    d4c4:	f1 40 03 00 	mov.b	#3,	21(r1)	;#0x0003, 0x0015(r1)
    d4c8:	15 00 
    ioctl_info.recv.msg  = msg;
    d4ca:	0f 41       	mov	r1,	r15	
    d4cc:	3f 52       	add	#8,	r15	;r2 As==11
    d4ce:	81 4f 12 00 	mov	r15,	18(r1)	;0x0012(r1)
    ioctl_info.recv.addr = &apAddr;    /* save AP address from reply */
    d4d2:	81 41 10 00 	mov	r1,	16(r1)	;0x0010(r1)

    NWK_CHECK_FOR_SETRX(radioState);
    d4d6:	7b 90 03 00 	cmp.b	#3,	r11	;#0x0003
    d4da:	33 24       	jz	$+104    	;abs 0xd542
    d4dc:	5b 93       	cmp.b	#1,	r11	;r3 As==01
    d4de:	34 24       	jz	$+106    	;abs 0xd548
    d4e0:	b0 12 ba c5 	call	#0xc5ba	
    NWK_REPLY_DELAY();
    d4e4:	b0 12 10 c4 	call	#0xc410	
    NWK_CHECK_FOR_RESTORE_STATE(radioState);
    d4e8:	b0 12 7a c5 	call	#0xc57a	

    if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
    d4ec:	0d 41       	mov	r1,	r13	
    d4ee:	3d 50 10 00 	add	#16,	r13	;#0x0010
    d4f2:	2e 43       	mov	#2,	r14	;r3 As==10
    d4f4:	2f 43       	mov	#2,	r15	;r3 As==10
    d4f6:	b0 12 2c cf 	call	#0xcf2c	
    d4fa:	0f 93       	tst	r15		
    d4fc:	06 24       	jz	$+14     	;abs 0xd50a
{
  uint8_t      msg[JOIN_FRAME_SIZE];
  uint32_t     linkToken;
  addr_t       apAddr;
  uint8_t      radioState = MRFI_GetRadioState();
  smplStatus_t rc = SMPL_NO_JOIN;
    d4fe:	3f 40 06 00 	mov	#6,	r15	;#0x0006
    /* TODO: process encryption stuff */
  }

  return rc;

}
    d502:	31 50 18 00 	add	#24,	r1	;#0x0018
    d506:	3b 41       	pop	r11		
    d508:	30 41       	ret			
    NWK_REPLY_DELAY();
    NWK_CHECK_FOR_RESTORE_STATE(radioState);

    if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
    {
      uint8_t firstByte = msg[JB_REQ_OS] & (~NWK_APP_REPLY_BIT);
    d50a:	5f 41 08 00 	mov.b	8(r1),	r15	;0x0008(r1)
    d50e:	7f f0 7f 00 	and.b	#127,	r15	;#0x007f

      /* Sanity check for correct reply frame. Older version
       * has the length instead of the request as the first byte.
       */
      if ((firstByte == JOIN_REQ_JOIN) ||
    d512:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    d514:	03 24       	jz	$+8      	;abs 0xd51c
    d516:	7f 90 06 00 	cmp.b	#6,	r15	;#0x0006
    d51a:	f1 23       	jnz	$-28     	;abs 0xd4fe
          (firstByte == JOIN_REPLY_LEGACY_MSG_LENGTH)
         )
      {
        /* join reply returns link token */
        memcpy(&linkToken, msg+JR_LINK_TOKEN_OS, sizeof(linkToken));
    d51c:	91 41 0a 00 	mov	10(r1),	4(r1)	;0x000a(r1), 0x0004(r1)
    d520:	04 00 
    d522:	91 41 0c 00 	mov	12(r1),	6(r1)	;0x000c(r1), 0x0006(r1)
    d526:	06 00 

        nwk_setLinkToken(linkToken);
    d528:	1e 41 04 00 	mov	4(r1),	r14	;0x0004(r1)
    d52c:	1f 41 06 00 	mov	6(r1),	r15	;0x0006(r1)
    d530:	b0 12 10 d8 	call	#0xd810	
        /* save AP address */
        nwk_setAPAddress(&apAddr);
    d534:	0f 41       	mov	r1,	r15	
    d536:	b0 12 94 dd 	call	#0xdd94	
        sTid++;   /* guard against duplicates */
    d53a:	d2 53 56 02 	inc.b	&0x0256	
        rc = SMPL_SUCCESS;
    d53e:	0f 43       	clr	r15		
    d540:	e0 3f       	jmp	$-62     	;abs 0xd502
    ioctl_info.recv.port = SMPL_PORT_JOIN;
    ioctl_info.recv.msg  = msg;
    ioctl_info.recv.addr = &apAddr;    /* save AP address from reply */

    NWK_CHECK_FOR_SETRX(radioState);
    NWK_REPLY_DELAY();
    d542:	b0 12 10 c4 	call	#0xc410	
    d546:	d2 3f       	jmp	$-90     	;abs 0xd4ec

    ioctl_info.recv.port = SMPL_PORT_JOIN;
    ioctl_info.recv.msg  = msg;
    ioctl_info.recv.addr = &apAddr;    /* save AP address from reply */

    NWK_CHECK_FOR_SETRX(radioState);
    d548:	b0 12 a2 c6 	call	#0xc6a2	
    d54c:	b0 12 ba c5 	call	#0xc5ba	
    NWK_REPLY_DELAY();
    d550:	b0 12 10 c4 	call	#0xc410	
    NWK_CHECK_FOR_RESTORE_STATE(radioState);
    d554:	b0 12 da c5 	call	#0xc5da	
    d558:	c9 3f       	jmp	$-108    	;abs 0xd4ec

0000d55a <nwk_processJoin>:
  uint8_t    replyType;

  /* Make sure this is a reply and see if we sent this. Validate the
   * packet for reception by client app.
   */
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, JB_REQ_OS, JB_TID_OS)))
    d55a:	5e 42 56 02 	mov.b	&0x0256,r14	
    d55e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    d560:	4d 43       	clr.b	r13		
    d562:	b0 12 1a d3 	call	#0xd31a	
    d566:	4f 93       	tst.b	r15		
    d568:	02 24       	jz	$+6      	;abs 0xd56e
 *
 * @return   Keep frame for application, release frame, or replay frame.
 */
fhStatus_t nwk_processJoin(mrfiPacket_t *frame)
{
  fhStatus_t rc = FHS_RELEASE;
    d56a:	0f 43       	clr	r15		
#endif /* not END_DEVICE */

  (void) replyType;  /* keep compiler happy */

  return rc;
}
    d56c:	30 41       	ret			
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, JB_REQ_OS, JB_TID_OS)))
  {
    /* It's a match and it's a reply. Validate the received packet by
     * returning a 1 so it can be received by the client app.
     */
    MRFI_PostKillSem();
    d56e:	b0 12 8e c4 	call	#0xc48e	
    rc = FHS_KEEP;
    d572:	1f 43       	mov	#1,	r15	;r3 As==01
    d574:	30 41       	ret			

0000d576 <nwk_frameInit>:
    sMyTxType = F_TX_DEVICE_AP;
  #else
    sMyTxType = F_TX_DEVICE_RE;
  #endif
#else
    sMyTxType = F_TX_DEVICE_ED;
    d576:	c2 43 5e 02 	mov.b	#0,	&0x025e	;r3 As==00
  #endif
#endif
/****** DONE fill static values for the DEVICEINFO byte that will go in each frame ******/

#if !defined(RX_POLLS)
  spCallback = pF;
    d57a:	82 4f 60 02 	mov	r15,	&0x0260	
#else
  (void) pF;
#endif

  sMyAddr = nwk_getMyAddress();
    d57e:	b0 12 56 dd 	call	#0xdd56	
    d582:	82 4f 62 02 	mov	r15,	&0x0262	

  while (!(sTRACTID=MRFI_RandomByte())) ;
    d586:	b0 12 30 c3 	call	#0xc330	
    d58a:	c2 4f 64 02 	mov.b	r15,	&0x0264	
    d58e:	4f 93       	tst.b	r15		
    d590:	fa 27       	jz	$-10     	;abs 0xd586

  return;
}
    d592:	30 41       	ret			

0000d594 <nwk_buildFrame>:
 *
 * @return   pointer to frameInfo_t structure created. NULL if there is
 *           no room in output queue.
 */
frameInfo_t *nwk_buildFrame(uint8_t port, uint8_t *msg, uint8_t len, uint8_t hops)
{
    d594:	0b 12       	push	r11		
    d596:	0a 12       	push	r10		
    d598:	09 12       	push	r9		
    d59a:	08 12       	push	r8		
    d59c:	07 12       	push	r7		
    d59e:	06 12       	push	r6		
    d5a0:	46 4f       	mov.b	r15,	r6	
    d5a2:	08 4e       	mov	r14,	r8	
    d5a4:	49 4d       	mov.b	r13,	r9	
    d5a6:	47 4c       	mov.b	r12,	r7	
  frameInfo_t  *fInfoPtr;

  if (!(fInfoPtr=nwk_QfindSlot(OUTQ)))
    d5a8:	6f 43       	mov.b	#2,	r15	;r3 As==10
    d5aa:	b0 12 36 e0 	call	#0xe036	
    d5ae:	0b 4f       	mov	r15,	r11	
    d5b0:	0f 93       	tst	r15		
    d5b2:	32 24       	jz	$+102    	;abs 0xd618
  {
    return (frameInfo_t *)NULL;
  }

  MRFI_SET_PAYLOAD_LEN(&fInfoPtr->mrfiPkt, len+F_APP_PAYLOAD_OS);
    d5b4:	4f 49       	mov.b	r9,	r15	
    d5b6:	7f 50 0b 00 	add.b	#11,	r15	;#0x000b
    d5ba:	cb 4f 02 00 	mov.b	r15,	2(r11)	;0x0002(r11)

  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_ENCRYPT_OS, 0);
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_PORT_OS, port);
    d5be:	5a 4b 0b 00 	mov.b	11(r11),r10	;0x000b(r11)
    d5c2:	7a f0 80 ff 	and.b	#-128,	r10	;#0xff80
    d5c6:	4a d6       	bis.b	r6,	r10	
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_TRACTID_OS, sTRACTID);
    d5c8:	5f 42 64 02 	mov.b	&0x0264,r15	
    d5cc:	cb 4f 0d 00 	mov.b	r15,	13(r11)	;0x000d(r11)
  while (!(++sTRACTID)) ;  /* transaction ID can't be 0 */
    d5d0:	01 3c       	jmp	$+4      	;abs 0xd5d4
    d5d2:	4f 43       	clr.b	r15		
    d5d4:	5f 53       	inc.b	r15		
    d5d6:	fd 27       	jz	$-4      	;abs 0xd5d2
    d5d8:	c2 4f 64 02 	mov.b	r15,	&0x0264	
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_RX_TYPE, sMyRxType);
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_HOP_COUNT, hops);
    d5dc:	5f 4b 0c 00 	mov.b	12(r11),r15	;0x000c(r11)
    d5e0:	7f f0 b8 ff 	and.b	#-72,	r15	;#0xffb8
    d5e4:	4f d7       	bis.b	r7,	r15	

  /* reset ack-relevant bits */
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_ACK_REQ, 0);
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_ACK_RPLY, 0);
    d5e6:	7f f0 77 00 	and.b	#119,	r15	;#0x0077
    d5ea:	cb 4f 0c 00 	mov.b	r15,	12(r11)	;0x000c(r11)

  /* reset forwarding bit */
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt), F_FWD_FRAME, 0);
    d5ee:	7a f0 7f 00 	and.b	#127,	r10	;#0x007f
    d5f2:	cb 4a 0b 00 	mov.b	r10,	11(r11)	;0x000b(r11)

  memcpy(MRFI_P_PAYLOAD(&fInfoPtr->mrfiPkt)+F_APP_PAYLOAD_OS, msg, len);
    d5f6:	4d 49       	mov.b	r9,	r13	
    d5f8:	0e 48       	mov	r8,	r14	
    d5fa:	0f 4b       	mov	r11,	r15	
    d5fc:	3f 50 0e 00 	add	#14,	r15	;#0x000e
    d600:	b0 12 28 e2 	call	#0xe228	
  memcpy(MRFI_P_SRC_ADDR(&fInfoPtr->mrfiPkt), sMyAddr, NET_ADDR_SIZE);
    d604:	1f 42 62 02 	mov	&0x0262,r15	
    d608:	fb 4f 07 00 	mov.b	@r15+,	7(r11)	;0x0007(r11)
    d60c:	fb 4f 08 00 	mov.b	@r15+,	8(r11)	;0x0008(r11)
    d610:	fb 4f 09 00 	mov.b	@r15+,	9(r11)	;0x0009(r11)
    d614:	eb 4f 0a 00 	mov.b	@r15,	10(r11)	;0x000a(r11)

  return fInfoPtr;
}
    d618:	0f 4b       	mov	r11,	r15	
    d61a:	36 41       	pop	r6		
    d61c:	37 41       	pop	r7		
    d61e:	38 41       	pop	r8		
    d620:	39 41       	pop	r9		
    d622:	3a 41       	pop	r10		
    d624:	3b 41       	pop	r11		
    d626:	30 41       	ret			

0000d628 <MRFI_RxCompleteISR>:
 * output parameters
 *
 * @return      void
 */
void MRFI_RxCompleteISR()
{
    d628:	0b 12       	push	r11		
    d62a:	0a 12       	push	r10		
    d62c:	09 12       	push	r9		
    d62e:	21 83       	decd	r1		
  frameInfo_t  *fInfoPtr;

  /* room for more? */
  if ((fInfoPtr=nwk_QfindSlot(INQ)))
    d630:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d632:	b0 12 36 e0 	call	#0xe036	
    d636:	0b 4f       	mov	r15,	r11	
    d638:	0f 93       	tst	r15		
    d63a:	31 24       	jz	$+100    	;abs 0xd69e
  {
    MRFI_Receive(&fInfoPtr->mrfiPkt);
    d63c:	0a 4f       	mov	r15,	r10	
    d63e:	2a 53       	incd	r10		
    d640:	0f 4a       	mov	r10,	r15	
    d642:	b0 12 e6 c2 	call	#0xc2e6	
 *
 * @return   void
 */
static void dispatchFrame(frameInfo_t *fiPtr)
{
  uint8_t     port       = GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_PORT_OS);
    d646:	59 4b 0b 00 	mov.b	11(r11),r9	;0x000b(r11)
#if !defined(END_DEVICE)
  uint8_t isForMe;
#endif

  /* be sure it's not an echo... */
  if (!memcmp(MRFI_P_SRC_ADDR(&fiPtr->mrfiPkt), sMyAddr, NET_ADDR_SIZE))
    d64a:	2d 42       	mov	#4,	r13	;r2 As==10
    d64c:	1e 42 62 02 	mov	&0x0262,r14	
    d650:	0f 4b       	mov	r11,	r15	
    d652:	3f 50 07 00 	add	#7,	r15	;#0x0007
    d656:	b0 12 08 e2 	call	#0xe208	
    d65a:	0f 93       	tst	r15		
    d65c:	1e 24       	jz	$+62     	;abs 0xd69a
    /* Encyrption bit is not on when when it should be */
    fiPtr->fi_usage = FI_AVAILABLE;
    return;
  }
#else
  if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_ENCRYPT_OS))
    d65e:	39 b0 40 00 	bit	#64,	r9	;#0x0040
    d662:	1b 20       	jnz	$+56     	;abs 0xd69a
 *
 * @return   void
 */
static void dispatchFrame(frameInfo_t *fiPtr)
{
  uint8_t     port       = GET_FROM_FRAME(MRFI_P_PAYLOAD(&fiPtr->mrfiPkt), F_PORT_OS);
    d664:	79 f0 3f 00 	and.b	#63,	r9	;#0x003f
#endif  /* SMPL_SECURE */

  /* If it's a network application port dispatch to service routine. Dispose
   * of frame depending on return code.
   */
  if (port && (port <= nwkAppSize))
    d668:	18 24       	jz	$+50     	;abs 0xd69a
    d66a:	79 90 07 00 	cmp.b	#7,	r9	;#0x0007
    d66e:	1c 28       	jnc	$+58     	;abs 0xd6a8
      fiPtr->fi_usage = FI_AVAILABLE;
    }
    return;
  }
  /* sanity check */
  else if ((port != SMPL_PORT_USER_BCAST) && ((port < PORT_BASE_NUMBER) || (port > SMPL_PORT_STATIC_MAX)))
    d670:	79 50 e0 ff 	add.b	#-32,	r9	;#0xffe0
    d674:	79 90 20 00 	cmp.b	#32,	r9	;#0x0020
    d678:	10 2c       	jc	$+34     	;abs 0xd69a
  {
    fiPtr->fi_usage = FI_AVAILABLE;
  }
#else
  /* it's destined for a user app. */
  if (nwk_isConnectionValid(&fiPtr->mrfiPkt, &lid))
    d67a:	0e 41       	mov	r1,	r14	
    d67c:	0f 4a       	mov	r10,	r15	
    d67e:	b0 12 e0 d1 	call	#0xd1e0	
    d682:	4f 93       	tst.b	r15		
    d684:	0a 24       	jz	$+22     	;abs 0xd69a
  {
    fiPtr->fi_usage = FI_INUSE_UNTIL_DEL;
    d686:	db 43 00 00 	mov.b	#1,	0(r11)	;r3 As==01, 0x0000(r11)
    if (spCallback && spCallback(lid))
    d68a:	1e 42 60 02 	mov	&0x0260,r14	
    d68e:	0e 93       	tst	r14		
    d690:	06 24       	jz	$+14     	;abs 0xd69e
    d692:	6f 41       	mov.b	@r1,	r15	
    d694:	8e 12       	call	r14		
    d696:	4f 93       	tst.b	r15		
    d698:	02 24       	jz	$+6      	;abs 0xd69e
      return;
    }
  }
  else
  {
    fiPtr->fi_usage = FI_AVAILABLE;
    d69a:	cb 43 00 00 	mov.b	#0,	0(r11)	;r3 As==00, 0x0000(r11)

    dispatchFrame(fInfoPtr);
  }

  return;
}
    d69e:	21 53       	incd	r1		
    d6a0:	39 41       	pop	r9		
    d6a2:	3a 41       	pop	r10		
    d6a4:	3b 41       	pop	r11		
    d6a6:	30 41       	ret			
    {
      fiPtr->fi_usage = FI_AVAILABLE;
      return;
    }
#endif
    rc = func[port-1](&fiPtr->mrfiPkt);
    d6a8:	49 49       	mov.b	r9,	r9	
    d6aa:	39 53       	add	#-1,	r9	;r3 As==11
    d6ac:	09 59       	rla	r9		
    d6ae:	0f 4a       	mov	r10,	r15	
    d6b0:	99 12 e8 e4 	call	-6936(r9)	;0xe4e8(r9)
    if (FHS_KEEP == rc)
    d6b4:	1f 93       	cmp	#1,	r15	;r3 As==01
    d6b6:	f1 23       	jnz	$-28     	;abs 0xd69a
    {
      fiPtr->fi_usage = FI_INUSE_UNTIL_DEL;
    d6b8:	db 43 00 00 	mov.b	#1,	0(r11)	;r3 As==01, 0x0000(r11)
    d6bc:	f0 3f       	jmp	$-30     	;abs 0xd69e

0000d6be <nwk_retrieveFrame>:
 *            SMPL_NO_FRAME  - no frame found for specified destination
 *            SMPL_BAD_PARAM - no valid connection info for the Link ID
 *
 */
smplStatus_t nwk_retrieveFrame(rcvContext_t *rcv, uint8_t *msg, uint8_t *len, addr_t *srcAddr, uint8_t *hopCount)
{
    d6be:	0b 12       	push	r11		
    d6c0:	0a 12       	push	r10		
    d6c2:	09 12       	push	r9		
    d6c4:	08 12       	push	r8		
    d6c6:	07 12       	push	r7		
    d6c8:	06 12       	push	r6		
    d6ca:	09 4f       	mov	r15,	r9	
    d6cc:	07 4e       	mov	r14,	r7	
    d6ce:	0a 4d       	mov	r13,	r10	
    d6d0:	08 4c       	mov	r12,	r8	
    d6d2:	16 41 0e 00 	mov	14(r1),	r6	;0x000e(r1)
  frameInfo_t *fPtr;
  uint8_t      done;

  do {
    /* look for a frame on requested port. */
    *len = 0;
    d6d6:	cd 43 00 00 	mov.b	#0,	0(r13)	;r3 As==00, 0x0000(r13)
    done = 1;

    fPtr = nwk_QfindOldest(INQ, rcv, USAGE_NORMAL);
    d6da:	5d 43       	mov.b	#1,	r13	;r3 As==01
    d6dc:	0e 4f       	mov	r15,	r14	
    d6de:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d6e0:	b0 12 c6 e0 	call	#0xe0c6	
    d6e4:	0b 4f       	mov	r15,	r11	
    if (fPtr)
    d6e6:	0f 93       	tst	r15		
    d6e8:	38 24       	jz	$+114    	;abs 0xd75a
    {
      connInfo_t  *pCInfo = 0;

      if (RCV_APP_LID == rcv->type)
    d6ea:	99 93 00 00 	cmp	#1,	0(r9)	;r3 As==01, 0x0000(r9)
    d6ee:	3d 24       	jz	$+124    	;abs 0xd76a
        }
#endif  /* SMPL_SECURE */
      }

      /* it's on the requested port. */
      *len = MRFI_GET_PAYLOAD_LEN(&fPtr->mrfiPkt) - F_APP_PAYLOAD_OS;
    d6f0:	5d 4f 02 00 	mov.b	2(r15),	r13	;0x0002(r15)
    d6f4:	7d 50 f5 ff 	add.b	#-11,	r13	;#0xfff5
    d6f8:	ca 4d 00 00 	mov.b	r13,	0(r10)	;0x0000(r10)
      memcpy(msg, MRFI_P_PAYLOAD(&fPtr->mrfiPkt)+F_APP_PAYLOAD_OS, *len);
    d6fc:	4d 4d       	mov.b	r13,	r13	
    d6fe:	0e 4f       	mov	r15,	r14	
    d700:	3e 50 0e 00 	add	#14,	r14	;#0x000e
    d704:	0f 47       	mov	r7,	r15	
    d706:	b0 12 28 e2 	call	#0xe228	
      {
        /* Save Rx metrics... */
        pCInfo->sigInfo.rssi = fPtr->mrfiPkt.rxMetrics[MRFI_RX_METRICS_RSSI_OFS];
        pCInfo->sigInfo.lqi  = fPtr->mrfiPkt.rxMetrics[MRFI_RX_METRICS_CRC_LQI_OFS];
      }
      if (srcAddr)
    d70a:	08 93       	tst	r8		
    d70c:	0f 24       	jz	$+32     	;abs 0xd72c
      {
        /* copy source address if requested */
        memcpy(srcAddr, MRFI_P_SRC_ADDR(&fPtr->mrfiPkt), NET_ADDR_SIZE);
    d70e:	d8 4b 07 00 	mov.b	7(r11),	0(r8)	;0x0007(r11), 0x0000(r8)
    d712:	00 00 
    d714:	0c 48       	mov	r8,	r12	
    d716:	1c 53       	inc	r12		
    d718:	dc 4b 08 00 	mov.b	8(r11),	0(r12)	;0x0008(r11), 0x0000(r12)
    d71c:	00 00 
    d71e:	1c 53       	inc	r12		
    d720:	dc 4b 09 00 	mov.b	9(r11),	0(r12)	;0x0009(r11), 0x0000(r12)
    d724:	00 00 
    d726:	dc 4b 0a 00 	mov.b	10(r11),1(r12)	;0x000a(r11), 0x0001(r12)
    d72a:	01 00 
      }
      if (hopCount)
    d72c:	06 93       	tst	r6		
    d72e:	06 24       	jz	$+14     	;abs 0xd73c
      {
        /* copy hop count if requested */
        *hopCount = GET_FROM_FRAME(MRFI_P_PAYLOAD(&fPtr->mrfiPkt), F_HOP_COUNT);
    d730:	5f 4b 0c 00 	mov.b	12(r11),r15	;0x000c(r11)
    d734:	7f f0 07 00 	and.b	#7,	r15	;#0x0007
    d738:	c6 4f 00 00 	mov.b	r15,	0(r6)	;0x0000(r6)
      }
      /* input frame no longer needed. free it. */
      nwk_QadjustOrder(INQ, fPtr->orderStamp);
    d73c:	5e 4b 01 00 	mov.b	1(r11),	r14	;0x0001(r11)
    d740:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d742:	b0 12 ee df 	call	#0xdfee	

      fPtr->fi_usage = FI_AVAILABLE;
    d746:	cb 43 00 00 	mov.b	#0,	0(r11)	;r3 As==00, 0x0000(r11)
      return SMPL_SUCCESS;
    d74a:	0f 43       	clr	r15		
    }
  } while (!done);

  return SMPL_NO_FRAME;
}
    d74c:	36 41       	pop	r6		
    d74e:	37 41       	pop	r7		
    d750:	38 41       	pop	r8		
    d752:	39 41       	pop	r9		
    d754:	3a 41       	pop	r10		
    d756:	3b 41       	pop	r11		
    d758:	30 41       	ret			
      fPtr->fi_usage = FI_AVAILABLE;
      return SMPL_SUCCESS;
    }
  } while (!done);

  return SMPL_NO_FRAME;
    d75a:	2f 42       	mov	#4,	r15	;r2 As==10
}
    d75c:	36 41       	pop	r6		
    d75e:	37 41       	pop	r7		
    d760:	38 41       	pop	r8		
    d762:	39 41       	pop	r9		
    d764:	3a 41       	pop	r10		
    d766:	3b 41       	pop	r11		
    d768:	30 41       	ret			
    {
      connInfo_t  *pCInfo = 0;

      if (RCV_APP_LID == rcv->type)
      {
        pCInfo = nwk_getConnInfo(rcv->t.lid);
    d76a:	5f 49 02 00 	mov.b	2(r9),	r15	;0x0002(r9)
    d76e:	b0 12 e0 d0 	call	#0xd0e0	
    d772:	09 4f       	mov	r15,	r9	
        if (!pCInfo)
    d774:	0f 93       	tst	r15		
    d776:	14 24       	jz	$+42     	;abs 0xd7a0
        }
#endif  /* SMPL_SECURE */
      }

      /* it's on the requested port. */
      *len = MRFI_GET_PAYLOAD_LEN(&fPtr->mrfiPkt) - F_APP_PAYLOAD_OS;
    d778:	5d 4b 02 00 	mov.b	2(r11),	r13	;0x0002(r11)
    d77c:	7d 50 f5 ff 	add.b	#-11,	r13	;#0xfff5
    d780:	ca 4d 00 00 	mov.b	r13,	0(r10)	;0x0000(r10)
      memcpy(msg, MRFI_P_PAYLOAD(&fPtr->mrfiPkt)+F_APP_PAYLOAD_OS, *len);
    d784:	4d 4d       	mov.b	r13,	r13	
    d786:	0e 4b       	mov	r11,	r14	
    d788:	3e 50 0e 00 	add	#14,	r14	;#0x000e
    d78c:	0f 47       	mov	r7,	r15	
    d78e:	b0 12 28 e2 	call	#0xe228	
      /* save signal info */
      if (pCInfo)
      {
        /* Save Rx metrics... */
        pCInfo->sigInfo.rssi = fPtr->mrfiPkt.rxMetrics[MRFI_RX_METRICS_RSSI_OFS];
    d792:	d9 4b 18 00 	mov.b	24(r11),6(r9)	;0x0018(r11), 0x0006(r9)
    d796:	06 00 
        pCInfo->sigInfo.lqi  = fPtr->mrfiPkt.rxMetrics[MRFI_RX_METRICS_CRC_LQI_OFS];
    d798:	d9 4b 19 00 	mov.b	25(r11),7(r9)	;0x0019(r11), 0x0007(r9)
    d79c:	07 00 
    d79e:	b5 3f       	jmp	$-148    	;abs 0xd70a
      if (RCV_APP_LID == rcv->type)
      {
        pCInfo = nwk_getConnInfo(rcv->t.lid);
        if (!pCInfo)
        {
          return SMPL_BAD_PARAM;
    d7a0:	2f 43       	mov	#2,	r15	;r3 As==10
    d7a2:	d4 3f       	jmp	$-86     	;abs 0xd74c

0000d7a4 <nwk_sendFrame>:
 * @return    SMPL_SUCCESS
 *            SMPL_TX_CCA_FAIL Tx failed because of CCA failure.
 *                             Tx FIFO flushed in this case.
 */
smplStatus_t nwk_sendFrame(frameInfo_t *pFrameInfo, uint8_t txOption)
{
    d7a4:	0b 12       	push	r11		
    d7a6:	0b 4f       	mov	r15,	r11	
  smplStatus_t rc;

  /* set the type of device sending the frame in the header */
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&pFrameInfo->mrfiPkt), F_TX_DEVICE, sMyTxType);
    d7a8:	5f 4f 0c 00 	mov.b	12(r15),r15	;0x000c(r15)
    d7ac:	7f f0 cf ff 	and.b	#-49,	r15	;#0xffcf
    d7b0:	5f d2 5e 02 	bis.b	&0x025e,r15	
    d7b4:	cb 4f 0c 00 	mov.b	r15,	12(r11)	;0x000c(r11)

  if (MRFI_TX_RESULT_SUCCESS == MRFI_Transmit(&pFrameInfo->mrfiPkt, txOption))
    d7b8:	0f 4b       	mov	r11,	r15	
    d7ba:	2f 53       	incd	r15		
    d7bc:	b0 12 28 c7 	call	#0xc728	
    d7c0:	4f 93       	tst.b	r15		
    d7c2:	06 24       	jz	$+14     	;abs 0xd7d0
  else
  {
    /* Tx failed -- probably CCA. free up frame buffer. We do not have NWK
     * level retries. Let application do it.
     */
    rc = SMPL_TX_CCA_FAIL;
    d7c4:	3f 40 09 00 	mov	#9,	r15	;#0x0009
  }

  /* TX is done. free up the frame buffer */
  pFrameInfo->fi_usage = FI_AVAILABLE;
    d7c8:	cb 43 00 00 	mov.b	#0,	0(r11)	;r3 As==00, 0x0000(r11)

  return rc;
}
    d7cc:	3b 41       	pop	r11		
    d7ce:	30 41       	ret			
  /* set the type of device sending the frame in the header */
  PUT_INTO_FRAME(MRFI_P_PAYLOAD(&pFrameInfo->mrfiPkt), F_TX_DEVICE, sMyTxType);

  if (MRFI_TX_RESULT_SUCCESS == MRFI_Transmit(&pFrameInfo->mrfiPkt, txOption))
  {
    rc = SMPL_SUCCESS;
    d7d0:	0f 43       	clr	r15		
     */
    rc = SMPL_TX_CCA_FAIL;
  }

  /* TX is done. free up the frame buffer */
  pFrameInfo->fi_usage = FI_AVAILABLE;
    d7d2:	cb 43 00 00 	mov.b	#0,	0(r11)	;r3 As==00, 0x0000(r11)

  return rc;
}
    d7d6:	3b 41       	pop	r11		
    d7d8:	30 41       	ret			

0000d7da <nwk_getMyRxType>:
 * @return      The address LSB.
 */
uint8_t nwk_getMyRxType(void)
{
  return sMyRxType;
}
    d7da:	4f 43       	clr.b	r15		
    d7dc:	30 41       	ret			

0000d7de <nwk_linkInit>:
 *
 * @return   void
 */
void nwk_linkInit(void)
{
  if (!sLinkToken)
    d7de:	82 93 6c 02 	tst	&0x026c	
    d7e2:	09 20       	jnz	$+20     	;abs 0xd7f6
    d7e4:	82 93 6e 02 	tst	&0x026e	
    d7e8:	06 20       	jnz	$+14     	;abs 0xd7f6
  {
    /* if the link token has not been set externally by the time we get here
     * (such as by the ioctl token-setting interface) assign the default
     */
    sLinkToken = DEFAULT_LINK_TOKEN;
    d7ea:	b2 40 04 03 	mov	#772,	&0x026c	;#0x0304
    d7ee:	6c 02 
    d7f0:	b2 40 02 01 	mov	#258,	&0x026e	;#0x0102
    d7f4:	6e 02 
  }

  /* set a non-zero TID. */
  while (!(sTid = MRFI_RandomByte()))  ;
    d7f6:	b0 12 30 c3 	call	#0xc330	
    d7fa:	c2 4f 66 02 	mov.b	r15,	&0x0266	
    d7fe:	4f 93       	tst.b	r15		
    d800:	fa 27       	jz	$-10     	;abs 0xd7f6

#if NUM_CONNECTIONS > 0
  memset((void *)&sServiceLinkID, 0x0, sizeof(sServiceLinkID));
    d802:	c2 43 68 02 	mov.b	#0,	&0x0268	;r3 As==00
    d806:	3f 40 68 02 	mov	#616,	r15	;#0x0268
    d80a:	cf 43 01 00 	mov.b	#0,	1(r15)	;r3 As==00, 0x0001(r15)
#endif

  return;
}
    d80e:	30 41       	ret			

0000d810 <nwk_setLinkToken>:
 * @return   void
 */
void nwk_setLinkToken(uint32_t token)
{
  /* only set if the supplied token is non-zero. */
  if (token)
    d810:	0e 93       	tst	r14		
    d812:	03 20       	jnz	$+8      	;abs 0xd81a
    d814:	0f 93       	tst	r15		
    d816:	01 20       	jnz	$+4      	;abs 0xd81a
    d818:	30 41       	ret			
  {
    sLinkToken = token;
    d81a:	82 4e 6c 02 	mov	r14,	&0x026c	
    d81e:	82 4f 6e 02 	mov	r15,	&0x026e	
    d822:	30 41       	ret			

0000d824 <nwk_getLinkToken>:
 * @return   Current link token
 */
void nwk_getLinkToken(uint32_t *pToken)
{
  /* only set if the supplied token is non-zero. */
  if (pToken)
    d824:	0f 93       	tst	r15		
    d826:	06 24       	jz	$+14     	;abs 0xd834
  {
    *pToken = sLinkToken;
    d828:	9f 42 6c 02 	mov	&0x026c,0(r15)	;0x0000(r15)
    d82c:	00 00 
    d82e:	9f 42 6e 02 	mov	&0x026e,2(r15)	;0x0002(r15)
    d832:	02 00 
    d834:	30 41       	ret			

0000d836 <nwk_link>:
 * @param   lid     - pointer to Link ID (port) assigned for this link
 *
 * @return   Status of the operation.
 */
smplStatus_t nwk_link(linkID_t *lid)
{
    d836:	0b 12       	push	r11		
    d838:	0a 12       	push	r10		
    d83a:	09 12       	push	r9		
    d83c:	31 50 ea ff 	add	#-22,	r1	;#0xffea
    d840:	09 4f       	mov	r15,	r9	
  uint8_t       msg[LINK_FRAME_SIZE];
  connInfo_t   *pCInfo = nwk_getNextConnection();
    d842:	b0 12 5e d0 	call	#0xd05e	
    d846:	0b 4f       	mov	r15,	r11	
  smplStatus_t  rc;

  if (pCInfo)
    d848:	0f 93       	tst	r15		
    d84a:	12 24       	jz	$+38     	;abs 0xd870
    {
      ioctlRawSend_t    send;
      ioctlRawReceive_t recv;
    } ioctl_info;

    if (!nwk_allocateLocalRxPort(LINK_SEND, pCInfo))
    d84c:	0e 4f       	mov	r15,	r14	
    d84e:	5f 43       	mov.b	#1,	r15	;r3 As==01
    d850:	b0 12 42 d2 	call	#0xd242	
    d854:	4f 93       	tst.b	r15		
    d856:	15 20       	jnz	$+44     	;abs 0xd882
    {
      nwk_freeConnection(pCInfo);
    d858:	0f 4b       	mov	r11,	r15	
    d85a:	b0 12 da d0 	call	#0xd0da	
      return SMPL_NOMEM;
    d85e:	3a 40 03 00 	mov	#3,	r10	;#0x0003
    }
    return SMPL_SUCCESS;
  }

  return SMPL_NOMEM;
}
    d862:	0f 4a       	mov	r10,	r15	
    d864:	31 50 16 00 	add	#22,	r1	;#0x0016
    d868:	39 41       	pop	r9		
    d86a:	3a 41       	pop	r10		
    d86c:	3b 41       	pop	r11		
    d86e:	30 41       	ret			
      sTid = 1;
    }
    return SMPL_SUCCESS;
  }

  return SMPL_NOMEM;
    d870:	3a 40 03 00 	mov	#3,	r10	;#0x0003
}
    d874:	0f 4a       	mov	r10,	r15	
    d876:	31 50 16 00 	add	#22,	r1	;#0x0016
    d87a:	39 41       	pop	r9		
    d87c:	3a 41       	pop	r10		
    d87e:	3b 41       	pop	r11		
    d880:	30 41       	ret			
    {
      nwk_freeConnection(pCInfo);
      return SMPL_NOMEM;
    }

    memcpy(addr.addr, nwk_getBCastAddress(), NET_ADDR_SIZE);
    d882:	b0 12 d6 dd 	call	#0xddd6	
    d886:	0e 4f       	mov	r15,	r14	
    d888:	f1 4e 00 00 	mov.b	@r14+,	0(r1)	;0x0000(r1)
    d88c:	0d 41       	mov	r1,	r13	
    d88e:	1d 53       	inc	r13		
    d890:	fd 4e 00 00 	mov.b	@r14+,	0(r13)	;0x0000(r13)
    d894:	1d 53       	inc	r13		
    d896:	fd 4e 00 00 	mov.b	@r14+,	0(r13)	;0x0000(r13)
    d89a:	ed 4e 01 00 	mov.b	@r14,	1(r13)	;0x0001(r13)
    ioctl_info.send.addr = &addr;
    d89e:	81 41 04 00 	mov	r1,	4(r1)	;0x0004(r1)
    ioctl_info.send.msg  = msg;
    d8a2:	0e 41       	mov	r1,	r14	
    d8a4:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    d8a8:	81 4e 06 00 	mov	r14,	6(r1)	;0x0006(r1)
    ioctl_info.send.len  = sizeof(msg);
    d8ac:	f1 40 09 00 	mov.b	#9,	8(r1)	;#0x0009, 0x0008(r1)
    d8b0:	08 00 
    ioctl_info.send.port = SMPL_PORT_LINK;
    d8b2:	e1 43 09 00 	mov.b	#2,	9(r1)	;r3 As==10, 0x0009(r1)

    /* Put link token in */
    nwk_putNumObjectIntoMsg((void *)&sLinkToken, msg+L_LINK_TOKEN_OS, sizeof(sLinkToken));
    d8b6:	6d 42       	mov.b	#4,	r13	;r2 As==10
    d8b8:	2e 53       	incd	r14		
    d8ba:	3f 40 6c 02 	mov	#620,	r15	;#0x026c
    d8be:	b0 12 dc d3 	call	#0xd3dc	

    /* set port to which the remote device should send */
    msg[L_RMT_PORT_OS] = pCInfo->portRx;
    d8c2:	d1 4b 08 00 	mov.b	8(r11),	18(r1)	;0x0008(r11), 0x0012(r1)
    d8c6:	12 00 

    /* set the transaction ID. this allows target to figure out duplicates */
    msg[LB_TID_OS] = sTid;
    d8c8:	d1 42 66 02 	mov.b	&0x0266,13(r1)	;0x000d(r1)
    d8cc:	0d 00 

    /* set my Rx type */
    msg[L_MY_RXTYPE_OS] = nwk_getMyRxType();
    d8ce:	b0 12 da d7 	call	#0xd7da	
    d8d2:	c1 4f 13 00 	mov.b	r15,	19(r1)	;0x0013(r1)

    /* set request byte */
    msg[LB_REQ_OS] = LINK_REQ_LINK;
    d8d6:	d1 43 0c 00 	mov.b	#1,	12(r1)	;r3 As==01, 0x000c(r1)

    /* protocol version number */
    msg[L_PROTOCOL_VERSION_OS] = nwk_getProtocolVersion();
    d8da:	b0 12 6e dd 	call	#0xdd6e	
    d8de:	c1 4f 14 00 	mov.b	r15,	20(r1)	;0x0014(r1)

    nwk_putNumObjectIntoMsg((void *)&pCInfo->connTxCTR, (void *)&msg[L_CTR_OS], 4);
#endif


    if (SMPL_SUCCESS != (rc=SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_WRITE, &ioctl_info.send)))
    d8e2:	0d 41       	mov	r1,	r13	
    d8e4:	2d 52       	add	#4,	r13	;r2 As==10
    d8e6:	3e 40 03 00 	mov	#3,	r14	;#0x0003
    d8ea:	2f 43       	mov	#2,	r15	;r3 As==10
    d8ec:	b0 12 2c cf 	call	#0xcf2c	
    d8f0:	0a 4f       	mov	r15,	r10	
    d8f2:	0f 93       	tst	r15		
    d8f4:	2f 20       	jnz	$+96     	;abs 0xd954
      nwk_freeConnection(pCInfo);
      return rc;
    }

    {
      uint8_t radioState = MRFI_GetRadioState();
    d8f6:	b0 12 9c c4 	call	#0xc49c	

      ioctl_info.recv.port = SMPL_PORT_LINK;
    d8fa:	e1 43 09 00 	mov.b	#2,	9(r1)	;r3 As==10, 0x0009(r1)
      ioctl_info.recv.msg  = msg;
    d8fe:	0e 41       	mov	r1,	r14	
    d900:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    d904:	81 4e 06 00 	mov	r14,	6(r1)	;0x0006(r1)
      ioctl_info.recv.addr = (addr_t *)pCInfo->peerAddr;
    d908:	0e 4b       	mov	r11,	r14	
    d90a:	2e 53       	incd	r14		
    d90c:	81 4e 04 00 	mov	r14,	4(r1)	;0x0004(r1)

      NWK_CHECK_FOR_SETRX(radioState);
    d910:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    d914:	3b 24       	jz	$+120    	;abs 0xd98c
    d916:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    d918:	44 24       	jz	$+138    	;abs 0xd9a2
    d91a:	b0 12 ba c5 	call	#0xc5ba	
      NWK_REPLY_DELAY();
    d91e:	b0 12 10 c4 	call	#0xc410	
      NWK_CHECK_FOR_RESTORE_STATE(radioState);
    d922:	b0 12 7a c5 	call	#0xc57a	

      if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
    d926:	0d 41       	mov	r1,	r13	
    d928:	2d 52       	add	#4,	r13	;r2 As==10
    d92a:	2e 43       	mov	#2,	r14	;r3 As==10
    d92c:	2f 43       	mov	#2,	r15	;r3 As==10
    d92e:	b0 12 2c cf 	call	#0xcf2c	
    d932:	0f 93       	tst	r15		
    d934:	2e 20       	jnz	$+94     	;abs 0xd992
      {
        uint8_t firstByte = msg[LB_REQ_OS] & (~NWK_APP_REPLY_BIT);
    d936:	5f 41 0c 00 	mov.b	12(r1),	r15	;0x000c(r1)
    d93a:	7f f0 7f 00 	and.b	#127,	r15	;#0x007f

        /* Sanity check for correct reply frame. Older version
         * has the length instead of the request as the first byte.
         */
        if ((firstByte != LINK_REQ_LINK) &&
    d93e:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    d940:	0d 24       	jz	$+28     	;abs 0xd95c
    d942:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    d946:	0a 24       	jz	$+22     	;abs 0xd95c
            (firstByte != LINK_REPLY_LEGACY_MSG_LENGTH)
           )
        {
          /* invalidate connection object */
          nwk_freeConnection(pCInfo);
    d948:	0f 4b       	mov	r11,	r15	
    d94a:	b0 12 da d0 	call	#0xd0da	
          return SMPL_NO_LINK;
    d94e:	3a 40 05 00 	mov	#5,	r10	;#0x0005
    d952:	87 3f       	jmp	$-240    	;abs 0xd862
#endif


    if (SMPL_SUCCESS != (rc=SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_WRITE, &ioctl_info.send)))
    {
      nwk_freeConnection(pCInfo);
    d954:	0f 4b       	mov	r11,	r15	
    d956:	b0 12 da d0 	call	#0xd0da	
      return rc;
    d95a:	83 3f       	jmp	$-248    	;abs 0xd862
        /* no successful receive */
        nwk_freeConnection(pCInfo);
        return SMPL_TIMEOUT;
      }

      pCInfo->connState = CONNSTATE_CONNECTED;
    d95c:	eb 43 00 00 	mov.b	#2,	0(r11)	;r3 As==10, 0x0000(r11)
      pCInfo->portTx    = msg[LR_RMT_PORT_OS];    /* link reply returns remote port */
    d960:	db 41 0e 00 	mov.b	14(r1),	9(r11)	;0x000e(r1), 0x0009(r11)
    d964:	09 00 
      *lid              = pCInfo->thisLinkID;     /* return our local port number */
    d966:	d9 4b 0a 00 	mov.b	10(r11),0(r9)	;0x000a(r11), 0x0000(r9)
    d96a:	00 00 
      /* Set hop count. If it's a polling device set the count to the
       * distance to the AP. Otherwise, set it to the max less the remaining
       * which will be the path taken for this frame. It will be no worse
       * then tha max and probably will be better.
       */
      if (F_RX_TYPE_POLLS == msg[LR_MY_RXTYPE_OS])
    d96c:	f1 90 40 00 	cmp.b	#64,	15(r1)	;#0x0040, 0x000f(r1)
    d970:	0f 00 
    d972:	14 24       	jz	$+42     	;abs 0xd99c
         * was marginal.
         */
#if defined(DEVICE_DOES_NOT_MOVE)
        pCInfo->hops2target = MAX_HOPS - ioctl_info.recv.hopCount;
#else
        pCInfo->hops2target = MAX_HOPS;
    d974:	fb 40 03 00 	mov.b	#3,	1(r11)	;#0x0003, 0x0001(r11)
    d978:	01 00 
      nwk_getNumObjectFromMsg((void *)&msg[LR_CTR_OS], (void *)&pCInfo->connRxCTR, 4);
#endif
    }

    /* guard against duplicates... */
    ++sTid;
    d97a:	d2 53 66 02 	inc.b	&0x0266	
    if (!sTid)
    d97e:	5f 42 66 02 	mov.b	&0x0266,r15	
    d982:	4f 93       	tst.b	r15		
    d984:	6e 23       	jnz	$-290    	;abs 0xd862
    {
      sTid = 1;
    d986:	d2 43 66 02 	mov.b	#1,	&0x0266	;r3 As==01
    d98a:	6b 3f       	jmp	$-296    	;abs 0xd862
      ioctl_info.recv.port = SMPL_PORT_LINK;
      ioctl_info.recv.msg  = msg;
      ioctl_info.recv.addr = (addr_t *)pCInfo->peerAddr;

      NWK_CHECK_FOR_SETRX(radioState);
      NWK_REPLY_DELAY();
    d98c:	b0 12 10 c4 	call	#0xc410	
    d990:	ca 3f       	jmp	$-106    	;abs 0xd926
        }
      }
      else
      {
        /* no successful receive */
        nwk_freeConnection(pCInfo);
    d992:	0f 4b       	mov	r11,	r15	
    d994:	b0 12 da d0 	call	#0xd0da	
        return SMPL_TIMEOUT;
    d998:	1a 43       	mov	#1,	r10	;r3 As==01
    d99a:	63 3f       	jmp	$-312    	;abs 0xd862
       * which will be the path taken for this frame. It will be no worse
       * then tha max and probably will be better.
       */
      if (F_RX_TYPE_POLLS == msg[LR_MY_RXTYPE_OS])
      {
        pCInfo->hops2target = MAX_HOPS_FROM_AP;
    d99c:	db 43 01 00 	mov.b	#1,	1(r11)	;r3 As==01, 0x0001(r11)
    d9a0:	ec 3f       	jmp	$-38     	;abs 0xd97a

      ioctl_info.recv.port = SMPL_PORT_LINK;
      ioctl_info.recv.msg  = msg;
      ioctl_info.recv.addr = (addr_t *)pCInfo->peerAddr;

      NWK_CHECK_FOR_SETRX(radioState);
    d9a2:	b0 12 a2 c6 	call	#0xc6a2	
    d9a6:	b0 12 ba c5 	call	#0xc5ba	
      NWK_REPLY_DELAY();
    d9aa:	b0 12 10 c4 	call	#0xc410	
      NWK_CHECK_FOR_RESTORE_STATE(radioState);
    d9ae:	b0 12 da c5 	call	#0xc5da	
    d9b2:	b9 3f       	jmp	$-140    	;abs 0xd926

0000d9b4 <nwk_processLink>:
 * output parameters
 *
 * @return   Keep frame for application, release frame, or replay frame..
 */
fhStatus_t nwk_processLink(mrfiPacket_t *frame)
{
    d9b4:	0b 12       	push	r11		
    d9b6:	0a 12       	push	r10		
    d9b8:	09 12       	push	r9		
    d9ba:	08 12       	push	r8		
    d9bc:	31 82       	sub	#8,	r1	;r2 As==11
    d9be:	0b 4f       	mov	r15,	r11	

  /* If we sent this then this is the reply. Validate the
   * packet for reception by client app. If we didn't send
   * it then we are the target. send the reply.
   */
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, LB_REQ_OS, LB_TID_OS)))
    d9c0:	5e 42 66 02 	mov.b	&0x0266,r14	
    d9c4:	5c 43       	mov.b	#1,	r12	;r3 As==01
    d9c6:	4d 43       	clr.b	r13		
    d9c8:	b0 12 1a d3 	call	#0xd31a	
    d9cc:	4f 93       	tst.b	r15		
    d9ce:	56 24       	jz	$+174    	;abs 0xda7c
static fhStatus_t handleLinkRequest(mrfiPacket_t *frame)
{
  fhStatus_t rc = FHS_RELEASE;
  uint8_t    isReplySent;

  if (LINK_LEGACY_MSG_LENGTH == (MRFI_GET_PAYLOAD_LEN(frame) - F_APP_PAYLOAD_OS))
    d9d0:	6f 4b       	mov.b	@r11,	r15	
    d9d2:	7f 90 13 00 	cmp.b	#19,	r15	;#0x0013
    d9d6:	0a 24       	jz	$+22     	;abs 0xd9ec
  {
    /* Legacy frame. Spoof a link request */
    *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS) = LINK_REQ_LINK;
  }

  switch (*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS))
    d9d8:	db 93 0c 00 	cmp.b	#1,	12(r11)	;r3 As==01, 0x000c(r11)
    d9dc:	58 24       	jz	$+178    	;abs 0xda8e
  else
  {
    /* No, we didn't send it. Process request assuming it's
     * intended for us.
     */
    rc = handleLinkRequest(frame);
    d9de:	0f 43       	clr	r15		
  }

  (void) replyType;  /* keep compiler happy when ED built... */

  return rc;
}
    d9e0:	31 52       	add	#8,	r1	;r2 As==11
    d9e2:	38 41       	pop	r8		
    d9e4:	39 41       	pop	r9		
    d9e6:	3a 41       	pop	r10		
    d9e8:	3b 41       	pop	r11		
    d9ea:	30 41       	ret			
  uint8_t    isReplySent;

  if (LINK_LEGACY_MSG_LENGTH == (MRFI_GET_PAYLOAD_LEN(frame) - F_APP_PAYLOAD_OS))
  {
    /* Legacy frame. Spoof a link request */
    *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS) = LINK_REQ_LINK;
    d9ec:	db 43 0c 00 	mov.b	#1,	12(r11)	;r3 As==01, 0x000c(r11)

  /* see if token is correct */
  {
    uint32_t lt;

    nwk_getNumObjectFromMsg(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_LINK_TOKEN_OS, &lt, sizeof(lt));
    d9f0:	6d 42       	mov.b	#4,	r13	;r2 As==10
    d9f2:	0e 41       	mov	r1,	r14	
    d9f4:	2e 52       	add	#4,	r14	;r2 As==10
    d9f6:	0f 4b       	mov	r11,	r15	
    d9f8:	3f 50 0e 00 	add	#14,	r15	;#0x000e
    d9fc:	b0 12 ce d3 	call	#0xd3ce	
    if (lt != sLinkToken)
    da00:	91 92 6c 02 	cmp	&0x026c,4(r1)	;0x0004(r1)
    da04:	04 00 
    da06:	eb 23       	jnz	$-40     	;abs 0xd9de
    da08:	91 92 6e 02 	cmp	&0x026e,6(r1)	;0x0006(r1)
    da0c:	06 00 
    da0e:	e7 23       	jnz	$-48     	;abs 0xd9de
  }

  /* if we get here the token matched. */

  /* is this a duplicate request? */
  remotePort = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_RMT_PORT_OS);
    da10:	58 4b 12 00 	mov.b	18(r11),r8	;0x0012(r11)
  if ((pCInfo=nwk_isLinkDuplicate(MRFI_P_SRC_ADDR(frame), remotePort)))
    da14:	0a 4b       	mov	r11,	r10	
    da16:	3a 50 05 00 	add	#5,	r10	;#0x0005
    da1a:	4e 48       	mov.b	r8,	r14	
    da1c:	0f 4a       	mov	r10,	r15	
    da1e:	b0 12 2c d1 	call	#0xd12c	
    da22:	0f 93       	tst	r15		
    da24:	3f 24       	jz	$+128    	;abs 0xdaa4
  {
    /* resend reply */
    msg[LB_REQ_OS] = LINK_REQ_LINK | NWK_APP_REPLY_BIT;
    da26:	f1 40 81 ff 	mov.b	#-127,	0(r1)	;#0xff81, 0x0000(r1)
    da2a:	00 00 

    /* sender's TID */
    msg[LB_TID_OS] = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+LB_TID_OS);
    da2c:	d1 4b 0d 00 	mov.b	13(r11),1(r1)	;0x000d(r11), 0x0001(r1)
    da30:	01 00 

    /* Send reply with the local port number so the remote device knows where to
     * send packets.
     */
    msg[LR_RMT_PORT_OS] = pCInfo->portRx;
    da32:	d1 4f 08 00 	mov.b	8(r15),	2(r1)	;0x0008(r15), 0x0002(r1)
    da36:	02 00 

    /* put my Rx type in there. used to know how to set hops when sending back. */
    msg[LR_MY_RXTYPE_OS] = nwk_getMyRxType();
    da38:	b0 12 da d7 	call	#0xd7da	
    da3c:	c1 4f 03 00 	mov.b	r15,	3(r1)	;0x0003(r1)
    /* Set the Tx counter value for peer's Rx counter object */
    nwk_putNumObjectIntoMsg((void *)&pCInfo->connTxCTR, (void *)&msg[LR_CTR_OS], 4);
    /* We also need to save the newly generated Rx counter value. */
    nwk_getNumObjectFromMsg((void *)(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_CTR_OS), (void *)&pCInfo->connRxCTR, 4);
#endif
    if ((pOutFrame = nwk_buildFrame(SMPL_PORT_LINK, msg, sizeof(msg), MAX_HOPS-(GET_FROM_FRAME(MRFI_P_PAYLOAD(frame),F_HOP_COUNT)))))
    da40:	5f 4b 0a 00 	mov.b	10(r11),r15	;0x000a(r11)
    da44:	7f f0 07 00 	and.b	#7,	r15	;#0x0007
    da48:	7c 40 03 00 	mov.b	#3,	r12	;#0x0003
    da4c:	4c 8f       	sub.b	r15,	r12	
    da4e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    da50:	0e 41       	mov	r1,	r14	
    da52:	6f 43       	mov.b	#2,	r15	;r3 As==10
    da54:	b0 12 94 d5 	call	#0xd594	
    da58:	0f 93       	tst	r15		
    da5a:	c1 27       	jz	$-124    	;abs 0xd9de
    {
      /* destination address is the source adddress of the received frame. */
      memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
    da5c:	ef 4a 03 00 	mov.b	@r10,	3(r15)	;0x0003(r15)
    da60:	df 4b 06 00 	mov.b	6(r11),	4(r15)	;0x0006(r11), 0x0004(r15)
    da64:	04 00 
    da66:	df 4b 07 00 	mov.b	7(r11),	5(r15)	;0x0007(r11), 0x0005(r15)
    da6a:	05 00 
    da6c:	df 4b 08 00 	mov.b	8(r11),	6(r15)	;0x0008(r11), 0x0006(r15)
    da70:	06 00 
#if defined(SMPL_SECURE)
      nwk_setSecureFrame(&pOutFrame->mrfiPkt, sizeof(msg), 0);
#endif  /* SMPL_SECURE */
      nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_FORCED);
    da72:	4e 43       	clr.b	r14		
    da74:	b0 12 a4 d7 	call	#0xd7a4	
  else
  {
    /* No, we didn't send it. Process request assuming it's
     * intended for us.
     */
    rc = handleLinkRequest(frame);
    da78:	0f 43       	clr	r15		
    da7a:	b2 3f       	jmp	$-154    	;abs 0xd9e0
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, LB_REQ_OS, LB_TID_OS)))
  {
    /* It's a match and it's a reply. Validate the received packet by
     * returning a 1 so it can be received by the client app.
     */
    MRFI_PostKillSem();
    da7c:	b0 12 8e c4 	call	#0xc48e	
    rc = FHS_KEEP;
    da80:	1f 43       	mov	#1,	r15	;r3 As==01
  }

  (void) replyType;  /* keep compiler happy when ED built... */

  return rc;
}
    da82:	31 52       	add	#8,	r1	;r2 As==11
    da84:	38 41       	pop	r8		
    da86:	39 41       	pop	r9		
    da88:	3a 41       	pop	r10		
    da8a:	3b 41       	pop	r11		
    da8c:	30 41       	ret			
  connInfo_t  *pCInfo;
  uint8_t      remotePort;
  uint8_t      msg[LINK_REPLY_FRAME_SIZE];

  /* Is this a legacy frame? If so continue. Otherwise check version.*/
  if ((MRFI_GET_PAYLOAD_LEN(frame) - F_APP_PAYLOAD_OS) > LINK_LEGACY_MSG_LENGTH)
    da8e:	4f 4f       	mov.b	r15,	r15	
    da90:	3f 90 14 00 	cmp	#20,	r15	;#0x0014
    da94:	ad 3b       	jl	$-164    	;abs 0xd9f0
  {
    /* see if protocol version is correct... */
    if (*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_PROTOCOL_VERSION_OS) != nwk_getProtocolVersion())
    da96:	5a 4b 14 00 	mov.b	20(r11),r10	;0x0014(r11)
    da9a:	b0 12 6e dd 	call	#0xdd6e	
    da9e:	4a 9f       	cmp.b	r15,	r10	
    daa0:	9e 23       	jnz	$-194    	;abs 0xd9de
    daa2:	a6 3f       	jmp	$-178    	;abs 0xd9f0
      nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_FORCED);
    }
    return SENT_REPLY;
  }

  if (!sListenActive)
    daa4:	5f 42 6a 02 	mov.b	&0x026a,r15	
    daa8:	4f 93       	tst.b	r15		
    daaa:	99 27       	jz	$-204    	;abs 0xd9de
  pCInfo = nwk_findAlreadyJoined(frame);

  if (!pCInfo)
#endif
  {
    pCInfo = nwk_getNextConnection();
    daac:	b0 12 5e d0 	call	#0xd05e	
    dab0:	09 4f       	mov	r15,	r9	
  }

  if (pCInfo)
    dab2:	0f 93       	tst	r15		
    dab4:	94 27       	jz	$-214    	;abs 0xd9de
  {
    /* yes there's room and it's not a dup. address. */
    memcpy(&pCInfo->peerAddr, MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
    dab6:	2d 42       	mov	#4,	r13	;r2 As==10
    dab8:	0e 4a       	mov	r10,	r14	
    daba:	2f 53       	incd	r15		
    dabc:	b0 12 28 e2 	call	#0xe228	

    if (!nwk_allocateLocalRxPort(LINK_REPLY, pCInfo))
    dac0:	0e 49       	mov	r9,	r14	
    dac2:	6f 43       	mov.b	#2,	r15	;r3 As==10
    dac4:	b0 12 42 d2 	call	#0xd242	
    dac8:	4f 93       	tst.b	r15		
    daca:	43 24       	jz	$+136    	;abs 0xdb52

    /* The local Rx port is the one returned in the connection structure. The
     * caller is waiting on this to be set. The code here is running in an ISR
     * thread so the caller will see this change after RETI.
     */
    if (NUM_CONNECTIONS == sNumLinkers)
    dacc:	5f 42 67 02 	mov.b	&0x0267,r15	
    dad0:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    dad2:	3f 24       	jz	$+128    	;abs 0xdb52
      /* Something is wrong -- no room to stack Link request */
      nwk_freeConnection(pCInfo);
      /* we're done with the packet */
      return SENT_REPLY;
    }
    sServiceLinkID[sNumLinkers++] = pCInfo->thisLinkID;
    dad4:	5e 42 67 02 	mov.b	&0x0267,r14	
    dad8:	4f 4e       	mov.b	r14,	r15	
    dada:	5d 49 0a 00 	mov.b	10(r9),	r13	;0x000a(r9)
    dade:	3f 50 68 02 	add	#616,	r15	;#0x0268
    dae2:	cf 4d 00 00 	mov.b	r13,	0(r15)	;0x0000(r15)
    dae6:	5e 53       	inc.b	r14		
    dae8:	c2 4e 67 02 	mov.b	r14,	&0x0267	

    /* save the remote Tx port */
    pCInfo->portTx = remotePort;
    daec:	c9 48 09 00 	mov.b	r8,	9(r9)	;0x0009(r9)

    /* connection is valid... */
    pCInfo->connState = CONNSTATE_CONNECTED;
    daf0:	e9 43 00 00 	mov.b	#2,	0(r9)	;r3 As==10, 0x0000(r9)
    /* Set hop count. If it's a polling device set the count to the
     * distance to the AP. otherwise, set it to the max less the remaining
     * which will be the path taken for this frame. It will be no worse
     * then tha max and probably will be better.
     */
    if (F_RX_TYPE_POLLS == *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_MY_RXTYPE_OS))
    daf4:	fb 90 40 00 	cmp.b	#64,	19(r11)	;#0x0040, 0x0013(r11)
    daf8:	13 00 
    dafa:	30 24       	jz	$+98     	;abs 0xdb5c
       * was marginal.
       */
#if defined(DEVICE_DOES_NOT_MOVE)
      pCInfo->hops2target = MAX_HOPS - GET_FROM_FRAME(MRFI_P_PAYLOAD(frame), F_HOP_COUNT);
#else
      pCInfo->hops2target = MAX_HOPS;
    dafc:	f9 40 03 00 	mov.b	#3,	1(r9)	;#0x0003, 0x0001(r9)
    db00:	01 00 
#endif
    }
    /* Send reply with the local port number so the remote device knows where to
     * send packets.
     */
    msg[LR_RMT_PORT_OS]  = pCInfo->portRx;
    db02:	d1 49 08 00 	mov.b	8(r9),	2(r1)	;0x0008(r9), 0x0002(r1)
    db06:	02 00 

    /* put my Rx type in there. used to know how to set hops when sending back. */
    msg[LR_MY_RXTYPE_OS] = nwk_getMyRxType();
    db08:	b0 12 da d7 	call	#0xd7da	
    db0c:	c1 4f 03 00 	mov.b	r15,	3(r1)	;0x0003(r1)

    msg[LB_REQ_OS] = LINK_REQ_LINK | NWK_APP_REPLY_BIT;
    db10:	f1 40 81 ff 	mov.b	#-127,	0(r1)	;#0xff81, 0x0000(r1)
    db14:	00 00 

    /* sender's TID */
    msg[LB_TID_OS] = *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+LB_TID_OS);
    db16:	d1 4b 0d 00 	mov.b	13(r11),1(r1)	;0x000d(r11), 0x0001(r1)
    db1a:	01 00 
                        ((uint32_t)(MRFI_RandomByte())<<16) | \
                        ((uint32_t)(MRFI_RandomByte())<<24);

    nwk_putNumObjectIntoMsg((void *)&pCInfo->connTxCTR, (void *)&msg[LR_CTR_OS], 4);
#endif
    if ((pOutFrame = nwk_buildFrame(SMPL_PORT_LINK, msg, sizeof(msg), MAX_HOPS-(GET_FROM_FRAME(MRFI_P_PAYLOAD(frame),F_HOP_COUNT)))))
    db1c:	5f 4b 0a 00 	mov.b	10(r11),r15	;0x000a(r11)
    db20:	7f f0 07 00 	and.b	#7,	r15	;#0x0007
    db24:	7c 40 03 00 	mov.b	#3,	r12	;#0x0003
    db28:	4c 8f       	sub.b	r15,	r12	
    db2a:	6d 42       	mov.b	#4,	r13	;r2 As==10
    db2c:	0e 41       	mov	r1,	r14	
    db2e:	6f 43       	mov.b	#2,	r15	;r3 As==10
    db30:	b0 12 94 d5 	call	#0xd594	
    db34:	0b 4f       	mov	r15,	r11	
    db36:	0f 93       	tst	r15		
    db38:	0c 24       	jz	$+26     	;abs 0xdb52
    {
      /* destination address is the source adddress of the received frame. */
      memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
    db3a:	2d 42       	mov	#4,	r13	;r2 As==10
    db3c:	0e 4a       	mov	r10,	r14	
    db3e:	3f 50 03 00 	add	#3,	r15	;#0x0003
    db42:	b0 12 28 e2 	call	#0xe228	
#if defined(SMPL_SECURE)
      nwk_setSecureFrame(&pOutFrame->mrfiPkt, sizeof(msg), 0);
#endif
      if (SMPL_SUCCESS != nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_FORCED))
    db46:	4e 43       	clr.b	r14		
    db48:	0f 4b       	mov	r11,	r15	
    db4a:	b0 12 a4 d7 	call	#0xd7a4	
    db4e:	0f 93       	tst	r15		
    db50:	46 27       	jz	$-370    	;abs 0xd9de
      }
    }
    else
    {
      /* better release the connection structure */
      nwk_freeConnection(pCInfo);
    db52:	0f 49       	mov	r9,	r15	
    db54:	b0 12 da d0 	call	#0xd0da	
  else
  {
    /* No, we didn't send it. Process request assuming it's
     * intended for us.
     */
    rc = handleLinkRequest(frame);
    db58:	0f 43       	clr	r15		
    db5a:	42 3f       	jmp	$-378    	;abs 0xd9e0
    if (F_RX_TYPE_POLLS == *(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS+L_MY_RXTYPE_OS))
    {
      /* It polls. so. we'll be sending to the AP which will store the
       * frame. The AP is only MAX_HOPS_FROM_AP hops away from us.
       */
      pCInfo->hops2target = MAX_HOPS_FROM_AP;
    db5c:	d9 43 01 00 	mov.b	#1,	1(r9)	;r3 As==01, 0x0001(r9)
    db60:	d0 3f       	jmp	$-94     	;abs 0xdb02

0000db62 <nwk_getLocalLinkID>:
#if NUM_CONNECTIONS > 0
  uint8_t     i;
  bspIState_t intState;


  BSP_ENTER_CRITICAL_SECTION(intState);
    db62:	0f 42       	mov	r2,	r15	
    db64:	3f f2       	and	#8,	r15	;r2 As==11
    db66:	32 c2       	dint			
    db68:	03 43       	nop			
  if (sNumLinkers)
    db6a:	5e 42 67 02 	mov.b	&0x0267,r14	
    db6e:	4e 93       	tst.b	r14		
    db70:	1e 24       	jz	$+62     	;abs 0xdbae
  {
    sNumLinkers--;
    db72:	f2 53 67 02 	add.b	#-1,	&0x0267	;r3 As==11
    BSP_EXIT_CRITICAL_SECTION(intState);
    db76:	0f 93       	tst	r15		
    db78:	20 20       	jnz	$+66     	;abs 0xdbba
    db7a:	0f 42       	mov	r2,	r15	
 *
 * @return   void
 */
void nwk_setListenContext(uint8_t context)
{
  sListenActive = (context == LINK_LISTEN_ON) ? 1 : 0;
    db7c:	c2 43 6a 02 	mov.b	#0,	&0x026a	;r3 As==00
  {
    sNumLinkers--;
    BSP_EXIT_CRITICAL_SECTION(intState);

    nwk_setListenContext(LINK_LISTEN_OFF);
    lid = sServiceLinkID[0];
    db80:	5f 42 68 02 	mov.b	&0x0268,r15	
     * window of opportunity for a "typical" scenario to get hosed. But for
     * a "typical" scenario to get hosed a number of improbable events have to
     * occur. These are deemed far less likely than the multiple-ED-activation
     * scenario in the AP-as-dat-hub case.
     */
    for (i=0; i<sNumLinkers; ++i)
    db84:	5e 42 67 02 	mov.b	&0x0267,r14	
    db88:	4e 93       	tst.b	r14		
    db8a:	16 24       	jz	$+46     	;abs 0xdbb8
    db8c:	4d 43       	clr.b	r13		
    {
      sServiceLinkID[i] = sServiceLinkID[i+1];
    db8e:	4c 4d       	mov.b	r13,	r12	
    db90:	0e 4c       	mov	r12,	r14	
    db92:	1e 53       	inc	r14		
    db94:	3e 50 68 02 	add	#616,	r14	;#0x0268
    db98:	6e 4e       	mov.b	@r14,	r14	
    db9a:	3c 50 68 02 	add	#616,	r12	;#0x0268
    db9e:	cc 4e 00 00 	mov.b	r14,	0(r12)	;0x0000(r12)
     * window of opportunity for a "typical" scenario to get hosed. But for
     * a "typical" scenario to get hosed a number of improbable events have to
     * occur. These are deemed far less likely than the multiple-ED-activation
     * scenario in the AP-as-dat-hub case.
     */
    for (i=0; i<sNumLinkers; ++i)
    dba2:	5d 53       	inc.b	r13		
    dba4:	5e 42 67 02 	mov.b	&0x0267,r14	
    dba8:	4d 9e       	cmp.b	r14,	r13	
    dbaa:	f1 2b       	jnc	$-28     	;abs 0xdb8e
    dbac:	30 41       	ret			
      sServiceLinkID[i] = sServiceLinkID[i+1];
    }
  }
  else
  {
    BSP_EXIT_CRITICAL_SECTION(intState);
    dbae:	0f 93       	tst	r15		
    dbb0:	01 24       	jz	$+4      	;abs 0xdbb4
    dbb2:	32 d2       	eint			
    dbb4:	0f 42       	mov	r2,	r15	
 *
 * @return   Local port assigned when the link reply was received.
 */
linkID_t nwk_getLocalLinkID(void)
{
  linkID_t    lid = 0;
    dbb6:	4f 43       	clr.b	r15		
    BSP_EXIT_CRITICAL_SECTION(intState);
  }
#endif  /* NUM_CONNECTIONS */

  return lid;
}
    dbb8:	30 41       	ret			

  BSP_ENTER_CRITICAL_SECTION(intState);
  if (sNumLinkers)
  {
    sNumLinkers--;
    BSP_EXIT_CRITICAL_SECTION(intState);
    dbba:	32 d2       	eint			
    dbbc:	de 3f       	jmp	$-66     	;abs 0xdb7a

0000dbbe <nwk_setListenContext>:
 *
 * @return   void
 */
void nwk_setListenContext(uint8_t context)
{
  sListenActive = (context == LINK_LISTEN_ON) ? 1 : 0;
    dbbe:	5e 43       	mov.b	#1,	r14	;r3 As==01
    dbc0:	4f 93       	tst.b	r15		
    dbc2:	01 24       	jz	$+4      	;abs 0xdbc6
    dbc4:	4e 43       	clr.b	r14		
    dbc6:	c2 4e 6a 02 	mov.b	r14,	&0x026a	
}
    dbca:	30 41       	ret			

0000dbcc <nwk_rawSend>:
 * @return         SMPL_SUCCESS
 *                 SMPL_NOMEM       - no room in output frame queue
 *                 SMPL_TX_CCA_FAIL - CCA failure
 */
smplStatus_t nwk_rawSend(ioctlRawSend_t *info)
{
    dbcc:	0b 12       	push	r11		
    dbce:	0b 4f       	mov	r15,	r11	
  uint8_t      hops;

  /* If we know frame is going to or from the AP then we can reduce the hop
   * count.
   */
  switch (info->port)
    dbd0:	5f 4f 05 00 	mov.b	5(r15),	r15	;0x0005(r15)
    dbd4:	4e 4f       	mov.b	r15,	r14	
    dbd6:	7e 50 fd ff 	add.b	#-3,	r14	;#0xfffd
    dbda:	6e 92       	cmp.b	#4,	r14	;r2 As==10
    dbdc:	19 2c       	jc	$+52     	;abs 0xdc10
    dbde:	4e 4e       	mov.b	r14,	r14	
    dbe0:	5c 4e f4 e4 	mov.b	-6924(r14),r12	;0xe4f4(r14)
    default:
      hops = MAX_HOPS;
      break;
  }

  if ((pOutFrame = nwk_buildFrame(info->port, info->msg, info->len, hops)))
    dbe4:	5d 4b 04 00 	mov.b	4(r11),	r13	;0x0004(r11)
    dbe8:	1e 4b 02 00 	mov	2(r11),	r14	;0x0002(r11)
    dbec:	b0 12 94 d5 	call	#0xd594	
    dbf0:	0f 93       	tst	r15		
    dbf2:	11 24       	jz	$+36     	;abs 0xdc16
      // update the transmit time stamp address to point
      // into where the message was copied to
      MRFI_SetTxTimeStampAddr( &(((pll_Packet_t*)pkt)->Time) );
    }
#endif
    memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), info->addr, NET_ADDR_SIZE);
    dbf4:	2e 4b       	mov	@r11,	r14	
    dbf6:	ff 4e 03 00 	mov.b	@r14+,	3(r15)	;0x0003(r15)
    dbfa:	ff 4e 04 00 	mov.b	@r14+,	4(r15)	;0x0004(r15)
    dbfe:	ff 4e 05 00 	mov.b	@r14+,	5(r15)	;0x0005(r15)
    dc02:	ef 4e 06 00 	mov.b	@r14,	6(r15)	;0x0006(r15)
#ifdef SMPL_SECURE
    nwk_setSecureFrame(&pOutFrame->mrfiPkt, info->len, 0);
#endif  /* SMPL_SECURE */
    return nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_CCA);
    dc06:	5e 43       	mov.b	#1,	r14	;r3 As==01
    dc08:	b0 12 a4 d7 	call	#0xd7a4	
  }
  return SMPL_NOMEM;
}
    dc0c:	3b 41       	pop	r11		
    dc0e:	30 41       	ret			
  uint8_t      hops;

  /* If we know frame is going to or from the AP then we can reduce the hop
   * count.
   */
  switch (info->port)
    dc10:	7c 40 03 00 	mov.b	#3,	r12	;#0x0003
    dc14:	e7 3f       	jmp	$-48     	;abs 0xdbe4
#ifdef SMPL_SECURE
    nwk_setSecureFrame(&pOutFrame->mrfiPkt, info->len, 0);
#endif  /* SMPL_SECURE */
    return nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_CCA);
  }
  return SMPL_NOMEM;
    dc16:	3f 40 03 00 	mov	#3,	r15	;#0x0003
}
    dc1a:	3b 41       	pop	r11		
    dc1c:	30 41       	ret			

0000dc1e <nwk_rawReceive>:
 *                       hop count of retrieved frame.
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_rawReceive(ioctlRawReceive_t *info)
{
    dc1e:	21 82       	sub	#4,	r1	;r2 As==10
  rcvContext_t rcv;

  rcv.type   = RCV_NWK_PORT;
    dc20:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00, 0x0000(r1)
  rcv.t.port = info->port;
    dc24:	d1 4f 05 00 	mov.b	5(r15),	2(r1)	;0x0005(r15), 0x0002(r1)
    dc28:	02 00 

  return nwk_retrieveFrame(&rcv, info->msg, &info->len, info->addr, &info->hopCount);
    dc2a:	0e 4f       	mov	r15,	r14	
    dc2c:	3e 50 06 00 	add	#6,	r14	;#0x0006
    dc30:	0e 12       	push	r14		
    dc32:	2c 4f       	mov	@r15,	r12	
    dc34:	0d 4f       	mov	r15,	r13	
    dc36:	2d 52       	add	#4,	r13	;r2 As==10
    dc38:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    dc3c:	0f 41       	mov	r1,	r15	
    dc3e:	2f 53       	incd	r15		
    dc40:	b0 12 be d6 	call	#0xd6be	
}
    dc44:	31 50 06 00 	add	#6,	r1	;#0x0006
    dc48:	30 41       	ret			

0000dc4a <nwk_radioControl>:
 * output parameters
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
    dc4a:	21 83       	decd	r1		
  smplStatus_t rc = SMPL_SUCCESS;

  if (IOCTL_ACT_RADIO_SLEEP == action)
    dc4c:	2f 92       	cmp	#4,	r15	;r2 As==10
    dc4e:	19 24       	jz	$+52     	;abs 0xdc82
  {
    /* go to sleep mode. */
    MRFI_RxIdle();
    MRFI_Sleep();
  }
  else if (IOCTL_ACT_RADIO_AWAKE == action)
    dc50:	3f 90 05 00 	cmp	#5,	r15	;#0x0005
    dc54:	1d 24       	jz	$+60     	;abs 0xdc90
#if !defined( END_DEVICE )
    MRFI_RxOn();
#endif

  }
  else if (IOCTL_ACT_RADIO_SIGINFO == action)
    dc56:	3f 90 06 00 	cmp	#6,	r15	;#0x0006
    dc5a:	1f 24       	jz	$+64     	;abs 0xdc9a
    {
      return SMPL_BAD_PARAM;
    }
    memcpy(&pSigInfo->sigInfo, &pCInfo->sigInfo, sizeof(pCInfo->sigInfo));
  }
  else if (IOCTL_ACT_RADIO_RSSI == action)
    dc5c:	3f 90 07 00 	cmp	#7,	r15	;#0x0007
    dc60:	2e 24       	jz	$+94     	;abs 0xdcbe
  {
    *((rssi_t *)val) = MRFI_Rssi();
  }
  else if (IOCTL_ACT_RADIO_RXON == action)
    dc62:	3f 92       	cmp	#8,	r15	;r2 As==11
    dc64:	06 24       	jz	$+14     	;abs 0xdc72
  {
    MRFI_RxOn();
  }
  else if (IOCTL_ACT_RADIO_RXIDLE == action)
    dc66:	3f 90 09 00 	cmp	#9,	r15	;#0x0009
    dc6a:	07 24       	jz	$+16     	;abs 0xdc7a
    return SMPL_SUCCESS;
  }
#endif  /* EXTENDED_API */
  else
  {
    rc = SMPL_BAD_PARAM;
    dc6c:	2f 43       	mov	#2,	r15	;r3 As==10
  }
  return rc;
}
    dc6e:	21 53       	incd	r1		
    dc70:	30 41       	ret			
  {
    *((rssi_t *)val) = MRFI_Rssi();
  }
  else if (IOCTL_ACT_RADIO_RXON == action)
  {
    MRFI_RxOn();
    dc72:	b0 12 ba c5 	call	#0xc5ba	
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    dc76:	0f 43       	clr	r15		
    dc78:	fa 3f       	jmp	$-10     	;abs 0xdc6e
  {
    MRFI_RxOn();
  }
  else if (IOCTL_ACT_RADIO_RXIDLE == action)
  {
    MRFI_RxIdle();
    dc7a:	b0 12 7a c5 	call	#0xc57a	
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    dc7e:	0f 43       	clr	r15		
    dc80:	f6 3f       	jmp	$-18     	;abs 0xdc6e

  if (IOCTL_ACT_RADIO_SLEEP == action)
  {
    /* go to sleep mode. */
    MRFI_RxIdle();
    dc82:	b0 12 7a c5 	call	#0xc57a	
    MRFI_Sleep();
    dc86:	b0 12 da c5 	call	#0xc5da	
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    dc8a:	0f 43       	clr	r15		
  else
  {
    rc = SMPL_BAD_PARAM;
  }
  return rc;
}
    dc8c:	21 53       	incd	r1		
    dc8e:	30 41       	ret			
    MRFI_RxIdle();
    MRFI_Sleep();
  }
  else if (IOCTL_ACT_RADIO_AWAKE == action)
  {
    MRFI_WakeUp();
    dc90:	b0 12 a2 c6 	call	#0xc6a2	
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    dc94:	0f 43       	clr	r15		
  else
  {
    rc = SMPL_BAD_PARAM;
  }
  return rc;
}
    dc96:	21 53       	incd	r1		
    dc98:	30 41       	ret			

  }
  else if (IOCTL_ACT_RADIO_SIGINFO == action)
  {
    ioctlRadioSiginfo_t *pSigInfo = (ioctlRadioSiginfo_t *)val;
    connInfo_t          *pCInfo   = nwk_getConnInfo(pSigInfo->lid);
    dc9a:	6f 4e       	mov.b	@r14,	r15	
    dc9c:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    dca0:	b0 12 e0 d0 	call	#0xd0e0	

    if (!pCInfo)
    dca4:	2e 41       	mov	@r1,	r14	
    dca6:	0f 93       	tst	r15		
    dca8:	e1 27       	jz	$-60     	;abs 0xdc6c
    {
      return SMPL_BAD_PARAM;
    }
    memcpy(&pSigInfo->sigInfo, &pCInfo->sigInfo, sizeof(pCInfo->sigInfo));
    dcaa:	2e 53       	incd	r14		
    dcac:	3f 50 06 00 	add	#6,	r15	;#0x0006
    dcb0:	ee 4f 00 00 	mov.b	@r15,	0(r14)	;0x0000(r14)
    dcb4:	de 4f 01 00 	mov.b	1(r15),	1(r14)	;0x0001(r15), 0x0001(r14)
    dcb8:	01 00 
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    dcba:	0f 43       	clr	r15		
    dcbc:	d8 3f       	jmp	$-78     	;abs 0xdc6e
    }
    memcpy(&pSigInfo->sigInfo, &pCInfo->sigInfo, sizeof(pCInfo->sigInfo));
  }
  else if (IOCTL_ACT_RADIO_RSSI == action)
  {
    *((rssi_t *)val) = MRFI_Rssi();
    dcbe:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    dcc2:	b0 12 1e c6 	call	#0xc61e	
    dcc6:	2e 41       	mov	@r1,	r14	
    dcc8:	ce 4f 00 00 	mov.b	r15,	0(r14)	;0x0000(r14)
 *
 * @return   Status of operation.
 */
smplStatus_t nwk_radioControl(ioctlAction_t action, void *val)
{
  smplStatus_t rc = SMPL_SUCCESS;
    dccc:	0f 43       	clr	r15		
    dcce:	cf 3f       	jmp	$-96     	;abs 0xdc6e

0000dcd0 <nwk_deviceAddress>:
 * @return   SMPL_SUCCESS
 *           SMPL_BAD_PARAM  Action request illegal or a Set request
 *                           was not respected.
 */
smplStatus_t nwk_deviceAddress(ioctlAction_t action, addr_t *addr)
{
    dcd0:	21 83       	decd	r1		
  smplStatus_t rc = SMPL_BAD_PARAM;

  if (IOCTL_ACT_GET == action)
    dcd2:	1f 93       	cmp	#1,	r15	;r3 As==01
    dcd4:	0c 24       	jz	$+26     	;abs 0xdcee
  {
    memcpy(addr, nwk_getMyAddress(), sizeof(addr_t));
    rc = SMPL_SUCCESS;
  }
  else if (IOCTL_ACT_SET == action)
    dcd6:	0f 93       	tst	r15		
    dcd8:	03 24       	jz	$+8      	;abs 0xdce0
 *           SMPL_BAD_PARAM  Action request illegal or a Set request
 *                           was not respected.
 */
smplStatus_t nwk_deviceAddress(ioctlAction_t action, addr_t *addr)
{
  smplStatus_t rc = SMPL_BAD_PARAM;
    dcda:	2f 43       	mov	#2,	r15	;r3 As==10
      rc = SMPL_SUCCESS;
    }
  }

  return rc;
}
    dcdc:	21 53       	incd	r1		
    dcde:	30 41       	ret			
    memcpy(addr, nwk_getMyAddress(), sizeof(addr_t));
    rc = SMPL_SUCCESS;
  }
  else if (IOCTL_ACT_SET == action)
  {
    if (nwk_setMyAddress(addr))
    dce0:	0f 4e       	mov	r14,	r15	
    dce2:	b0 12 72 dd 	call	#0xdd72	
    dce6:	4f 93       	tst.b	r15		
    dce8:	f8 27       	jz	$-14     	;abs 0xdcda
    {
      rc = SMPL_SUCCESS;
    dcea:	0f 43       	clr	r15		
    dcec:	f7 3f       	jmp	$-16     	;abs 0xdcdc
{
  smplStatus_t rc = SMPL_BAD_PARAM;

  if (IOCTL_ACT_GET == action)
  {
    memcpy(addr, nwk_getMyAddress(), sizeof(addr_t));
    dcee:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    dcf2:	b0 12 56 dd 	call	#0xdd56	
    dcf6:	2e 41       	mov	@r1,	r14	
    dcf8:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dcfc:	1e 53       	inc	r14		
    dcfe:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dd02:	1e 53       	inc	r14		
    dd04:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dd08:	ee 4f 01 00 	mov.b	@r15,	1(r14)	;0x0001(r14)
    rc = SMPL_SUCCESS;
    dd0c:	0f 43       	clr	r15		
    dd0e:	e6 3f       	jmp	$-50     	;abs 0xdcdc

0000dd10 <nwk_connectionControl>:
 *                           No connection table info for Link ID
 */
smplStatus_t nwk_connectionControl(ioctlAction_t action, void *val)
{
  connInfo_t *pCInfo;
  linkID_t    lid = *((linkID_t *)val);
    dd10:	6e 4e       	mov.b	@r14,	r14	

  if (IOCTL_ACT_DELETE != action)
    dd12:	3f 90 0e 00 	cmp	#14,	r15	;#0x000e
    dd16:	02 24       	jz	$+6      	;abs 0xdd1c
  }

  if ((SMPL_LINKID_USER_UUD == lid) ||
      (!(pCInfo=nwk_getConnInfo(lid))))
  {
    return SMPL_BAD_PARAM;
    dd18:	2f 43       	mov	#2,	r15	;r3 As==10
    dd1a:	30 41       	ret			
  if (IOCTL_ACT_DELETE != action)
  {
    return SMPL_BAD_PARAM;
  }

  if ((SMPL_LINKID_USER_UUD == lid) ||
    dd1c:	7e 93       	cmp.b	#-1,	r14	;r3 As==11
    dd1e:	fc 27       	jz	$-6      	;abs 0xdd18
    dd20:	4f 4e       	mov.b	r14,	r15	
    dd22:	b0 12 e0 d0 	call	#0xd0e0	
    dd26:	0f 93       	tst	r15		
    dd28:	04 24       	jz	$+10     	;abs 0xdd32
      (!(pCInfo=nwk_getConnInfo(lid))))
  {
    return SMPL_BAD_PARAM;
  }

  nwk_freeConnection(pCInfo);
    dd2a:	b0 12 da d0 	call	#0xd0da	

  return SMPL_SUCCESS;
    dd2e:	0f 43       	clr	r15		
    dd30:	30 41       	ret			
  }

  if ((SMPL_LINKID_USER_UUD == lid) ||
      (!(pCInfo=nwk_getConnInfo(lid))))
  {
    return SMPL_BAD_PARAM;
    dd32:	2f 43       	mov	#2,	r15	;r3 As==10
  }

  nwk_freeConnection(pCInfo);

  return SMPL_SUCCESS;
}
    dd34:	30 41       	ret			

0000dd36 <nwk_globalsInit>:
 * @return   void
 */
void nwk_globalsInit(void)
{

  memset(&sAPAddress, 0x00, sizeof(addr_t));
    dd36:	82 43 70 02 	mov	#0,	&0x0270	;r3 As==00
    dd3a:	82 43 72 02 	mov	#0,	&0x0272	;r3 As==00

  /* populate RAM address from ROM default if it hasn't laready been set
   * using the IOCTL interface.
   */
  if (!sRAMAddressIsSet)
    dd3e:	c2 93 74 02 	tst.b	&0x0274	
    dd42:	08 20       	jnz	$+18     	;abs 0xdd54
  {
    memcpy(&sMyRAMAddress, &sMyROMAddress, sizeof(addr_t));
    dd44:	92 42 f8 e4 	mov	&0xe4f8,&0x0276	
    dd48:	76 02 
    dd4a:	92 42 fa e4 	mov	&0xe4fa,&0x0278	
    dd4e:	78 02 
    sRAMAddressIsSet = 1;  /* RAM address is now valid */
    dd50:	d2 43 74 02 	mov.b	#1,	&0x0274	;r3 As==01
    dd54:	30 41       	ret			

0000dd56 <nwk_getMyAddress>:
   * to be careful -- if this routine is called immediately it will return
   * the ROM address. If the application then sets the address using the
   * IOCTL before doing the SMPL_Init() the original pointer is no longer
   * valid as it points to the wrong address.
   */
  return sRAMAddressIsSet ? &sMyRAMAddress : &sMyROMAddress;
    dd56:	c2 93 74 02 	tst.b	&0x0274	
    dd5a:	03 20       	jnz	$+8      	;abs 0xdd62
    dd5c:	3f 40 f8 e4 	mov	#-6920,	r15	;#0xe4f8
}
    dd60:	30 41       	ret			
   * to be careful -- if this routine is called immediately it will return
   * the ROM address. If the application then sets the address using the
   * IOCTL before doing the SMPL_Init() the original pointer is no longer
   * valid as it points to the wrong address.
   */
  return sRAMAddressIsSet ? &sMyRAMAddress : &sMyROMAddress;
    dd62:	3f 40 76 02 	mov	#630,	r15	;#0x0276
    dd66:	30 41       	ret			

0000dd68 <nwk_getFWVersion>:
 * @return   pointer to a constant uint16_t object.
 */
uint8_t const *nwk_getFWVersion()
{
  return sVersionInfo.fwVerString;
}
    dd68:	3f 40 fd e4 	mov	#-6915,	r15	;#0xe4fd
    dd6c:	30 41       	ret			

0000dd6e <nwk_getProtocolVersion>:
 * @return   Protocol version.
 */
uint8_t nwk_getProtocolVersion(void)
{
  return sVersionInfo.protocolVersion;
}
    dd6e:	6f 43       	mov.b	#2,	r15	;r3 As==10
    dd70:	30 41       	ret			

0000dd72 <nwk_setMyAddress>:
 */
uint8_t nwk_setMyAddress(addr_t *addr)
{
  uint8_t rc = 0;

  if (!sRAMAddressIsSet)
    dd72:	c2 93 74 02 	tst.b	&0x0274	
    dd76:	02 24       	jz	$+6      	;abs 0xdd7c
 *
 * @return   Returns non-zero if request is respected, otherwise returns 0.
 */
uint8_t nwk_setMyAddress(addr_t *addr)
{
  uint8_t rc = 0;
    dd78:	4f 43       	clr.b	r15		
    sRAMAddressIsSet = 1;  /* RAM address is now valid */
    rc = 1;
  }

  return rc;
}
    dd7a:	30 41       	ret			
{
  uint8_t rc = 0;

  if (!sRAMAddressIsSet)
  {
    memcpy(&sMyRAMAddress, addr, sizeof(addr_t));
    dd7c:	f2 4f 76 02 	mov.b	@r15+,	&0x0276	
    dd80:	f2 4f 77 02 	mov.b	@r15+,	&0x0277	
    dd84:	f2 4f 78 02 	mov.b	@r15+,	&0x0278	
    dd88:	e2 4f 79 02 	mov.b	@r15,	&0x0279	
    sRAMAddressIsSet = 1;  /* RAM address is now valid */
    dd8c:	d2 43 74 02 	mov.b	#1,	&0x0274	;r3 As==01
    rc = 1;
    dd90:	5f 43       	mov.b	#1,	r15	;r3 As==01
    dd92:	30 41       	ret			

0000dd94 <nwk_setAPAddress>:
 * @return   void
 */
void nwk_setAPAddress(addr_t *addr)
{

  memcpy((void *)&sAPAddress, (void *)addr, NET_ADDR_SIZE);
    dd94:	3e 40 70 02 	mov	#624,	r14	;#0x0270
    dd98:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dd9c:	1e 53       	inc	r14		
    dd9e:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dda2:	1e 53       	inc	r14		
    dda4:	fe 4f 00 00 	mov.b	@r15+,	0(r14)	;0x0000(r14)
    dda8:	ee 4f 01 00 	mov.b	@r15,	1(r14)	;0x0001(r14)

  return;
}
    ddac:	30 41       	ret			

0000ddae <nwk_getAPAddress>:
 *
 * @return   Pointer to a constant address object or null if the address has not
 *           yet been set.
 */
addr_t const *nwk_getAPAddress(void)
{
    ddae:	21 82       	sub	#4,	r1	;r2 As==10
  addr_t addr;

  memset(&addr, 0x0, sizeof(addr));
    ddb0:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00, 0x0000(r1)
    ddb4:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00, 0x0002(r1)

  return !memcmp(&sAPAddress, &addr, NET_ADDR_SIZE) ? 0 : &sAPAddress;
    ddb8:	2d 42       	mov	#4,	r13	;r2 As==10
    ddba:	0e 41       	mov	r1,	r14	
    ddbc:	3f 40 70 02 	mov	#624,	r15	;#0x0270
    ddc0:	b0 12 08 e2 	call	#0xe208	
    ddc4:	0f 93       	tst	r15		
    ddc6:	04 24       	jz	$+10     	;abs 0xddd0
    ddc8:	3f 40 70 02 	mov	#624,	r15	;#0x0270
}
    ddcc:	21 52       	add	#4,	r1	;r2 As==10
    ddce:	30 41       	ret			
{
  addr_t addr;

  memset(&addr, 0x0, sizeof(addr));

  return !memcmp(&sAPAddress, &addr, NET_ADDR_SIZE) ? 0 : &sAPAddress;
    ddd0:	0f 43       	clr	r15		
}
    ddd2:	21 52       	add	#4,	r1	;r2 As==10
    ddd4:	30 41       	ret			

0000ddd6 <nwk_getBCastAddress>:
 * @return   Pointer to a constant address object.
 */
addr_t const *nwk_getBCastAddress(void)
{
  return (addr_t const *)mrfiBroadcastAddr;
}
    ddd6:	3f 40 88 e4 	mov	#-7032,	r15	;#0xe488
    ddda:	30 41       	ret			

0000dddc <nwk_freqInit>:
 * @return   none.
 */
void nwk_freqInit(void)
{
  return;
}
    dddc:	30 41       	ret			

0000ddde <nwk_processFreq>:
 * @return   Disposition for frame: either release (FHS_RELEASE) or replay (FHS_REPLAY).
 */
fhStatus_t nwk_processFreq(mrfiPacket_t *frame)
{
  return FHS_RELEASE;
}
    ddde:	0f 43       	clr	r15		
    dde0:	30 41       	ret			

0000dde2 <nwk_pingInit>:
 *
 * @return   void
 */
void nwk_pingInit(void)
{
  sTid = MRFI_RandomByte();
    dde2:	b0 12 30 c3 	call	#0xc330	
    dde6:	c2 4f 7a 02 	mov.b	r15,	&0x027a	

  return;
}
    ddea:	30 41       	ret			

0000ddec <nwk_ping>:
 * @return   SMPL_SUCCESS   valid reply received
 *           SMPL_TIMEOUT   no valid reply received
 *           SMPL_NO_CHANNEL  no channels returned on a scan
 */
smplStatus_t nwk_ping(linkID_t lid)
{
    ddec:	0b 12       	push	r11		
    ddee:	0a 12       	push	r10		
    ddf0:	09 12       	push	r9		
    ddf2:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    ddf6:	49 4f       	mov.b	r15,	r9	
  connInfo_t  *pCInfo   = nwk_getConnInfo(lid);
    ddf8:	b0 12 e0 d0 	call	#0xd0e0	
    ddfc:	0a 4f       	mov	r15,	r10	
  smplStatus_t rc       = SMPL_BAD_PARAM;
  uint8_t      done     = 0;
  uint8_t      repeatIt = 2;
  uint8_t      msg[MAX_PING_APP_FRAME];
  uint8_t      radioState = MRFI_GetRadioState();
    ddfe:	b0 12 9c c4 	call	#0xc49c	
    de02:	4b 4f       	mov.b	r15,	r11	
  {
    ioctlRawSend_t    send;
    ioctlRawReceive_t recv;
  } ioctl_info;

  if (!pCInfo || (SMPL_LINKID_USER_UUD == lid))
    de04:	0a 93       	tst	r10		
    de06:	02 24       	jz	$+6      	;abs 0xde0c
    de08:	79 93       	cmp.b	#-1,	r9	;r3 As==11
    de0a:	07 20       	jnz	$+16     	;abs 0xde1a
  {
    /* either link ID bogus or tried to ping the unconnected user datagram link ID. */
    return rc;
    de0c:	2f 43       	mov	#2,	r15	;r3 As==10
    }
  } while (repeatIt);

  return done ? SMPL_SUCCESS : SMPL_TIMEOUT;

}
    de0e:	31 50 0a 00 	add	#10,	r1	;#0x000a
    de12:	39 41       	pop	r9		
    de14:	3a 41       	pop	r10		
    de16:	3b 41       	pop	r11		
    de18:	30 41       	ret			
#else
    {
      repeatIt = 0;
#endif  /* defined(FREQUENCY_AGILITY) && !defined(ACCESS_POINT) */

      ioctl_info.send.addr = (addr_t *)pCInfo->peerAddr;
    de1a:	2a 53       	incd	r10		
    de1c:	81 4a 02 00 	mov	r10,	2(r1)	;0x0002(r1)
      ioctl_info.send.msg  = msg;
    de20:	81 41 04 00 	mov	r1,	4(r1)	;0x0004(r1)
      ioctl_info.send.len  = sizeof(msg);
    de24:	e1 43 06 00 	mov.b	#2,	6(r1)	;r3 As==10, 0x0006(r1)
      ioctl_info.send.port = SMPL_PORT_PING;
    de28:	d1 43 07 00 	mov.b	#1,	7(r1)	;r3 As==01, 0x0007(r1)

      /* fill in msg */
      msg[PB_REQ_OS] = PING_REQ_PING;
    de2c:	d1 43 00 00 	mov.b	#1,	0(r1)	;r3 As==01, 0x0000(r1)
      msg[PB_TID_OS] = sTid;
    de30:	d1 42 7a 02 	mov.b	&0x027a,1(r1)	;0x0001(r1)
    de34:	01 00 

      SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_WRITE, &ioctl_info.send);
    de36:	0d 41       	mov	r1,	r13	
    de38:	2d 53       	incd	r13		
    de3a:	3e 40 03 00 	mov	#3,	r14	;#0x0003
    de3e:	2f 43       	mov	#2,	r15	;r3 As==10
    de40:	b0 12 2c cf 	call	#0xcf2c	

      ioctl_info.recv.port = SMPL_PORT_PING;
    de44:	d1 43 07 00 	mov.b	#1,	7(r1)	;r3 As==01, 0x0007(r1)
      ioctl_info.recv.msg  = msg;
    de48:	81 41 04 00 	mov	r1,	4(r1)	;0x0004(r1)
      ioctl_info.recv.addr = 0;
    de4c:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00, 0x0002(r1)

      NWK_CHECK_FOR_SETRX(radioState);
    de50:	7b 90 03 00 	cmp.b	#3,	r11	;#0x0003
    de54:	19 24       	jz	$+52     	;abs 0xde88
    de56:	5b 93       	cmp.b	#1,	r11	;r3 As==01
    de58:	21 24       	jz	$+68     	;abs 0xde9c
    de5a:	b0 12 ba c5 	call	#0xc5ba	
      NWK_REPLY_DELAY();
    de5e:	b0 12 10 c4 	call	#0xc410	
      NWK_CHECK_FOR_RESTORE_STATE(radioState);
    de62:	b0 12 7a c5 	call	#0xc57a	

      if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
    de66:	0d 41       	mov	r1,	r13	
    de68:	2d 53       	incd	r13		
    de6a:	2e 43       	mov	#2,	r14	;r3 As==10
    de6c:	2f 43       	mov	#2,	r15	;r3 As==10
    de6e:	b0 12 2c cf 	call	#0xcf2c	
    de72:	0f 93       	tst	r15		
    de74:	0c 20       	jnz	$+26     	;abs 0xde8e
      {
        repeatIt = 0;
        done     = 1;
        sTid++;   /* guard against duplicates */
    de76:	d2 53 7a 02 	inc.b	&0x027a	
    de7a:	0f 43       	clr	r15		
    }
  } while (repeatIt);

  return done ? SMPL_SUCCESS : SMPL_TIMEOUT;

}
    de7c:	31 50 0a 00 	add	#10,	r1	;#0x000a
    de80:	39 41       	pop	r9		
    de82:	3a 41       	pop	r10		
    de84:	3b 41       	pop	r11		
    de86:	30 41       	ret			
      ioctl_info.recv.port = SMPL_PORT_PING;
      ioctl_info.recv.msg  = msg;
      ioctl_info.recv.addr = 0;

      NWK_CHECK_FOR_SETRX(radioState);
      NWK_REPLY_DELAY();
    de88:	b0 12 10 c4 	call	#0xc410	
    de8c:	ec 3f       	jmp	$-38     	;abs 0xde66
      NWK_CHECK_FOR_RESTORE_STATE(radioState);

      if (SMPL_SUCCESS == SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_READ, &ioctl_info.recv))
    de8e:	1f 43       	mov	#1,	r15	;r3 As==01
    }
  } while (repeatIt);

  return done ? SMPL_SUCCESS : SMPL_TIMEOUT;

}
    de90:	31 50 0a 00 	add	#10,	r1	;#0x000a
    de94:	39 41       	pop	r9		
    de96:	3a 41       	pop	r10		
    de98:	3b 41       	pop	r11		
    de9a:	30 41       	ret			

      ioctl_info.recv.port = SMPL_PORT_PING;
      ioctl_info.recv.msg  = msg;
      ioctl_info.recv.addr = 0;

      NWK_CHECK_FOR_SETRX(radioState);
    de9c:	b0 12 a2 c6 	call	#0xc6a2	
    dea0:	b0 12 ba c5 	call	#0xc5ba	
      NWK_REPLY_DELAY();
    dea4:	b0 12 10 c4 	call	#0xc410	
      NWK_CHECK_FOR_RESTORE_STATE(radioState);
    dea8:	b0 12 da c5 	call	#0xc5da	
    deac:	dc 3f       	jmp	$-70     	;abs 0xde66

0000deae <nwk_processPing>:
 * output parameters
 *
 * @return    Keep frame for application, release frame, or replay frame.
 */
fhStatus_t nwk_processPing(mrfiPacket_t *frame)
{
    deae:	0b 12       	push	r11		
    deb0:	0b 4f       	mov	r15,	r11	

  /* If we sent this then this is the reply. Validate the
   * packet for reception by client app. If we didn't send
   * it then we are the target. Send the reply.
   */
  replyType = nwk_isValidReply(frame, sTid, PB_REQ_OS, PB_TID_OS);
    deb2:	5e 42 7a 02 	mov.b	&0x027a,r14	
    deb6:	5c 43       	mov.b	#1,	r12	;r3 As==01
    deb8:	4d 43       	clr.b	r13		
    deba:	b0 12 1a d3 	call	#0xd31a	
  if (SMPL_MY_REPLY == replyType)
    debe:	4f 93       	tst.b	r15		
    dec0:	28 24       	jz	$+82     	;abs 0xdf12
 *
 * @return   void
 */
static void handlePingRequest(mrfiPacket_t *frame)
{
  switch (*(MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS))
    dec2:	db 93 0c 00 	cmp.b	#1,	12(r11)	;r3 As==01, 0x000c(r11)
    dec6:	03 24       	jz	$+8      	;abs 0xdece
  else
  {
    /* No, we didn't send it. Send reply assuming it's a Ping intended for us. */
    handlePingRequest(frame);

    rc = FHS_RELEASE;
    dec8:	0f 43       	clr	r15		
  }

  return rc;
}
    deca:	3b 41       	pop	r11		
    decc:	30 41       	ret			
  frameInfo_t *pOutFrame;

  /* Build the reply frame. The application payload is the one included in the
   * received frame payload.
   */
  if ((pOutFrame = nwk_buildFrame(SMPL_PORT_PING, MRFI_P_PAYLOAD(frame)+F_APP_PAYLOAD_OS, MRFI_GET_PAYLOAD_LEN(frame)-F_APP_PAYLOAD_OS, MAX_HOPS)))
    dece:	7c 40 03 00 	mov.b	#3,	r12	;#0x0003
    ded2:	6d 4b       	mov.b	@r11,	r13	
    ded4:	7d 50 f5 ff 	add.b	#-11,	r13	;#0xfff5
    ded8:	0e 4b       	mov	r11,	r14	
    deda:	3e 50 0c 00 	add	#12,	r14	;#0x000c
    dede:	5f 43       	mov.b	#1,	r15	;r3 As==01
    dee0:	b0 12 94 d5 	call	#0xd594	
    dee4:	0f 93       	tst	r15		
    dee6:	f0 27       	jz	$-30     	;abs 0xdec8
  {
    /* destination address is the source adddress of the received frame. */
    memcpy(MRFI_P_DST_ADDR(&pOutFrame->mrfiPkt), MRFI_P_SRC_ADDR(frame), NET_ADDR_SIZE);
    dee8:	df 4b 05 00 	mov.b	5(r11),	3(r15)	;0x0005(r11), 0x0003(r15)
    deec:	03 00 
    deee:	df 4b 06 00 	mov.b	6(r11),	4(r15)	;0x0006(r11), 0x0004(r15)
    def2:	04 00 
    def4:	df 4b 07 00 	mov.b	7(r11),	5(r15)	;0x0007(r11), 0x0005(r15)
    def8:	05 00 
    defa:	df 4b 08 00 	mov.b	8(r11),	6(r15)	;0x0008(r11), 0x0006(r15)
    defe:	06 00 

    /* turn on the reply bit in the application payload */
    *(MRFI_P_PAYLOAD(&pOutFrame->mrfiPkt)+F_APP_PAYLOAD_OS+PB_REQ_OS) |= NWK_APP_REPLY_BIT;
    df00:	ff d0 80 ff 	bis.b	#-128,	14(r15)	;#0xff80, 0x000e(r15)
    df04:	0e 00 
#ifdef SMPL_SECURE
    nwk_setSecureFrame(&pOutFrame->mrfiPkt, MRFI_GET_PAYLOAD_LEN(frame)-F_APP_PAYLOAD_OS, 0);
#endif  /* SMPL_SECURE */
    nwk_sendFrame(pOutFrame, MRFI_TX_TYPE_FORCED);
    df06:	4e 43       	clr.b	r14		
    df08:	b0 12 a4 d7 	call	#0xd7a4	
  else
  {
    /* No, we didn't send it. Send reply assuming it's a Ping intended for us. */
    handlePingRequest(frame);

    rc = FHS_RELEASE;
    df0c:	0f 43       	clr	r15		
  }

  return rc;
}
    df0e:	3b 41       	pop	r11		
    df10:	30 41       	ret			
  if (SMPL_MY_REPLY == replyType)
  {
    /* It's a match and it's a reply. Validate the received packet by
     * returning a 1 so it can be received by the client app.
     */
    MRFI_PostKillSem();
    df12:	b0 12 8e c4 	call	#0xc48e	
    rc = FHS_KEEP;
    df16:	1f 43       	mov	#1,	r15	;r3 As==01

    rc = FHS_RELEASE;
  }

  return rc;
}
    df18:	3b 41       	pop	r11		
    df1a:	30 41       	ret			

0000df1c <nwk_mgmtInit>:
 * @return   void
 */

void nwk_mgmtInit(void)
{
  sTid = MRFI_RandomByte();
    df1c:	b0 12 30 c3 	call	#0xc330	
    df20:	c2 4f 7c 02 	mov.b	r15,	&0x027c	
#ifdef ACCESS_POINT
  memset(&sSFMarker, 0x0, sizeof(sSFMarker));
#endif

  return;
}
    df24:	30 41       	ret			

0000df26 <nwk_processMgmt>:
 * output parameters
 *
 * @return   Keep frame for application, release frame, or replay frame.
 */
fhStatus_t nwk_processMgmt(mrfiPacket_t *frame)
{
    df26:	0b 12       	push	r11		
    df28:	0b 4f       	mov	r15,	r11	

  /* If we sent this then this is the reply. Validate the
   * packet for reception by client app. If we didn't send
   * it then we are the target. send the reply.
   */
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, MB_APP_INFO_OS, MB_TID_OS)))
    df2a:	5e 42 7c 02 	mov.b	&0x027c,r14	
    df2e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    df30:	4d 43       	clr.b	r13		
    df32:	b0 12 1a d3 	call	#0xd31a	
    df36:	4f 93       	tst.b	r15		
    df38:	0d 24       	jz	$+28     	;abs 0xdf54
  }
#endif  /* !END_DEVICE */
  else
  {
    /* no, we didn't send it. send reply if it's intended for us */
    if (!memcmp(MRFI_P_DST_ADDR(frame), nwk_getMyAddress(), NET_ADDR_SIZE))
    df3a:	b0 12 56 dd 	call	#0xdd56	
    df3e:	2d 42       	mov	#4,	r13	;r2 As==10
    df40:	0e 4f       	mov	r15,	r14	
    df42:	0f 4b       	mov	r11,	r15	
    df44:	1f 53       	inc	r15		
    df46:	b0 12 08 e2 	call	#0xe208	
    df4a:	0f 93       	tst	r15		
    df4c:	01 24       	jz	$+4      	;abs 0xdf50
      /* we're done with the frame. */
      rc = FHS_RELEASE;
    }
    else
    {
      rc = FHS_REPLAY;
    df4e:	2f 43       	mov	#2,	r15	;r3 As==10
  }

  (void) replyType;  /* keep compiler happy */

  return rc;
}
    df50:	3b 41       	pop	r11		
    df52:	30 41       	ret			
  if (SMPL_MY_REPLY == (replyType=nwk_isValidReply(frame, sTid, MB_APP_INFO_OS, MB_TID_OS)))
  {
    /* It's a match and it's a reply. Validate the received packet by
     * returning a 1 so it can be received by the client app.
     */
    MRFI_PostKillSem();
    df54:	b0 12 8e c4 	call	#0xc48e	
    rc = FHS_KEEP;
    df58:	1f 43       	mov	#1,	r15	;r3 As==01
  }

  (void) replyType;  /* keep compiler happy */

  return rc;
}
    df5a:	3b 41       	pop	r11		
    df5c:	30 41       	ret			

0000df5e <nwk_poll>:
 *           SMPL_NO_AP_ADDRESS - We don't know Access Point's address
 *           SMPL_NOMEM         - no room in output frame queue
 *           SMPL_TX_CCA_FAIL   - CCA failure
 */
smplStatus_t nwk_poll(uint8_t port, uint8_t *addr)
{
    df5e:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
  uint8_t        msg[MGMT_POLL_FRAME_SIZE];
  ioctlRawSend_t send;

  msg[MB_APP_INFO_OS] = MGMT_REQ_POLL;
    df62:	d1 43 06 00 	mov.b	#1,	6(r1)	;r3 As==01, 0x0006(r1)
  msg[MB_TID_OS]      = sTid;
    df66:	d1 42 7c 02 	mov.b	&0x027c,7(r1)	;0x0007(r1)
    df6a:	07 00 
  msg[M_POLL_PORT_OS] = port;
    df6c:	c1 4f 08 00 	mov.b	r15,	8(r1)	;0x0008(r1)
  memcpy(msg+M_POLL_ADDR_OS, addr, NET_ADDR_SIZE);
    df70:	f1 4e 09 00 	mov.b	@r14+,	9(r1)	;0x0009(r1)
    df74:	f1 4e 0a 00 	mov.b	@r14+,	10(r1)	;0x000a(r1)
    df78:	f1 4e 0b 00 	mov.b	@r14+,	11(r1)	;0x000b(r1)
    df7c:	e1 4e 0c 00 	mov.b	@r14,	12(r1)	;0x000c(r1)

  /* it's OK to increment the TID here because the reply will not be
   * matched based on this number. The reply to the poll comes back
   * to the client port, not the Management port.
   */
  sTid++;
    df80:	d2 53 7c 02 	inc.b	&0x027c	

  if (!sAPAddr)
    df84:	1f 42 7e 02 	mov	&0x027e,r15	
    df88:	0f 93       	tst	r15		
    df8a:	16 24       	jz	$+46     	;abs 0xdfb8
    if (!sAPAddr)
    {
      return SMPL_NO_AP_ADDRESS;
    }
  }
  send.addr = (addr_t *)sAPAddr;
    df8c:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
  send.msg  = msg;
    df90:	0f 41       	mov	r1,	r15	
    df92:	3f 50 06 00 	add	#6,	r15	;#0x0006
    df96:	81 4f 02 00 	mov	r15,	2(r1)	;0x0002(r1)
  send.len  = sizeof(msg);
    df9a:	f1 40 07 00 	mov.b	#7,	4(r1)	;#0x0007, 0x0004(r1)
    df9e:	04 00 
  send.port = SMPL_PORT_MGMT;
    dfa0:	f1 40 06 00 	mov.b	#6,	5(r1)	;#0x0006, 0x0005(r1)
    dfa4:	05 00 

  return SMPL_Ioctl(IOCTL_OBJ_RAW_IO, IOCTL_ACT_WRITE, &send);
    dfa6:	0d 41       	mov	r1,	r13	
    dfa8:	3e 40 03 00 	mov	#3,	r14	;#0x0003
    dfac:	2f 43       	mov	#2,	r15	;r3 As==10
    dfae:	b0 12 2c cf 	call	#0xcf2c	
}
    dfb2:	31 50 0e 00 	add	#14,	r1	;#0x000e
    dfb6:	30 41       	ret			
   */
  sTid++;

  if (!sAPAddr)
  {
    sAPAddr = nwk_getAPAddress();
    dfb8:	b0 12 ae dd 	call	#0xddae	
    dfbc:	82 4f 7e 02 	mov	r15,	&0x027e	
    if (!sAPAddr)
    dfc0:	0f 93       	tst	r15		
    dfc2:	e4 23       	jnz	$-54     	;abs 0xdf8c
    {
      return SMPL_NO_AP_ADDRESS;
    dfc4:	3f 40 0b 00 	mov	#11,	r15	;#0x000b
    dfc8:	f4 3f       	jmp	$-22     	;abs 0xdfb2

0000dfca <nwk_securityInit>:
    sKey.keyL[i] = ntohl(sKey.keyL[i]);
  }

#endif  /* SMPL_SECURE */
  return;
}
    dfca:	30 41       	ret			

0000dfcc <nwk_processSecurity>:
 * @return    Keep frame for application, release frame, or replay frame.
 */
fhStatus_t nwk_processSecurity(mrfiPacket_t *frame)
{
  return FHS_RELEASE;
}
    dfcc:	0f 43       	clr	r15		
    dfce:	30 41       	ret			

0000dfd0 <nwk_QInit>:
* @return   void
*/
void nwk_QInit(void)
{
#if SIZE_INFRAME_Q > 0
  memset(sInFrameQ, 0, sizeof(sInFrameQ));
    dfd0:	3d 40 34 00 	mov	#52,	r13	;#0x0034
    dfd4:	0e 43       	clr	r14		
    dfd6:	3f 40 80 02 	mov	#640,	r15	;#0x0280
    dfda:	b0 12 1c e4 	call	#0xe41c	
#endif  // SIZE_INFRAME_Q > 0
  memset(sOutFrameQ, 0, sizeof(sOutFrameQ));
    dfde:	3d 40 34 00 	mov	#52,	r13	;#0x0034
    dfe2:	0e 43       	clr	r14		
    dfe4:	3f 40 b4 02 	mov	#692,	r15	;#0x02b4
    dfe8:	b0 12 1c e4 	call	#0xe41c	
}
    dfec:	30 41       	ret			

0000dfee <nwk_QadjustOrder>:
{
  frameInfo_t *pFI;
  uint8_t      i, num;
  bspIState_t  intState;

  if (INQ == which)
    dfee:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    dff0:	01 24       	jz	$+4      	;abs 0xdff4
    dff2:	30 41       	ret			
/*    pFI  = sOutFrameQ; */
/*    num  = SIZE_OUTFRAME_Q; */
    return;
  }

  BSP_ENTER_CRITICAL_SECTION(intState);
    dff4:	0d 42       	mov	r2,	r13	
    dff6:	32 c2       	dint			
    dff8:	03 43       	nop			

  for (i=0; i<num; ++i, ++pFI)
  {
    if ((pFI->fi_usage != FI_AVAILABLE) && (pFI->orderStamp > stamp))
    dffa:	5f 42 80 02 	mov.b	&0x0280,r15	
    dffe:	4f 93       	tst.b	r15		
    e000:	04 24       	jz	$+10     	;abs 0xe00a
    e002:	5f 42 81 02 	mov.b	&0x0281,r15	
    e006:	4e 9f       	cmp.b	r15,	r14	
    e008:	12 28       	jnc	$+38     	;abs 0xe02e
    e00a:	5f 42 9a 02 	mov.b	&0x029a,r15	
    e00e:	4f 93       	tst.b	r15		
    e010:	07 24       	jz	$+16     	;abs 0xe020
    e012:	5f 42 9b 02 	mov.b	&0x029b,r15	
    e016:	4e 9f       	cmp.b	r15,	r14	
    e018:	03 2c       	jc	$+8      	;abs 0xe020
    {
      pFI->orderStamp--;
    e01a:	7f 53       	add.b	#-1,	r15	;r3 As==11
    e01c:	c2 4f 9b 02 	mov.b	r15,	&0x029b	
    }
  }

  BSP_EXIT_CRITICAL_SECTION(intState);
    e020:	3d f2       	and	#8,	r13	;r2 As==11
    e022:	02 20       	jnz	$+6      	;abs 0xe028
    e024:	0f 42       	mov	r2,	r15	
    e026:	30 41       	ret			
    e028:	32 d2       	eint			
    e02a:	0f 42       	mov	r2,	r15	
    e02c:	fc 3f       	jmp	$-6      	;abs 0xe026

  for (i=0; i<num; ++i, ++pFI)
  {
    if ((pFI->fi_usage != FI_AVAILABLE) && (pFI->orderStamp > stamp))
    {
      pFI->orderStamp--;
    e02e:	7f 53       	add.b	#-1,	r15	;r3 As==11
    e030:	c2 4f 81 02 	mov.b	r15,	&0x0281	
    e034:	ea 3f       	jmp	$-42     	;abs 0xe00a

0000e036 <nwk_QfindSlot>:
 * output parameters
 *
 * @return      Pointer to oldest available frame in the queue
 */
frameInfo_t *nwk_QfindSlot(uint8_t which)
{
    e036:	0b 12       	push	r11		
    e038:	0a 12       	push	r10		
    e03a:	09 12       	push	r9		
    e03c:	08 12       	push	r8		
  frameInfo_t *pFI, *oldest= 0, *newFI = 0;
  uint8_t        i, num, newOrder = 0, orderTest;

  if (INQ == which)
    e03e:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    e040:	23 24       	jz	$+72     	;abs 0xe088
    pFI  = sInFrameQ;
    num  = SIZE_INFRAME_Q;
  }
  else
  {
    pFI  = sOutFrameQ;
    e042:	3e 40 b4 02 	mov	#692,	r14	;#0x02b4
 *
 * output parameters
 *
 * @return      Pointer to oldest available frame in the queue
 */
frameInfo_t *nwk_QfindSlot(uint8_t which)
    e046:	09 4e       	mov	r14,	r9	
    e048:	39 50 34 00 	add	#52,	r9	;#0x0034
    e04c:	78 40 03 00 	mov.b	#3,	r8	;#0x0003
    e050:	4b 43       	clr.b	r11		
    e052:	0d 43       	clr	r13		
    e054:	0a 43       	clr	r10		
  orderTest = num + 1;

  for (i=0; i<num; ++i, ++pFI)
  {
    /* if frame is available it's a candidate. */
    if (pFI->fi_usage != FI_AVAILABLE)
    e056:	6c 4e       	mov.b	@r14,	r12	
    e058:	4c 93       	tst.b	r12		
    e05a:	12 24       	jz	$+38     	;abs 0xe080
    {
      if (INQ == which)  /* TODO: do cast-out for Tx as well */
    e05c:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    e05e:	17 24       	jz	$+48     	;abs 0xe08e
    num  = SIZE_OUTFRAME_Q;
  }

  orderTest = num + 1;

  for (i=0; i<num; ++i, ++pFI)
    e060:	3e 50 1a 00 	add	#26,	r14	;#0x001a
    e064:	0e 99       	cmp	r9,	r14	
    e066:	f7 23       	jnz	$-16     	;abs 0xe056
      newFI = pFI;
    }
  }

  /* did we find anything? */
  if (!newFI)
    e068:	0d 93       	tst	r13		
    e06a:	1c 24       	jz	$+58     	;abs 0xe0a4
    newFI->orderStamp = i;
  }
  else
  {
    /* mark the available slot. */
    newFI->orderStamp = ++newOrder;
    e06c:	5b 53       	inc.b	r11		
    e06e:	cd 4b 01 00 	mov.b	r11,	1(r13)	;0x0001(r13)
    e072:	0e 4d       	mov	r13,	r14	
  }

  return newFI;
}
    e074:	0f 4e       	mov	r14,	r15	
    e076:	38 41       	pop	r8		
    e078:	39 41       	pop	r9		
    e07a:	3a 41       	pop	r10		
    e07c:	3b 41       	pop	r11		
    e07e:	30 41       	ret			
        }
      }
    }
    else
    {
      if (OUTQ == which)  /* TODO: do cast-out for Tx as well */
    e080:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    e082:	f8 27       	jz	$-14     	;abs 0xe074
    e084:	0d 4e       	mov	r14,	r13	
    e086:	ec 3f       	jmp	$-38     	;abs 0xe060
  frameInfo_t *pFI, *oldest= 0, *newFI = 0;
  uint8_t        i, num, newOrder = 0, orderTest;

  if (INQ == which)
  {
    pFI  = sInFrameQ;
    e088:	3e 40 80 02 	mov	#640,	r14	;#0x0280
    e08c:	dc 3f       	jmp	$-70     	;abs 0xe046
      {

        /* need to know the number of occupied slots so we know the age value
         * for the unoccupied slot (if there is one).
         */
        newOrder++;
    e08e:	5b 53       	inc.b	r11		

        /* make sure nwk_retrieveFrame() is not processing this frame */
        if (FI_INUSE_TRANSITION == pFI->fi_usage)
    e090:	6c 4e       	mov.b	@r14,	r12	
    e092:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    e094:	e5 27       	jz	$-52     	;abs 0xe060
        {
          continue;
        }
        /* is this frame older than any we've seen? */
        if (orderTest > pFI->orderStamp)
    e096:	5c 4e 01 00 	mov.b	1(r14),	r12	;0x0001(r14)
    e09a:	4c 98       	cmp.b	r8,	r12	
    e09c:	e1 2f       	jc	$-60     	;abs 0xe060
    e09e:	48 4c       	mov.b	r12,	r8	
    e0a0:	0a 4e       	mov	r14,	r10	
    e0a2:	de 3f       	jmp	$-66     	;abs 0xe060

  /* did we find anything? */
  if (!newFI)
  {
    /* queue was full. cast-out happens here...unless... */
    if (!oldest)
    e0a4:	0a 93       	tst	r10		
    e0a6:	0d 24       	jz	$+28     	;abs 0xe0c2
       * the frames are in transition when the Rx interrupt occurs.
       */
      return (frameInfo_t *)0;
    }
    newFI = oldest;
    nwk_QadjustOrder(which, newFI->orderStamp);
    e0a8:	5e 4a 01 00 	mov.b	1(r10),	r14	;0x0001(r10)
    e0ac:	b0 12 ee df 	call	#0xdfee	
    newFI->orderStamp = i;
    e0b0:	ea 43 01 00 	mov.b	#2,	1(r10)	;r3 As==10, 0x0001(r10)
    e0b4:	0e 4a       	mov	r10,	r14	
    /* mark the available slot. */
    newFI->orderStamp = ++newOrder;
  }

  return newFI;
}
    e0b6:	0f 4e       	mov	r14,	r15	
    e0b8:	38 41       	pop	r8		
    e0ba:	39 41       	pop	r9		
    e0bc:	3a 41       	pop	r10		
    e0be:	3b 41       	pop	r11		
    e0c0:	30 41       	ret			
    if (!oldest)
    {
      /* This can happen if the queue is only of size 1 or 2 and all
       * the frames are in transition when the Rx interrupt occurs.
       */
      return (frameInfo_t *)0;
    e0c2:	0e 43       	clr	r14		
    e0c4:	d7 3f       	jmp	$-80     	;abs 0xe074

0000e0c6 <nwk_QfindOldest>:
 *
 * @return      Pointer to frame that is the oldsest on the requested port, or
 *              0 if there are none.
 */
frameInfo_t *nwk_QfindOldest(uint8_t which, rcvContext_t *rcv, uint8_t fi_usage)
{
    e0c6:	0b 12       	push	r11		
    e0c8:	0a 12       	push	r10		
    e0ca:	09 12       	push	r9		
    e0cc:	08 12       	push	r8		
    e0ce:	07 12       	push	r7		
    e0d0:	06 12       	push	r6		
    e0d2:	05 12       	push	r5		
    e0d4:	04 12       	push	r4		
    e0d6:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    e0da:	09 4e       	mov	r14,	r9	
  bspIState_t  intState;
  frameInfo_t *fPtr = 0, *wPtr;
  connInfo_t  *pCInfo = 0;
  uint8_t     *pAddr1 = 0, *pAddr2 = 0, *pAddr3 = 0;

  if (INQ == which)
    e0dc:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    e0de:	42 20       	jnz	$+134    	;abs 0xe164
/*    pFI  = sOutFrameQ; */
/*    num  = SIZE_OUTFRAME_Q; */
    return 0;
  }

  if (RCV_APP_LID == rcv->type)
    e0e0:	2f 4e       	mov	@r14,	r15	
    e0e2:	1f 93       	cmp	#1,	r15	;r3 As==01
    e0e4:	60 24       	jz	$+194    	;abs 0xe1a6
      return (frameInfo_t *)0;
    }
    port   = pCInfo->portRx;
    pAddr2 = pCInfo->peerAddr;
  }
  else if (RCV_NWK_PORT == rcv->type)
    e0e6:	0f 93       	tst	r15		
    e0e8:	3d 20       	jnz	$+124    	;abs 0xe164
  {
    port = rcv->t.port;
    e0ea:	56 4e 02 00 	mov.b	2(r14),	r6	;0x0002(r14)
  uint8_t      i, oldest, num, port;
  uint8_t      uType, addr12Compare;
  bspIState_t  intState;
  frameInfo_t *fPtr = 0, *wPtr;
  connInfo_t  *pCInfo = 0;
  uint8_t     *pAddr1 = 0, *pAddr2 = 0, *pAddr3 = 0;
    e0ee:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00, 0x0002(r1)
{
  uint8_t      i, oldest, num, port;
  uint8_t      uType, addr12Compare;
  bspIState_t  intState;
  frameInfo_t *fPtr = 0, *wPtr;
  connInfo_t  *pCInfo = 0;
    e0f2:	0c 43       	clr	r12		
  else
  {
    return (frameInfo_t *)0;
  }

  uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;
    e0f4:	5d 93       	cmp.b	#1,	r13	;r3 As==01
    e0f6:	38 24       	jz	$+114    	;abs 0xe168
    e0f8:	77 40 03 00 	mov.b	#3,	r7	;#0x0003
  uint8_t      i, oldest, num, port;
  uint8_t      uType, addr12Compare;
  bspIState_t  intState;
  frameInfo_t *fPtr = 0, *wPtr;
  connInfo_t  *pCInfo = 0;
  uint8_t     *pAddr1 = 0, *pAddr2 = 0, *pAddr3 = 0;
    e0fc:	04 43       	clr	r4		

  if (INQ == which)
  {
    wPtr   = sInFrameQ;
    e0fe:	3a 40 80 02 	mov	#640,	r10	;#0x0280
frameInfo_t *nwk_QfindOldest(uint8_t which, rcvContext_t *rcv, uint8_t fi_usage)
{
  uint8_t      i, oldest, num, port;
  uint8_t      uType, addr12Compare;
  bspIState_t  intState;
  frameInfo_t *fPtr = 0, *wPtr;
    e102:	08 43       	clr	r8		

  if (INQ == which)
  {
    wPtr   = sInFrameQ;
    num    = SIZE_INFRAME_Q;
    oldest = SIZE_INFRAME_Q+1;
    e104:	f1 40 03 00 	mov.b	#3,	0(r1)	;#0x0003, 0x0000(r1)
    e108:	00 00 
    {
      wPtr->fi_usage = FI_INUSE_TRANSITION;

      BSP_EXIT_CRITICAL_SECTION(intState);  /* release hold */
      /* message sent to this device? */
      if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&wPtr->mrfiPkt), F_PORT_OS) == port)
    e10a:	45 46       	mov.b	r6,	r5	
        if (RCV_APP_LID == rcv->type)
        {
          if (SMPL_PORT_USER_BCAST == port)
          {
            /* guarantee a match... */
            pAddr1 = pCInfo->peerAddr;
    e10c:	2c 53       	incd	r12		
  uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;

  for (i=0; i<num; ++i, ++wPtr)
  {

    BSP_ENTER_CRITICAL_SECTION(intState);   /* protect the frame states */
    e10e:	0d 42       	mov	r2,	r13	
    e110:	3d f2       	and	#8,	r13	;r2 As==11
    e112:	32 c2       	dint			
    e114:	03 43       	nop			

    /* only check entries in use and waiting for this port */
    if (uType == wPtr->fi_usage)
    e116:	6b 4a       	mov.b	@r10,	r11	
    e118:	47 9b       	cmp.b	r11,	r7	
    e11a:	16 24       	jz	$+46     	;abs 0xe148
        wPtr->fi_usage = uType;
      }
    }
    else
    {
      BSP_EXIT_CRITICAL_SECTION(intState);
    e11c:	0d 93       	tst	r13		
    e11e:	12 20       	jnz	$+38     	;abs 0xe144
    e120:	0d 42       	mov	r2,	r13	
    return (frameInfo_t *)0;
  }

  uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;

  for (i=0; i<num; ++i, ++wPtr)
    e122:	3a 50 1a 00 	add	#26,	r10	;#0x001a
    e126:	3a 90 b4 02 	cmp	#692,	r10	;#0x02b4
    e12a:	f1 23       	jnz	$-28     	;abs 0xe10e
      BSP_EXIT_CRITICAL_SECTION(intState);
    }
  }

  return fPtr;
}
    e12c:	0f 48       	mov	r8,	r15	
    e12e:	31 50 06 00 	add	#6,	r1	;#0x0006
    e132:	34 41       	pop	r4		
    e134:	35 41       	pop	r5		
    e136:	36 41       	pop	r6		
    e138:	37 41       	pop	r7		
    e13a:	38 41       	pop	r8		
    e13c:	39 41       	pop	r9		
    e13e:	3a 41       	pop	r10		
    e140:	3b 41       	pop	r11		
    e142:	30 41       	ret			
        wPtr->fi_usage = uType;
      }
    }
    else
    {
      BSP_EXIT_CRITICAL_SECTION(intState);
    e144:	32 d2       	eint			
    e146:	ec 3f       	jmp	$-38     	;abs 0xe120
    BSP_ENTER_CRITICAL_SECTION(intState);   /* protect the frame states */

    /* only check entries in use and waiting for this port */
    if (uType == wPtr->fi_usage)
    {
      wPtr->fi_usage = FI_INUSE_TRANSITION;
    e148:	ea 42 00 00 	mov.b	#4,	0(r10)	;r2 As==10, 0x0000(r10)

      BSP_EXIT_CRITICAL_SECTION(intState);  /* release hold */
    e14c:	0d 93       	tst	r13		
    e14e:	0e 20       	jnz	$+30     	;abs 0xe16c
    e150:	0d 42       	mov	r2,	r13	
      /* message sent to this device? */
      if (GET_FROM_FRAME(MRFI_P_PAYLOAD(&wPtr->mrfiPkt), F_PORT_OS) == port)
    e152:	5d 4a 0b 00 	mov.b	11(r10),r13	;0x000b(r10)
    e156:	3d f0 3f 00 	and	#63,	r13	;#0x003f
    e15a:	0d 95       	cmp	r5,	r13	
    e15c:	09 24       	jz	$+20     	;abs 0xe170
        }
      }
      else
      {
        /* wrong port. restore state */
        wPtr->fi_usage = uType;
    e15e:	ca 47 00 00 	mov.b	r7,	0(r10)	;0x0000(r10)
    e162:	df 3f       	jmp	$-64     	;abs 0xe122
    pAddr3 = MRFI_P_PAYLOAD(rcv->t.pkt)+F_APP_PAYLOAD_OS+M_POLL_ADDR_OS;
  }
#endif
  else
  {
    return (frameInfo_t *)0;
    e164:	08 43       	clr	r8		
    e166:	e2 3f       	jmp	$-58     	;abs 0xe12c
  }

  uType = (USAGE_NORMAL == fi_usage) ? FI_INUSE_UNTIL_DEL : FI_INUSE_UNTIL_FWD;
    e168:	57 43       	mov.b	#1,	r7	;r3 As==01
    e16a:	c8 3f       	jmp	$-110    	;abs 0xe0fc
    /* only check entries in use and waiting for this port */
    if (uType == wPtr->fi_usage)
    {
      wPtr->fi_usage = FI_INUSE_TRANSITION;

      BSP_EXIT_CRITICAL_SECTION(intState);  /* release hold */
    e16c:	32 d2       	eint			
    e16e:	f0 3f       	jmp	$-30     	;abs 0xe150
        /* Port matches. If the port of interest is a NWK applicaiton we're a
         * match...the NWK applications are not connection-based. If it is a
         * NWK application we need to check the source address for disambiguation.
         * Also need to check source address if it's a raw frame lookup (S&F frame)
         */
        if (RCV_APP_LID == rcv->type)
    e170:	2b 49       	mov	@r9,	r11	
    e172:	1b 93       	cmp	#1,	r11	;r3 As==01
    e174:	29 24       	jz	$+84     	;abs 0xe1c8
        {
          pAddr1 = MRFI_P_DST_ADDR(&wPtr->mrfiPkt);
        }
#endif

        addr12Compare = memcmp(pAddr1, pAddr2, NET_ADDR_SIZE);
    e176:	2d 42       	mov	#4,	r13	;r2 As==10
    e178:	1e 41 02 00 	mov	2(r1),	r14	;0x0002(r1)
    e17c:	0f 44       	mov	r4,	r15	
    e17e:	81 4c 04 00 	mov	r12,	4(r1)	;0x0004(r1)
    e182:	b0 12 08 e2 	call	#0xe208	
        if (  (RCV_NWK_PORT == rcv->type) ||
    e186:	1c 41 04 00 	mov	4(r1),	r12	;0x0004(r1)
    e18a:	0b 93       	tst	r11		
    e18c:	31 20       	jnz	$+100    	;abs 0xe1f0
              (!pAddr3 && !addr12Compare) ||
              (pAddr3 && !memcmp(pAddr3, MRFI_P_SRC_ADDR(&wPtr->mrfiPkt), NET_ADDR_SIZE))
           )
        {
          if (wPtr->orderStamp < oldest)
    e18e:	5d 4a 01 00 	mov.b	1(r10),	r13	;0x0001(r10)
    e192:	6d 91       	cmp.b	@r1,	r13	
    e194:	e4 2f       	jc	$-54     	;abs 0xe15e
          {
            if (fPtr)
    e196:	08 93       	tst	r8		
    e198:	02 24       	jz	$+6      	;abs 0xe19e
            {
              /* restore previous oldest one */
              fPtr->fi_usage = uType;
    e19a:	c8 47 00 00 	mov.b	r7,	0(r8)	;0x0000(r8)
            }
            oldest = wPtr->orderStamp;
            fPtr   = wPtr;
            continue;
    e19e:	08 4a       	mov	r10,	r8	
    e1a0:	c1 4d 00 00 	mov.b	r13,	0(r1)	;0x0000(r1)
    e1a4:	be 3f       	jmp	$-130    	;abs 0xe122
    return 0;
  }

  if (RCV_APP_LID == rcv->type)
  {
    pCInfo = nwk_getConnInfo(rcv->t.lid);
    e1a6:	5f 4e 02 00 	mov.b	2(r14),	r15	;0x0002(r14)
    e1aa:	81 4d 04 00 	mov	r13,	4(r1)	;0x0004(r1)
    e1ae:	b0 12 e0 d0 	call	#0xd0e0	
    e1b2:	0c 4f       	mov	r15,	r12	
    if (!pCInfo)
    e1b4:	1d 41 04 00 	mov	4(r1),	r13	;0x0004(r1)
    e1b8:	0f 93       	tst	r15		
    e1ba:	d4 27       	jz	$-86     	;abs 0xe164
    {
      return (frameInfo_t *)0;
    }
    port   = pCInfo->portRx;
    e1bc:	56 4f 08 00 	mov.b	8(r15),	r6	;0x0008(r15)
    pAddr2 = pCInfo->peerAddr;
    e1c0:	2f 53       	incd	r15		
    e1c2:	81 4f 02 00 	mov	r15,	2(r1)	;0x0002(r1)
    e1c6:	96 3f       	jmp	$-210    	;abs 0xe0f4
         * NWK application we need to check the source address for disambiguation.
         * Also need to check source address if it's a raw frame lookup (S&F frame)
         */
        if (RCV_APP_LID == rcv->type)
        {
          if (SMPL_PORT_USER_BCAST == port)
    e1c8:	76 90 3f 00 	cmp.b	#63,	r6	;#0x003f
    e1cc:	13 24       	jz	$+40     	;abs 0xe1f4
            /* guarantee a match... */
            pAddr1 = pCInfo->peerAddr;
          }
          else
          {
            pAddr1 = MRFI_P_SRC_ADDR(&wPtr->mrfiPkt);
    e1ce:	04 4a       	mov	r10,	r4	
    e1d0:	34 50 07 00 	add	#7,	r4	;#0x0007
        {
          pAddr1 = MRFI_P_DST_ADDR(&wPtr->mrfiPkt);
        }
#endif

        addr12Compare = memcmp(pAddr1, pAddr2, NET_ADDR_SIZE);
    e1d4:	2d 42       	mov	#4,	r13	;r2 As==10
    e1d6:	1e 41 02 00 	mov	2(r1),	r14	;0x0002(r1)
    e1da:	0f 44       	mov	r4,	r15	
    e1dc:	81 4c 04 00 	mov	r12,	4(r1)	;0x0004(r1)
    e1e0:	b0 12 08 e2 	call	#0xe208	
    e1e4:	4d 4f       	mov.b	r15,	r13	
    e1e6:	1c 41 04 00 	mov	4(r1),	r12	;0x0004(r1)
        if (  (RCV_NWK_PORT == rcv->type) ||
              (!pAddr3 && !addr12Compare) ||
    e1ea:	4d 93       	tst.b	r13		
    e1ec:	b8 23       	jnz	$-142    	;abs 0xe15e
    e1ee:	cf 3f       	jmp	$-96     	;abs 0xe18e
        {
          pAddr1 = MRFI_P_DST_ADDR(&wPtr->mrfiPkt);
        }
#endif

        addr12Compare = memcmp(pAddr1, pAddr2, NET_ADDR_SIZE);
    e1f0:	4d 4f       	mov.b	r15,	r13	
    e1f2:	fb 3f       	jmp	$-8      	;abs 0xe1ea
        if (RCV_APP_LID == rcv->type)
        {
          if (SMPL_PORT_USER_BCAST == port)
          {
            /* guarantee a match... */
            pAddr1 = pCInfo->peerAddr;
    e1f4:	04 4c       	mov	r12,	r4	
    e1f6:	ee 3f       	jmp	$-34     	;abs 0xe1d4

0000e1f8 <nwk_getQ>:
 *
 * @return      Pointer to frame queue
 */
frameInfo_t *nwk_getQ(uint8_t which)
{
  return (INQ == which) ? sInFrameQ : sOutFrameQ;
    e1f8:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    e1fa:	03 24       	jz	$+8      	;abs 0xe202
    e1fc:	3f 40 b4 02 	mov	#692,	r15	;#0x02b4
}
    e200:	30 41       	ret			
 *
 * @return      Pointer to frame queue
 */
frameInfo_t *nwk_getQ(uint8_t which)
{
  return (INQ == which) ? sInFrameQ : sOutFrameQ;
    e202:	3f 40 80 02 	mov	#640,	r15	;#0x0280
    e206:	30 41       	ret			

0000e208 <memcmp>:

int
memcmp(s1, s2, n)
const void *s1, *s2;
size_t n;
{
    e208:	0b 12       	push	r11		
    if (n != 0)
    e20a:	0d 93       	tst	r13		
    e20c:	0a 24       	jz	$+22     	;abs 0xe222
    {
        register const unsigned char *p1 = s1, *p2 = s2;

        do
        {
            if (*p1++ != *p2++)
    e20e:	7b 4f       	mov.b	@r15+,	r11	
    e210:	7c 4e       	mov.b	@r14+,	r12	
    e212:	4b 9c       	cmp.b	r12,	r11	
    e214:	04 24       	jz	$+10     	;abs 0xe21e
                return (*--p1 - *--p2);
    e216:	4f 4b       	mov.b	r11,	r15	
    e218:	4e 4c       	mov.b	r12,	r14	
    e21a:	0f 8e       	sub	r14,	r15	
    e21c:	03 3c       	jmp	$+8      	;abs 0xe224
        }
        while (--n != 0);
    e21e:	3d 53       	add	#-1,	r13	;r3 As==11
    e220:	f4 3f       	jmp	$-22     	;abs 0xe20a
    }
    return (0);
    e222:	0f 43       	clr	r15		
}
    e224:	3b 41       	pop	r11		
    e226:	30 41       	ret			

0000e228 <memcpy>:
#endif
#endif
void *dst0;
const void *src0;
register size_t length;
{
    e228:	0b 12       	push	r11		
    e22a:	0a 12       	push	r10		
    e22c:	09 12       	push	r9		
    e22e:	08 12       	push	r8		
    e230:	07 12       	push	r7		
    register char *dst = dst0;
    register const char *src = src0;
    register size_t t;

    if (length == 0 || dst == src)		/* nothing to do */
    e232:	0d 93       	tst	r13		
    e234:	70 24       	jz	$+226    	;abs 0xe316
    e236:	0f 9e       	cmp	r14,	r15	
    e238:	6e 24       	jz	$+222    	;abs 0xe316
     * Macros: loop-t-times; and loop-t-times, t>0
     */
#define	TLOOP(s) if (t) TLOOP1(s)
#define	TLOOP1(s) do { s; } while (--t)

    if ((unsigned int)dst < (unsigned int)src)
    e23a:	34 2c       	jc	$+106    	;abs 0xe2a4
    {
        /*
         * Copy forward.
         */
        t = (int)src;	/* only need low bits */
        if ((t | (int)dst) & wmask)
    e23c:	0c 4e       	mov	r14,	r12	
    e23e:	0c df       	bis	r15,	r12	
    e240:	1c f3       	and	#1,	r12	;r3 As==01
    e242:	1b 24       	jz	$+56     	;abs 0xe27a
        {
            /*
             * Try to align operands.  This cannot be done
             * unless the low bits match.
             */
            if ((t ^ (int)dst) & wmask || length < wsize)
    e244:	0c 4e       	mov	r14,	r12	
    e246:	0c ef       	xor	r15,	r12	
    e248:	1c f3       	and	#1,	r12	;r3 As==01
    e24a:	07 20       	jnz	$+16     	;abs 0xe25a
    e24c:	2d 93       	cmp	#2,	r13	;r3 As==10
    e24e:	07 28       	jnc	$+16     	;abs 0xe25e
                t = length;
            else
                t = wsize - (t & wmask);
    e250:	0b 4e       	mov	r14,	r11	
    e252:	1b f3       	and	#1,	r11	;r3 As==01
    e254:	2c 43       	mov	#2,	r12	;r3 As==10
    e256:	0c 8b       	sub	r11,	r12	
    e258:	03 3c       	jmp	$+8      	;abs 0xe260
        {
            /*
             * Try to align operands.  This cannot be done
             * unless the low bits match.
             */
            if ((t ^ (int)dst) & wmask || length < wsize)
    e25a:	0c 4d       	mov	r13,	r12	
    e25c:	01 3c       	jmp	$+4      	;abs 0xe260
    e25e:	1c 43       	mov	#1,	r12	;r3 As==01
                t = length;
            else
                t = wsize - (t & wmask);
            length -= t;
    e260:	0d 8c       	sub	r12,	r13	
    e262:	0a 4c       	mov	r12,	r10	
    e264:	09 4e       	mov	r14,	r9	
    e266:	0b 4f       	mov	r15,	r11	
            TLOOP1(*dst++ = *src++);
    e268:	fb 49 00 00 	mov.b	@r9+,	0(r11)	;0x0000(r11)
    e26c:	1b 53       	inc	r11		
    e26e:	3a 53       	add	#-1,	r10	;r3 As==11
    e270:	fb 23       	jnz	$-8      	;abs 0xe268
    e272:	0a 4f       	mov	r15,	r10	
    e274:	0a 5c       	add	r12,	r10	
    e276:	0e 5c       	add	r12,	r14	
    e278:	01 3c       	jmp	$+4      	;abs 0xe27c
    {
        /*
         * Copy forward.
         */
        t = (int)src;	/* only need low bits */
        if ((t | (int)dst) & wmask)
    e27a:	0a 4f       	mov	r15,	r10	
            TLOOP1(*dst++ = *src++);
        }
        /*
         * Copy whole words, then mop up any trailing bytes.
         */
        t = length / wsize;
    e27c:	0b 4d       	mov	r13,	r11	
    e27e:	12 c3       	clrc			
    e280:	0b 10       	rrc	r11		
        TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
    e282:	0b 24       	jz	$+24     	;abs 0xe29a
    e284:	09 4b       	mov	r11,	r9	
    e286:	08 4e       	mov	r14,	r8	
    e288:	0c 4a       	mov	r10,	r12	
    e28a:	bc 48 00 00 	mov	@r8+,	0(r12)	;0x0000(r12)
    e28e:	2c 53       	incd	r12		
    e290:	39 53       	add	#-1,	r9	;r3 As==11
    e292:	fb 23       	jnz	$-8      	;abs 0xe28a
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 */
#ifdef MEMCOPY
void *
memcpy(dst0, src0, length)
    e294:	0b 5b       	rla	r11		
    e296:	0e 5b       	add	r11,	r14	
    e298:	0a 5b       	add	r11,	r10	
        /*
         * Copy whole words, then mop up any trailing bytes.
         */
        t = length / wsize;
        TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
        t = length & wmask;
    e29a:	1d f3       	and	#1,	r13	;r3 As==01
        TLOOP(*dst++ = *src++);
    e29c:	3c 24       	jz	$+122    	;abs 0xe316
    e29e:	ea 4e 00 00 	mov.b	@r14,	0(r10)	;0x0000(r10)
    e2a2:	39 3c       	jmp	$+116    	;abs 0xe316
        /*
         * Copy backwards.  Otherwise essentially the same.
         * Alignment works as before, except that it takes
         * (t&wmask) bytes to align, not wsize-(t&wmask).
         */
        src += length;
    e2a4:	0e 5d       	add	r13,	r14	
        dst += length;
    e2a6:	0c 4f       	mov	r15,	r12	
    e2a8:	0c 5d       	add	r13,	r12	
        t = (int)src;
        if ((t | (int)dst) & wmask)
    e2aa:	0b 4c       	mov	r12,	r11	
    e2ac:	0b de       	bis	r14,	r11	
    e2ae:	1b f3       	and	#1,	r11	;r3 As==01
    e2b0:	1b 24       	jz	$+56     	;abs 0xe2e8
        {
            if ((t ^ (int)dst) & wmask || length <= wsize)
    e2b2:	0b 4c       	mov	r12,	r11	
    e2b4:	0b ee       	xor	r14,	r11	
    e2b6:	1b f3       	and	#1,	r11	;r3 As==01
    e2b8:	06 20       	jnz	$+14     	;abs 0xe2c6
    e2ba:	3d 90 03 00 	cmp	#3,	r13	;#0x0003
    e2be:	03 28       	jnc	$+8      	;abs 0xe2c6
                t = length;
            else
                t &= wmask;
    e2c0:	0b 4e       	mov	r14,	r11	
    e2c2:	1b f3       	and	#1,	r11	;r3 As==01
    e2c4:	01 3c       	jmp	$+4      	;abs 0xe2c8
        src += length;
        dst += length;
        t = (int)src;
        if ((t | (int)dst) & wmask)
        {
            if ((t ^ (int)dst) & wmask || length <= wsize)
    e2c6:	0b 4d       	mov	r13,	r11	
                t = length;
            else
                t &= wmask;
            length -= t;
    e2c8:	0d 8b       	sub	r11,	r13	
        /*
         * Copy backwards.  Otherwise essentially the same.
         * Alignment works as before, except that it takes
         * (t&wmask) bytes to align, not wsize-(t&wmask).
         */
        src += length;
    e2ca:	09 4e       	mov	r14,	r9	
        dst += length;
    e2cc:	0a 4c       	mov	r12,	r10	
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 */
#ifdef MEMCOPY
void *
memcpy(dst0, src0, length)
    e2ce:	08 4b       	mov	r11,	r8	
    e2d0:	08 8c       	sub	r12,	r8	
            if ((t ^ (int)dst) & wmask || length <= wsize)
                t = length;
            else
                t &= wmask;
            length -= t;
            TLOOP1(*--dst = *--src);
    e2d2:	3a 53       	add	#-1,	r10	;r3 As==11
    e2d4:	39 53       	add	#-1,	r9	;r3 As==11
    e2d6:	ea 49 00 00 	mov.b	@r9,	0(r10)	;0x0000(r10)
    e2da:	07 4a       	mov	r10,	r7	
    e2dc:	07 58       	add	r8,	r7	
    e2de:	f9 23       	jnz	$-12     	;abs 0xe2d2
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 */
#ifdef MEMCOPY
void *
memcpy(dst0, src0, length)
    e2e0:	3b e3       	inv	r11		
    e2e2:	1b 53       	inc	r11		
    e2e4:	0c 5b       	add	r11,	r12	
    e2e6:	0e 5b       	add	r11,	r14	
            else
                t &= wmask;
            length -= t;
            TLOOP1(*--dst = *--src);
        }
        t = length / wsize;
    e2e8:	0b 4d       	mov	r13,	r11	
    e2ea:	12 c3       	clrc			
    e2ec:	0b 10       	rrc	r11		
        TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
    e2ee:	0e 24       	jz	$+30     	;abs 0xe30c
    e2f0:	0a 4b       	mov	r11,	r10	
    e2f2:	08 4e       	mov	r14,	r8	
    e2f4:	09 4c       	mov	r12,	r9	
    e2f6:	28 83       	decd	r8		
    e2f8:	29 83       	decd	r9		
    e2fa:	a9 48 00 00 	mov	@r8,	0(r9)	;0x0000(r9)
    e2fe:	3a 53       	add	#-1,	r10	;r3 As==11
    e300:	fa 23       	jnz	$-10     	;abs 0xe2f6
 * This is the routine that actually implements
 * (the portable versions of) bcopy, memcpy, and memmove.
 */
#ifdef MEMCOPY
void *
memcpy(dst0, src0, length)
    e302:	0a 8b       	sub	r11,	r10	
    e304:	0b 4a       	mov	r10,	r11	
    e306:	0b 5b       	rla	r11		
    e308:	0e 5b       	add	r11,	r14	
    e30a:	0c 5b       	add	r11,	r12	
            length -= t;
            TLOOP1(*--dst = *--src);
        }
        t = length / wsize;
        TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
        t = length & wmask;
    e30c:	1d f3       	and	#1,	r13	;r3 As==01
        TLOOP(*--dst = *--src);
    e30e:	03 24       	jz	$+8      	;abs 0xe316
    e310:	dc 4e ff ff 	mov.b	-1(r14),-1(r12)	;0xffff(r14), 0xffff(r12)
    e314:	ff ff 
#if defined(MEMCOPY) || defined(MEMMOVE)
    return (dst0);
#else
    return;
#endif
}
    e316:	37 41       	pop	r7		
    e318:	38 41       	pop	r8		
    e31a:	39 41       	pop	r9		
    e31c:	3a 41       	pop	r10		
    e31e:	3b 41       	pop	r11		
    e320:	30 41       	ret			

0000e322 <memmove>:
#endif
#endif
void *dst0;
const void *src0;
register size_t length;
{
    e322:	0b 12       	push	r11		
    e324:	0a 12       	push	r10		
    e326:	09 12       	push	r9		
    e328:	08 12       	push	r8		
    e32a:	07 12       	push	r7		
    register char *dst = dst0;
    register const char *src = src0;
    register size_t t;

    if (length == 0 || dst == src)		/* nothing to do */
    e32c:	0d 93       	tst	r13		
    e32e:	70 24       	jz	$+226    	;abs 0xe410
    e330:	0f 9e       	cmp	r14,	r15	
    e332:	6e 24       	jz	$+222    	;abs 0xe410
     * Macros: loop-t-times; and loop-t-times, t>0
     */
#define	TLOOP(s) if (t) TLOOP1(s)
#define	TLOOP1(s) do { s; } while (--t)

    if ((unsigned int)dst < (unsigned int)src)
    e334:	34 2c       	jc	$+106    	;abs 0xe39e
    {
        /*
         * Copy forward.
         */
        t = (int)src;	/* only need low bits */
        if ((t | (int)dst) & wmask)
    e336:	0c 4e       	mov	r14,	r12	
    e338:	0c df       	bis	r15,	r12	
    e33a:	1c f3       	and	#1,	r12	;r3 As==01
    e33c:	1b 24       	jz	$+56     	;abs 0xe374
        {
            /*
             * Try to align operands.  This cannot be done
             * unless the low bits match.
             */
            if ((t ^ (int)dst) & wmask || length < wsize)
    e33e:	0c 4e       	mov	r14,	r12	
    e340:	0c ef       	xor	r15,	r12	
    e342:	1c f3       	and	#1,	r12	;r3 As==01
    e344:	07 20       	jnz	$+16     	;abs 0xe354
    e346:	2d 93       	cmp	#2,	r13	;r3 As==10
    e348:	07 28       	jnc	$+16     	;abs 0xe358
                t = length;
            else
                t = wsize - (t & wmask);
    e34a:	0b 4e       	mov	r14,	r11	
    e34c:	1b f3       	and	#1,	r11	;r3 As==01
    e34e:	2c 43       	mov	#2,	r12	;r3 As==10
    e350:	0c 8b       	sub	r11,	r12	
    e352:	03 3c       	jmp	$+8      	;abs 0xe35a
        {
            /*
             * Try to align operands.  This cannot be done
             * unless the low bits match.
             */
            if ((t ^ (int)dst) & wmask || length < wsize)
    e354:	0c 4d       	mov	r13,	r12	
    e356:	01 3c       	jmp	$+4      	;abs 0xe35a
    e358:	1c 43       	mov	#1,	r12	;r3 As==01
                t = length;
            else
                t = wsize - (t & wmask);
            length -= t;
    e35a:	0d 8c       	sub	r12,	r13	
    e35c:	0a 4c       	mov	r12,	r10	
    e35e:	09 4e       	mov	r14,	r9	
    e360:	0b 4f       	mov	r15,	r11	
            TLOOP1(*dst++ = *src++);
    e362:	fb 49 00 00 	mov.b	@r9+,	0(r11)	;0x0000(r11)
    e366:	1b 53       	inc	r11		
    e368:	3a 53       	add	#-1,	r10	;r3 As==11
    e36a:	fb 23       	jnz	$-8      	;abs 0xe362
    e36c:	0a 4f       	mov	r15,	r10	
    e36e:	0a 5c       	add	r12,	r10	
    e370:	0e 5c       	add	r12,	r14	
    e372:	01 3c       	jmp	$+4      	;abs 0xe376
    {
        /*
         * Copy forward.
         */
        t = (int)src;	/* only need low bits */
        if ((t | (int)dst) & wmask)
    e374:	0a 4f       	mov	r15,	r10	
            TLOOP1(*dst++ = *src++);
        }
        /*
         * Copy whole words, then mop up any trailing bytes.
         */
        t = length / wsize;
    e376:	0b 4d       	mov	r13,	r11	
    e378:	12 c3       	clrc			
    e37a:	0b 10       	rrc	r11		
        TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
    e37c:	0b 24       	jz	$+24     	;abs 0xe394
    e37e:	09 4b       	mov	r11,	r9	
    e380:	08 4e       	mov	r14,	r8	
    e382:	0c 4a       	mov	r10,	r12	
    e384:	bc 48 00 00 	mov	@r8+,	0(r12)	;0x0000(r12)
    e388:	2c 53       	incd	r12		
    e38a:	39 53       	add	#-1,	r9	;r3 As==11
    e38c:	fb 23       	jnz	$-8      	;abs 0xe384
void *
memcpy(dst0, src0, length)
#else
#ifdef MEMMOVE
void *
memmove(dst0, src0, length)
    e38e:	0b 5b       	rla	r11		
    e390:	0e 5b       	add	r11,	r14	
    e392:	0a 5b       	add	r11,	r10	
        /*
         * Copy whole words, then mop up any trailing bytes.
         */
        t = length / wsize;
        TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
        t = length & wmask;
    e394:	1d f3       	and	#1,	r13	;r3 As==01
        TLOOP(*dst++ = *src++);
    e396:	3c 24       	jz	$+122    	;abs 0xe410
    e398:	ea 4e 00 00 	mov.b	@r14,	0(r10)	;0x0000(r10)
    e39c:	39 3c       	jmp	$+116    	;abs 0xe410
        /*
         * Copy backwards.  Otherwise essentially the same.
         * Alignment works as before, except that it takes
         * (t&wmask) bytes to align, not wsize-(t&wmask).
         */
        src += length;
    e39e:	0e 5d       	add	r13,	r14	
        dst += length;
    e3a0:	0c 4f       	mov	r15,	r12	
    e3a2:	0c 5d       	add	r13,	r12	
        t = (int)src;
        if ((t | (int)dst) & wmask)
    e3a4:	0b 4c       	mov	r12,	r11	
    e3a6:	0b de       	bis	r14,	r11	
    e3a8:	1b f3       	and	#1,	r11	;r3 As==01
    e3aa:	1b 24       	jz	$+56     	;abs 0xe3e2
        {
            if ((t ^ (int)dst) & wmask || length <= wsize)
    e3ac:	0b 4c       	mov	r12,	r11	
    e3ae:	0b ee       	xor	r14,	r11	
    e3b0:	1b f3       	and	#1,	r11	;r3 As==01
    e3b2:	06 20       	jnz	$+14     	;abs 0xe3c0
    e3b4:	3d 90 03 00 	cmp	#3,	r13	;#0x0003
    e3b8:	03 28       	jnc	$+8      	;abs 0xe3c0
                t = length;
            else
                t &= wmask;
    e3ba:	0b 4e       	mov	r14,	r11	
    e3bc:	1b f3       	and	#1,	r11	;r3 As==01
    e3be:	01 3c       	jmp	$+4      	;abs 0xe3c2
        src += length;
        dst += length;
        t = (int)src;
        if ((t | (int)dst) & wmask)
        {
            if ((t ^ (int)dst) & wmask || length <= wsize)
    e3c0:	0b 4d       	mov	r13,	r11	
                t = length;
            else
                t &= wmask;
            length -= t;
    e3c2:	0d 8b       	sub	r11,	r13	
        /*
         * Copy backwards.  Otherwise essentially the same.
         * Alignment works as before, except that it takes
         * (t&wmask) bytes to align, not wsize-(t&wmask).
         */
        src += length;
    e3c4:	09 4e       	mov	r14,	r9	
        dst += length;
    e3c6:	0a 4c       	mov	r12,	r10	
void *
memcpy(dst0, src0, length)
#else
#ifdef MEMMOVE
void *
memmove(dst0, src0, length)
    e3c8:	08 4b       	mov	r11,	r8	
    e3ca:	08 8c       	sub	r12,	r8	
            if ((t ^ (int)dst) & wmask || length <= wsize)
                t = length;
            else
                t &= wmask;
            length -= t;
            TLOOP1(*--dst = *--src);
    e3cc:	3a 53       	add	#-1,	r10	;r3 As==11
    e3ce:	39 53       	add	#-1,	r9	;r3 As==11
    e3d0:	ea 49 00 00 	mov.b	@r9,	0(r10)	;0x0000(r10)
    e3d4:	07 4a       	mov	r10,	r7	
    e3d6:	07 58       	add	r8,	r7	
    e3d8:	f9 23       	jnz	$-12     	;abs 0xe3cc
void *
memcpy(dst0, src0, length)
#else
#ifdef MEMMOVE
void *
memmove(dst0, src0, length)
    e3da:	3b e3       	inv	r11		
    e3dc:	1b 53       	inc	r11		
    e3de:	0c 5b       	add	r11,	r12	
    e3e0:	0e 5b       	add	r11,	r14	
            else
                t &= wmask;
            length -= t;
            TLOOP1(*--dst = *--src);
        }
        t = length / wsize;
    e3e2:	0b 4d       	mov	r13,	r11	
    e3e4:	12 c3       	clrc			
    e3e6:	0b 10       	rrc	r11		
        TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
    e3e8:	0e 24       	jz	$+30     	;abs 0xe406
    e3ea:	0a 4b       	mov	r11,	r10	
    e3ec:	08 4e       	mov	r14,	r8	
    e3ee:	09 4c       	mov	r12,	r9	
    e3f0:	28 83       	decd	r8		
    e3f2:	29 83       	decd	r9		
    e3f4:	a9 48 00 00 	mov	@r8,	0(r9)	;0x0000(r9)
    e3f8:	3a 53       	add	#-1,	r10	;r3 As==11
    e3fa:	fa 23       	jnz	$-10     	;abs 0xe3f0
void *
memcpy(dst0, src0, length)
#else
#ifdef MEMMOVE
void *
memmove(dst0, src0, length)
    e3fc:	0a 8b       	sub	r11,	r10	
    e3fe:	0b 4a       	mov	r10,	r11	
    e400:	0b 5b       	rla	r11		
    e402:	0e 5b       	add	r11,	r14	
    e404:	0c 5b       	add	r11,	r12	
            length -= t;
            TLOOP1(*--dst = *--src);
        }
        t = length / wsize;
        TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
        t = length & wmask;
    e406:	1d f3       	and	#1,	r13	;r3 As==01
        TLOOP(*--dst = *--src);
    e408:	03 24       	jz	$+8      	;abs 0xe410
    e40a:	dc 4e ff ff 	mov.b	-1(r14),-1(r12)	;0xffff(r14), 0xffff(r12)
    e40e:	ff ff 
#if defined(MEMCOPY) || defined(MEMMOVE)
    return (dst0);
#else
    return;
#endif
}
    e410:	37 41       	pop	r7		
    e412:	38 41       	pop	r8		
    e414:	39 41       	pop	r9		
    e416:	3a 41       	pop	r10		
    e418:	3b 41       	pop	r11		
    e41a:	30 41       	ret			

0000e41c <memset>:
memset(dst0, c0, length)
void *dst0;
register int c0;
register size_t length;
#endif
{
    e41c:	0b 12       	push	r11		
    e41e:	0a 12       	push	r10		
    e420:	09 12       	push	r9		
    e422:	08 12       	push	r8		
     *		 dst		 dst+length-1
     *
     * but we use a minimum of 3 here since the overhead of the code
     * to do word writes is substantial.
     */
    if (length < 3 * wsize)
    e424:	3d 90 06 00 	cmp	#6,	r13	;#0x0006
    e428:	09 2c       	jc	$+20     	;abs 0xe43c
    e42a:	0c 4f       	mov	r15,	r12	
    e42c:	04 3c       	jmp	$+10     	;abs 0xe436
    {
        while (length != 0)
        {
            *dst++ = VAL;
    e42e:	cc 4e 00 00 	mov.b	r14,	0(r12)	;0x0000(r12)
    e432:	1c 53       	inc	r12		
            --length;
    e434:	3d 53       	add	#-1,	r13	;r3 As==11
     * but we use a minimum of 3 here since the overhead of the code
     * to do word writes is substantial.
     */
    if (length < 3 * wsize)
    {
        while (length != 0)
    e436:	0d 93       	tst	r13		
    e438:	fa 23       	jnz	$-10     	;abs 0xe42e
    e43a:	20 3c       	jmp	$+66     	;abs 0xe47c
        }
        RETURN;
    }

#ifndef BZERO
    if ((c = (u_char)c0) != 0)
    e43c:	4e 4e       	mov.b	r14,	r14	
    e43e:	4b 4e       	mov.b	r14,	r11	
    e440:	0b 93       	tst	r11		
    e442:	03 24       	jz	$+8      	;abs 0xe44a
    {	/* Fill the word. */
        c = (c << 8) | c;	/* u_int is 16 bits. */
    e444:	0c 4b       	mov	r11,	r12	
    e446:	8c 10       	swpb	r12		
    e448:	0b dc       	bis	r12,	r11	
        c = (c << 32) | c;	/* u_int is 64 bits. */
#endif
    }
#endif
    /* Align destination by filling in bytes. */
    if ((t = (long)((int)dst) & wmask) != 0)
    e44a:	1f b3       	bit	#1,	r15	;r3 As==01
    e44c:	06 24       	jz	$+14     	;abs 0xe45a
    {
        t = wsize - t;
        length -= t;
    e44e:	3d 53       	add	#-1,	r13	;r3 As==11
        do
        {
            *dst++ = VAL;
    e450:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    e454:	09 4f       	mov	r15,	r9	
    e456:	19 53       	inc	r9		
    e458:	01 3c       	jmp	$+4      	;abs 0xe45c
        c = (c << 32) | c;	/* u_int is 64 bits. */
#endif
    }
#endif
    /* Align destination by filling in bytes. */
    if ((t = (long)((int)dst) & wmask) != 0)
    e45a:	09 4f       	mov	r15,	r9	
        }
        while (--t != 0);
    }

    /* Fill words.  Length was >= 2*words so we know t >= 1 here. */
    t = length / wsize;
    e45c:	0c 4d       	mov	r13,	r12	
    e45e:	12 c3       	clrc			
    e460:	0c 10       	rrc	r12		
    e462:	0a 49       	mov	r9,	r10	
    e464:	08 4c       	mov	r12,	r8	
    do
    {
        *(u_int *)dst = WIDEVAL;
    e466:	8a 4b 00 00 	mov	r11,	0(r10)	;0x0000(r10)
        dst += wsize;
    e46a:	2a 53       	incd	r10		
    }
    while (--t != 0);
    e46c:	38 53       	add	#-1,	r8	;r3 As==11
    e46e:	fb 23       	jnz	$-8      	;abs 0xe466
#define	RETURN	return (dst0)
#define	VAL	c0
#define	WIDEVAL	c

void *
memset(dst0, c0, length)
    e470:	0c 5c       	rla	r12		
    do
    {
        *(u_int *)dst = WIDEVAL;
        dst += wsize;
    }
    while (--t != 0);
    e472:	0c 59       	add	r9,	r12	

    /* Mop up trailing bytes, if any. */
    t = length & wmask;
    e474:	1d f3       	and	#1,	r13	;r3 As==01
    if (t != 0)
    e476:	02 24       	jz	$+6      	;abs 0xe47c
        do
        {
            *dst++ = VAL;
    e478:	cc 4e 00 00 	mov.b	r14,	0(r12)	;0x0000(r12)
        }
        while (--t != 0);
    RETURN;
}
    e47c:	38 41       	pop	r8		
    e47e:	39 41       	pop	r9		
    e480:	3a 41       	pop	r10		
    e482:	3b 41       	pop	r11		
    e484:	30 41       	ret			

0000e486 <_unexpected_>:
    e486:	00 13       	reti			

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	ea c0 ea c0 ea c0 d0 cc ea c0 ea c0 ea c0 ea c0     ................
    fff0:	ea c0 ea c0 ea c0 ea c0 ea c0 ea c0 ea c0 00 c0     ................
